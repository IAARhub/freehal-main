#
# This file is part of FreeHAL 2010.
#
# Copyright(c) 2006, 2007, 2008, 2009, 2010 Tobias Schulz and contributors.
# http://freehal.org
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

define action save_facts with array facts_parsed, hash tags, var pro_file_name, var prepend, flag no_reread, var lang, var path do

    if not var pro_file_name do
        set var pro_file_name to var path concat '/lang_' concat var lang concat '/facts.pro'
    done

    set new array line_array to an empty array

    for each new hash parsed in array facts_parsed do
        set new var line to ''
        set new var truth to "(maybe)"

print hash parsed
print new line
        
        set new array verbs to from hash parsed element { 'verbs' }
        for each new array verb in array verbs do
            set var verb to from array verb 1st element
            
print "verb: " concat var verb concat new line

            do regex with var verb: /<[|]>.*/ -> "" :global:i
        
            set new var verb_category to verb_category with var verb
            if var verb_category and var verb not matches /\// do
                set var verb to var verb concat "/" concat var verb_category
            done

print "verb: " concat var verb concat new line
            
            if var verb matches /opposite/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/opposite.pro'
            done
            
            if var verb matches /reasonof/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/beziehungen.pro'
            done
        done
        set new array subjects to from hash parsed element { 'subjects' }
        for each new array subject in array subjects do
            set var subject to from array subject 1st element
        done
        set new array objects to from hash parsed element { 'objects' }
        set new array adverbs to from hash parsed element { 'adverbs' }
        set new flag clear_all_objects to 0
        for each new array object in array objects do
            if flag clear_all_objects do
                set var object to ''
                go to next
            done
            if from array object 1st element matches /^(nicht|not)$/ do
                set new array temp to an empty array
                push into array temp, from array object 1st element
                push into array adverbs, array temp
                set var object to ''
                go to next
            done
            
            if from array object 1st element matches /^.?\(true\).?$/ do
                set var truth to "(true)"
                set var object to ''
                go to next
            done
            if from array object 1st element matches /^.?\(maybe\).?$/ do
                set var truth to "(maybe)"
                set var object to ''
                go to next
            done
            if from array object 1st element matches /^.?\(false\).?$/ do
                set var truth to "(false)"
                set var object to ''
                go to next
            done
            
            if from array object 1st element matches /^.?\(bad\).?$/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/ps_dateien/ps-bad.pro'
            done
            if from array object 1st element matches /^.?\(good\).?$/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/ps_dateien/ps-good.pro'
            done
            
            set var object to from array object 1st element
            
            if from array verbs 1st element matches "~~~" do
                if from hash tags element { var object } and from hash sym_noun element { from hash tags element { var object } 1st element } do
                    set flag clear_all_objects to 1
                done
            done
        done
        for each new array adverb in array adverbs do
            if from array adverb 1st element matches /^.?\(true\).?$/ do
                set var truth to "(true)"
                set var adverb to ''
                go to next
            done
            if from array adverb 1st element matches /^.?\(maybe\).?$/ do
                set var truth to "(maybe)"
                set var adverb to ''
                go to next
            done
            if from array adverb 1st element matches /^.?\(false\).?$/ do
                set var truth to "(false)"
                set var adverb to ''
                go to next
            done
            
            if from array adverb 1st element matches /^.?\(logic\).?$/ do
                set var adverb to '(logic)'
                go to next
            done
            
            set var adverb to from array adverb 1st element
        done
        
        # TEXT
        # Replace ~~~ with =
        # CODE
        if from array verbs 1st element matches "~~~" do
            set from array verbs to an empty array
            set from array verbs 1st element to "="
            set from hash parsed element { 'verbs' } to array verbs
        done
        
        # TEXT
        # Delete all other verbs if there is a "="
        # CODE
        if from array verbs 1st element matches "=" do
            set from array verbs to an empty array
            set from array verbs 1st element to "="
            set from hash parsed element { 'verbs' } to array verbs
            
            set new var objects to join using ' ', elements of that array: from hash parsed element { 'objects' } end of elements
            set new var adverbs to join using ' ', elements of that array: from hash parsed element { 'adverbs' } end of elements
            if var objects do
                if not var adverbs matches /^\s*?(in|von)\s+?...?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?$/ do
                    set from hash parsed element { 'adverbs' } to an empty array
                done
            done
            
            if var objects not matches /./ and var adverbs not matches /./ do
                go to next
            done
        done

#        set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'verbs' } end of elements
        set var line to var line concat join using ' ', elements of array verbs
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'subjects' } end of elements
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'objects' } end of elements
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'adverbs' } end of elements
        
        if not from hash parsed element { 'clauses' } do
            set from hash parsed element { 'clauses' } to an empty array
            set new hash empty_clause to an empty hash
            set from hash empty_clause element { 'verbs' } to an empty array
            set from hash empty_clause element { 'subjects' } to an empty array
            set from hash empty_clause element { 'objects' } to an empty array
            set from hash empty_clause element { 'adverbs' } to an empty array
            set from hash empty_clause element { 'questionword' } to an empty array
            do push elements of that array: from hash parsed element { 'clauses' } end of elements, hash empty_clause
        done
        
        if that array is empty: from hash parsed element { 'verbs' } end check and that array is empty: from hash parsed element { 'clauses' } end check do
            go to next
        done
        
        set new array clauses to from hash parsed element { 'clauses' }
        
        set new var number_of_clauses to 0
        for each new hash parsed in array clauses is rw do
            if var number_of_clauses do
                set var line to var line concat ' <> '
            done
            else do
                set var line to var line concat ' <> '
            done
        
            set new array verbs to from hash parsed element { 'verbs' }
            for each new array verb in array verbs do
                set var verb to from array verb 1st element
                
                do regex with var verb: /<[|]>.*/ -> "" :global:i
        
                set new var verb_category to verb_category with var verb
                if var verb_category and var verb not matches /\// do
                    set var verb to var verb concat "/" concat var verb_category
                done
            done
            set new array subjects to from hash parsed element { 'subjects' }
            for each new array subject in array subjects do
                set var subject to from array subject 1st element
            done
            set new array objects to from hash parsed element { 'objects' }
            for each new array object in array objects do
                set var object to from array object 1st element
            done
            set new array adverbs to from hash parsed element { 'adverbs' }
            for each new array adverb in array adverbs do
                set var adverb to from array adverb 1st element
            done
            if not from hash parsed element { 'questionword' } do
                set from hash parsed element { 'questionword' } to an empty array
            done
            set new array questionwords to from hash parsed element { 'questionword' }
            for each new array questionword in array questionwords do
                set var questionword to from array questionword 1st element
            done
            
            set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'verbs' } end of elements
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'subjects' } end of elements
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'objects' } end of elements
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'adverbs' } end of elements
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', elements of that array: from hash parsed element { 'questionword' } end of elements
            
            set var number_of_clauses to var number_of_clauses + 1
        done
        ###set var line to var line concat ' <> '
        set var line to var line concat ' '
        set var line to var line concat var truth
        
        push into array line_array, var line
    done
    
    set new var divisor to ' ~ '
    set new var line to join with var divisor, elements of array line_array
    
    do regex with var line: /\{\{\{questionword\}\}\}/ -> "" :global

    do regex with var line: /<[_]>+/ -> "_" :global
    
    if var pro_file_name matches "-" do
        print "Do not write any facts."
        print new line
    done
    else do
        set new var pro_file to handle for file name var pro_file_name, append
        print "Write some facts into " concat var pro_file_name concat "."
        print new line

        if var line do
            print into var pro_file data var prepend
            print into var pro_file data lc(var line)
            print into var pro_file data new line
        done
        
        do close with var pro_file
        
        if not flag no_reread do
            do reread_pro_file with var pro_file_name, var lang
        done
    done
    
    do return with var line
done

define action update_list_of_pro_file with var file, var lang, var path do
    set new var input_pro to handle for file name var file, read
    set new var file_output to var file
    do regex with var file_output: /.pro/ -> ".list" :global
    set new var output_list to handle for file name var file_output, write
    do close with output_list
    
    for each new var line from var input_pro do
        set new array results to to_array_from_pro_line with var line, var lang
        set new hash parsed to fake_hash_parsed without arguments
        set new array output_array to phrase with var lang, var path, "default", array results, hash parsed
        
        for each new array output_line in array output_array do
            if from array output_line 2nd element do
                set new var output_list to handle for file name var file_output, append
                
                set new hash tags to an empty hash
                
                set new var final_output to upper_case_correction with from array output_line 2nd element, hash tags, var lang, var path
                print into var output_list data var final_output
                print into var output_list data new line
                
                do close with output_list
            done
        done
    done
done

define action reread_pro_file with var file, var lang do
    if exists: "SLOW", end test do
        print "Don't read a .pro file in SLOW mode."
        print new line
        do return with 1
    done
    do wait 1 seconds
    # TEXT
    # Write the signal file for re-reading
    # CODE
    set new var output_handle to handle for file name "_output__add_pro_file", write
    print into var output_handle data var file
    do close with var output_handle

    do trigger_check_files without arguments

    do wait 2 seconds
done

define action work_prot_line with var input, var file_name, var lang, var path do

    set new var classification to ''
    if var input matches /^(\S+?[:][:])/ do
        set var classification to $0
        do regex with var input: /^(\S+?)[:][:]/ -> "" :global
    done

    do be_slow without arguments
    do regex with var input: /(<[.!?]>)/ -> "" :global
    # TEXT
    # Make the komma's readable.
    # CODE
    set (var input, new var no_change_pronouns) to compute_input with var input, var lang, var path
    set var input to make_parsable with var input
    
    do regex with var input: /(\s|^)(wie|wer|was|wo|wann|warum|wieso|weshalb|who|how|where|when|if|what) / -> "$0 _$1_ _no-question_ " :global:i
    do regex with var input: /<[,]>\s/ -> " KOMMA " :global:i
    do regex with var input: /(\D)<[.]>/ -> "${1} DOT " :global:i
    do regex with var input: /\s+/ -> " " :global:i
    set new array clauses_input to split with " KOMMA ", var input
    set new hash parsed to fake_hash_parsed without arguments
    set new flag number_of_clause to 0
    set new hash tags to an empty hash
    for each new var clause in array clauses_input do
        do be_slow without arguments

        # TEXT
        # Split the sentence.
        # CODE
        
        set new array words to split with " ", var clause
        
        # TEXT
        # Then compute the parts of speech etc.
        # CODE
        for each new var word in array words is rw do
            do be_slow without arguments
            set from hash tags element { var word } to compute_tags with var word, var lang, var path
        end for
        
        # TEXT
        # Then toggle the identities (user <-> machine).
        # CODE
        if flag number_of_clause is 0 do
            set new array data to input_data_for_bottom_up_parser with array words, hash tags, var lang, var path
            set hash parsed to new_parser_start with global array grammar, array data, var lang, var path
            if hash parsed is false do
                set hash parsed to parse with var lang, array words, hash tags
            done
            set new array entities to an empty array
            push into array entities, elements of that array: from hash parsed element { 'subjects' } end of elements
            push into array entities, elements of that array: from hash parsed element { 'objects' } end of elements
            set from hash parsed element { 'verbs' } to toggle_verbs using from hash parsed element { 'verbs' }, array entities
            set from hash parsed element { 'subjects' } to toggle_entities using from hash parsed element { 'subjects' }
            set from hash parsed element { 'objects' } to toggle_entities using from hash parsed element { 'objects' }
            set from hash parsed element { 'adverbs' } to toggle_entities using from hash parsed element { 'adverbs' }
            set from hash parsed element { 'clauses' } to an empty array
            
            set flag number_of_clause to 1
        done
        else do
            set new array data to input_data_for_bottom_up_parser with array words, hash tags, var lang, var path
            set new hash parsed_clause to new_parser_start with global array grammar, array data, var lang, var path
            if hash parsed is false do
                set hash parsed_clause to parse with var lang, array words, hash tags
            done
            set new array entities to an empty array
            push into array entities, elements of that array: from hash parsed_clause element { 'subjects' } end of elements
            push into array entities, elements of that array: from hash parsed_clause element { 'objects' } end of elements
            set from hash parsed_clause element { 'verbs' } to toggle_verbs using from hash parsed_clause element { 'verbs' }, array entities
            set from hash parsed_clause element { 'subjects' } to toggle_entities using from hash parsed_clause element { 'subjects' }
            set from hash parsed_clause element { 'objects' } to toggle_entities using from hash parsed_clause element { 'objects' }
            set from hash parsed_clause element { 'adverbs' } to toggle_entities using from hash parsed_clause element { 'adverbs' }
            set from hash parsed_clause element { 'clauses' } to an empty array
            if not from hash parsed_clause element { 'questionword' } do
                set from hash parsed_clause element { 'questionword' } to an empty array
            done
            push into that array: from hash parsed element { 'clauses' }, hash parsed_clause
        done
    done
    if not is an empty hash parsed do
        do save_facts with [ hash parsed ], hash tags, var file_name, var classification, 1, var lang, var path
    done
done

define action transform_psprot_line with var line, var main_word, var current_language, var path do
    do regex with var line: /^\s+/ -> "" :global
    do regex with var line: /\s+$/ -> "" :global
    do regex with var line: /\s+/ -> " " :global
    set new array words to an empty array
    set array words to split with /<[",.;!?]>/, var line
    
    if var main_word matches /^.?bad.?$/ do
        set var main_word to "_(bad)_"
    done
    if var main_word matches /^.?good.?$/ do
        set var main_word to "_(good)_"
    done
    
    set new array lines to an empty array
    if not lc(var main_word) matches var main_word do
        for each new var word in array words do
            if var word do
                if not lc(var word) matches var word do
                    push into array lines, var word concat ' = ' concat var main_word
                done
                else do
                    push into array lines, '"' concat var word concat '" = ' concat var main_word
                done
            done
        done
    done
    else do
        for each new var word in array words do
            if var word do
                if not lc(var word) matches var word do
                    push into array lines, var word concat ' = "' concat var main_word concat '"'
                done
                else do
                    push into array lines, '"' concat var word concat '" = "' concat var main_word concat '"'
                done
            done
        done
    done
    
    do return with array lines
done

define action init_part_of_speech_pro_file with var current_language, var path do

    set new var path_pos_dest to var path concat '/lang_' concat var current_language concat '/part_of_speech.pro'
    if exists: var path_pos_dest, end test do
        do return without arguments
    done
    set new var path_pos_dest_handle to handle for file name var path_pos_dest, write

    set new array sub_directories to an empty array
    push into array sub_directories, 'word_types.brain'
#    push into array sub_directories, 'word_types.memory'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var path_pos_source to var path concat '/lang_' concat var current_language concat '/' concat var sub_dir
        set new var path_pos_source_handle to handle for file name var path_pos_source, read

        set new var entry to ""

        for each new var _line from var path_pos_source_handle is rw do
            do be_slow without arguments

            if var _line matches /^.?.?type:\s?(.*?)$/ do
                set new var pos_raw to $0
                set new var pos_word to get_pos_word with var pos_raw
        
                if var pos_raw matches /^(v).?.?$/ and var pos_word do
                    if var entry not matches /_/ do
                        print into var path_pos_dest_handle data "is-a <> _" concat var entry concat "_ <> (a) " concat var pos_word concat " <>  <> (maybe)" concat new line
                    done
                done
            done
            else do
                if var _line matches /^([^\s]*?):/ do
                    set var entry to $0
                done
            done
        done
    done
    
done

define action init_prot_files with var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set var save_path to var save_path concat var current_language concat '/'
    do mkdir with var save_path
    do mkdir with var path concat '/lang_' concat var current_language concat '/wiki'
    set new array sub_directories to [ '', '/thesaurus', '/..' ]   
    push into array sub_directories, '/namen'
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .prot files by parsing them
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name
        
            do be_slow without arguments
            if not var file matches /prot$/ do
                go to next
            done
            if var file matches /wiki\// do
                go to next
            done
            
            set new var pro_file to var file
            do regex with var pro_file: /t$/ -> "" :i
            
            #if (not var pro_file matches /data/) or exists: var pro_file, end test do
            #    go to next
            #done

            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done

            if not var i is var j do

                print "Read (prot) file "
                print var file
                print new line
                
                do be_slow without arguments
                
                set new var pro_handle to handle for file name var pro_file, write
                do close with var pro_handle
                do be_slow without arguments
                
                set new var translation_input_handle to handle for file name var file, read
                for each new var _line from var translation_input_handle is rw do
                    do be_slow without arguments
                    
                    print "in init_prot_files (1): "
                    print var _line
                    print new line
                    
                    if var _line matches /<[#]>/ do
                        print into var pro_file data var _line
                        print into var pro_file data new line
                        go to next
                    done
                
                    set new array lines to an empty array
                    if var file matches /ps-(.*?).prot/ do
                        set new var main_words_str to $0
                        set new array main_words to split with /<[-]>/, var main_words_str
                        for each new var main_word in array main_words do
                            set new array subarray to transform_psprot_line with var _line, var main_word, var current_language, var path
                            push into array lines, elements of array subarray
                        done
                    done
                    else do
                        push into array lines, var _line
                    done
                    
                    for each new var line in array lines do
                        print "in init_prot_files (2): "
                        print var line
                        print new line
                        do work_prot_line with var line, var pro_file, var current_language, var path
                    done
                done
                do close using var translation_input_handle
                
                do reread_pro_file with var pro_file, var current_language

                do be_slow without arguments
                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

            done
        done
    done
done

define action transform_csv_line with var line, var current_language, var path do

    set new var delete_chars to '"\''
    do regex with var line: /<[var delete_chars]>/ -> "" :global

    do regex with var line: /^\s+/ -> "" :global
    do regex with var line: /\s+$/ -> "" :global
    do regex with var line: /\s+/ -> " " :global
    set new array words to an empty array
    set array words to split with /<[,;]>/, var line

    set new var main_word to shift from array words

    set new array hashes to an empty array
    for each new var word in array words do
        if var word do

            set new var verb to '~'
            if var word matches /<[A-Z]>/ do
                set var verb to '='
            done

            set new hash parsed to fake_hash_parsed without arguments
            push into that array: from hash parsed element { 'verbs' }, [ var verb ]
            push into that array: from hash parsed element { 'subjects' }, [ var word ]
            push into that array: from hash parsed element { 'objects' }, [ var main_word ]

            push into array hashes, hash parsed
        done
    done

    do return with array hashes
done

define action init_csv_files with var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set var save_path to var save_path concat var current_language concat '/'
    do mkdir with var save_path
    do mkdir with var path concat '/lang_' concat var current_language concat '/wiki'
    set new array sub_directories to [ '', '/thesaurus', '/..' ]   
    push into array sub_directories, '/namen'
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .prot files by parsing them
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name
        
            do be_slow without arguments
            if not var file matches /csv$/ do
                go to next
            done
            if var file matches /((remove-words)|(verbs)).csv/ do
                go to next
            done

            set new var pro_file to var file
            do regex with var pro_file: /csv$/ -> "pro" :i
            
            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done

            if not var i is var j do

                print "Read (prot) file "
                print var file
                print new line
                
                do be_slow without arguments
                
                set new var pro_handle to handle for file name var pro_file, write
                do close with var pro_handle
                do be_slow without arguments
                
                set new var translation_input_handle to handle for file name var file, read

                # first line contains column names
                set new var dummy to the next line from var translation_input_handle

                for each new var _line from var translation_input_handle is rw do
                    do be_slow without arguments
                    
                    print "in init_csv_files (1): "
                    print var _line
                    print new line
                    
                    if var _line matches /<[#]>/ do
                        print into var pro_file data var _line
                        print into var pro_file data new line
                        go to next
                    done
                
                    set new array lines to an empty array
                    set new array subarray to transform_csv_line with var _line, var current_language, var path
                    push into array lines, elements of array subarray
                    
                    set new hash tags to an empty hash
                    set new var classification to ''
                    for each new hash parsed in array lines do
                        do save_facts with [ hash parsed ], hash tags, var pro_file, var classification, 1, var current_language, var path
                    done
                done
                do close using var translation_input_handle
                
                do reread_pro_file with var pro_file, var current_language

                do be_slow without arguments
                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

            done
        done
    done
done

define action update_list_of_pro_files with var pattern, var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set var save_path to var save_path concat var current_language concat '/'
    do mkdir with var save_path
    set new array sub_directories to [ '', '/thesaurus' ]
    push into array sub_directories, '/namen'   
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .pro files by sending a signal to the C thread
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name

            if not var file matches /\.pro$/ do
                go to next
            done
            if not var file matches /$pattern/ do
                go to next
            done
            do update_list_of_pro_file with var file, var current_language, var path

        done
    done
done

define action correct_human_edit_typos with var file, var current_language, var path do
    set new var input_1 to handle for file name var file, read
    set new var output_1 to handle for file name var file concat ".tmp", write
    for each new var line from var input_1 is rw do
        set new var _copy to var line
        
        set new array parts to split using /<[<]><[>]>/, var line
        set new var j to 1
        for each new var part in array parts do
            if var part matches /_/ or var part matches /time/ do
                set var part to " " concat var part concat " "
                if var part not matches /\s<[a-z0-9]>\s/ and var j is not 4 and (var j - 4) % 4 is not 0 do
                    do regex with var part: /\s/ -> "_" :global
                    do regex with var part: /<[_]>+/ -> "_" :global
                    set var part to " " concat var part concat " "
                done
                do regex with var part: /_time_from/ -> " time_from" :global
                do regex with var part: /_time_to/ -> " time_to" :global
                if var part matches / time_(to|from)/ do
                    do regex with var part: /(<[a-z0-9]>)_/ -> "$0 " :global
                    do regex with var part: /_/ -> " " :global
                done
                do regex with var part: / time from/ -> " time_from" :global
                do regex with var part: / time to/ -> " time_to" :global
                do regex with var part: /(<[a-z)(]>)<[;]>(<[a-z)(]>)/ -> "$0 $1" :global

                do regex with var part: /(<[(\[]>)_/ -> "$0" :global
                do regex with var part: /_(<[)\]]>)/ -> "$0" :global
                do regex with var part: /^\s+/ -> " " :global
                do regex with var part: /\s+$/ -> " " :global
            done
            set var j to var j + 1
        done
        set var line to join using "<>", elements of array parts
        do regex with var line: /(<[a-zA-Z]>)_maybe_/ -> "$0_ (maybe)"
        do regex with var line: /\s_\(a\)_/ -> " (a) _"
        do regex with var line: /_\(a\)_/ -> "(a) _"

        do regex with var line: /<[;]>{2}/ -> "<>"
        do regex with var line: /^((?:.*?<[<]><[>]>\s+?){6,})\(((?:true)|(?:maybe)|(?:false)|(?:logic))\)/ -> "$0($1)"
        
        if var _copy not matches var line do
            print "Corrected typo:    " concat var _copy concat new line
            print "                => " concat var line concat new line
        done
    
        print into var output_1 data var line
        print into var output_1 data new line
    done
    do close with var input_1
    do close with var output_1
    
    set new var input_2 to handle for file name var file concat ".tmp", read
    set new var output_2 to handle for file name var file, write
    for each new var line from var input_2 is rw do
        print into var output_2 data var line
        print into var output_2 data new line
    done
    do close with var input_2
    do close with var output_2
    
    do unlink with var file concat ".tmp"
    
    do return without arguments
done

define action clear_empty_lines with var file, var current_language, var path do
    set new var _input to handle for file name var file, read
    for each new var line from var _input is rw do
        if length(var line) < 3 do
            do close with var _input
            
            set new var input_1 to handle for file name var file, read
            set new var output_1 to handle for file name var file concat ".tmp", write
            for each new var line from var input_1 is rw do
                if length(var line) >= 3 do
                    print into var output_1 data var line
                    print into var output_1 data new line
                done
            done
            do close with var input_1
            do close with var output_1
            
            set new var input_2 to handle for file name var file concat ".tmp", read
            set new var output_2 to handle for file name var file, write
            for each new var line from var input_2 is rw do
                print into var output_2 data var line
                print into var output_2 data new line
            done
            do close with var input_2
            do close with var output_2
            
            do unlink with var file concat ".tmp"
            
            do return without arguments
        done
    done
done

define action init_pro_files with var current_language, var path do
    if exists: "SLOW", end test do
        print "Don't read the .pro files in SLOW mode."
        print new line
        do return with 1
    done

    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set var save_path to var save_path concat var current_language concat '/'
    do mkdir with var save_path
    set new array sub_directories to [ '', '/thesaurus' ]
    push into array sub_directories, '/namen'   
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .pro files by sending a signal to the C thread
        # CODE
        for each new var file_name in array files is rw do
            #print var file_name concat "..."
            #print new line
            
            do be_slow without arguments
            set new var file to var language_directory concat '/' concat var file_name

            if not var file matches /\.pro$/ do
                go to next
            done

            do unlink with '_output__add_pro_file'
            do unlink with '_input__add_pro_file'
            
            do clear_empty_lines with var file, var current_language, var path

            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done
            
            if not var i is var j do
            
                do correct_human_edit_typos with var file, var current_language, var path

                print "Read file "
                print var file
                print new line

                # TEXT
                # Write the signal file
                # CODE
                do unlink with '_input__add_pro_file'
                set new var output_handle to handle for file name "_output__add_pro_file", write
                print into var output_handle data var file
                do close with var output_handle
                do trigger_check_files without arguments

                #do wait 1 seconds

                # TEXT
                # Wait...
                # CODE
                while not exists: '_input__add_pro_file', end test do
                    do wait 0.5 seconds
                done

                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

            done
            else do
                print "No changes have been made in file "
                print var file
                print "."
                print new line

            done
        done
    done
    print "Done..."
    print new line
done

define action link_facts with var type, var f1, var f2 do
    print "Linking " concat var f1 concat " and " concat var f2 concat " as " concat var type
    print new line
    set new var output_handle to handle for file name "_output__link", write
        print into var output_handle data var type
        print into var output_handle data new line
        print into var output_handle data var f1
        print into var output_handle data new line
        print into var output_handle data var f2
        print into var output_handle data new line
    do close with var output_handle

    do trigger_check_files without arguments
done

define action init with var current_language, var path do
    do init_part_of_speech_pro_file with var current_language, var path

    do init_csv_files with var current_language, var path
    do init_prot_files with var current_language, var path
    do init_pro_files with var current_language, var path
done

