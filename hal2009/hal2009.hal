use Socket;

#
# This file is part of FreeHAL 2010.
#
# Copyright(c) 2006, 2007, 2008, 2009, 2010 Tobias Schulz and contributors.
# http://freehal.org
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

# TEXT
# This is the main FreeHAL 2010 source file.
# CODE

set global hash sym_noun
set global hash sym_prep
set global hash sym_questionword
set global hash sym_verb
set global hash sym_inter
set global hash sym_adj
set global hash sym_pp
set global hash sym_unimportant
set global hash sym_linking
set global hash sym_art
set global hash sym_entity
set global hash sym_keyword
set global hash val_omit
set global const TYPE
set global const GENUS
set global var ident
set global array cache_memory
set global array standard_suffixes
set global var be_slow__last_time


compile source hal2009-defs.hal
require source hal2009-defs.hal
compile source hal2009-lang-indep.hal
require source hal2009-lang-indep.hal

compile source hal2009-parser-common.hal
require source hal2009-parser-common.hal
compile source hal2009-parser-bottomup.hal
require source hal2009-parser-bottomup.hal
compile source hal2009-parser-monolithic.hal
require source hal2009-parser-monolithic.hal

compile source hal2009-context.hal
require source hal2009-context.hal
compile source hal2009-context-reasonof.hal
require source hal2009-context-reasonof.hal
compile source hal2009-database-management.hal
require source hal2009-database-management.hal
compile source hal2009-phrase.hal
require source hal2009-phrase.hal
compile source hal2009-score.hal
require source hal2009-score.hal
compile source hal2009-tagger.hal
require source hal2009-tagger.hal
compile source hal2009-time-date.hal
require source hal2009-time-date.hal
compile source hal2009-util.hal
require source hal2009-util.hal


define action is_name with var lang, var word do
    set new var is_a_name to 0

    if from global hash builtin_entity_ends item { var word } do
        do return with 0
    done

    set new array male_names to global array builtin_male_names
    for each new var name in array male_names do
        if lc(var name) matches lc(var word) do
            set var is_a_name to "m"
        done
    done

    set new array female_names to global array builtin_female_names
    for each new var name in array female_names do
        if lc(var name) matches lc(var word) do
            set var is_a_name to "f"
        done
    done

    set new array custom_names to global array custom_names
    for each new var name in array custom_names do
        if lc(var name) matches lc(var word) do
            set var is_a_name to "q"
        done
    done

    set new flag is_a_job to is_job with var lang, var word
    if flag is_a_job is true do
        set var is_a_name to "q"
    done

    do return with var is_a_name
done

define action is_collective_noun with var lang, var word do
    set new var is_a_collective_noun to 1

    set new var is_a_name to is_name with var lang, var word
    if var is_a_name do
        set var is_a_collective_noun to 0
    done

    set new array _collective_nouns to global array collective_nouns
    for each new var name in array _collective_nouns do
        if lc(var name) matches lc(var word) do
            set var is_a_collective_noun to "q"
        done
    done

    do return with var is_a_collective_noun
done

define action compute_context with hash parsed do
    set new array questionword_array to from hash parsed element { 'questionword' } 1st element
    set new array verb_array to from hash parsed element { 'verbs' }
    set new array extra_array to from hash parsed element { 'extra' }

    if from array questionword_array 1st element matches "wie" or from array questionword_array 1st element matches "how" do
        do return with "q_how"
    done
    if from array questionword_array 1st element matches /^welch/ do
        do return with "q_what_prep"
    done
    if from array questionword_array 1st element matches /^woher/ do
        do return with "q_from_where"
    done
    if from array questionword_array 1st element matches /^wo/ or from array questionword_array 1st element matches "where" do
        do return with "q_where"
    done
    if from array questionword_array 1st element matches /^wer/ or from array questionword_array 1st element matches "who" do
        do return with "q_who"
    done
    if lc(from array questionword_array 1st element) matches "what-nowiki" do
        do return with "q_what_nowiki"
    done
    if lc(from array questionword_array 1st element) matches "was" or lc(from array questionword_array 1st element) matches "what" do
        if from array verb_array 1st element 1st element matches /^(bist|bi|bin)$/ do
            do return with "q_what_exactly"
        done
        else if from array extra_array 1st element 1st element do
            do return with "q_what_extra"
        done
        else do
            do return with "q_what_weakly"
        done
    done

    if lc(from array verb_array 1st element 1st element) matches "enumall" do
        set from hash parsed element { 'verbs' } to an empty array
        do return with "enum_all"
    done

    for each new var verb in array verb_array do
        if var verb 1st element matches /reasonof/ do
            do return with "reasonof"
        done
    done

    # TEXT
    # Look for something like "Das habe ich nicht gemeint"
    # CODE
    for each new var verb in array verb_array do
        if var verb 1st element matches /mein<[et]>/ do
            do return with "not_meant"
        done
    done


    do return with "default"
done

define action logic with var input, var lang, var path, hash parsed do

    set new var request_context_string to compute_context using hash parsed

    set new array request_verb_array to an empty array
    if from hash parsed element { 'verbs' } do
        push into array request_verb_array, elements of that array: from hash parsed element { 'verbs' } end of elements
    done
    set new array override_verb_array to an empty array

    set new flag verb_flag_want   to 0
    set new flag verb_flag_must   to 0
    set new flag verb_flag_can    to 0
    set new flag verb_flag_may    to 0
    set new flag verb_flag_should to 0

    if array request_verb_array do
        set new var num_of_verbs to elements of array request_verb_array
        if var num_of_verbs >= 1 do
            set new array new_verbs to an empty array
            set new flag do_removed to 0
            for each new array verb_array in array request_verb_array is rw do
                set new var verb to from array verb_array 1st element
                if not flag do_removed do
                    # TEXT
                    # Remove "do" and "does" in englishs entences
                    # CODE
                    if var verb matches /^(does|do)$/ do
                        set flag do_removed to 1
                        go to next
                    done

                    # TEXT
                    # Turn verbs like "must" or "want" into flags
                    # CODE
                    set new var verb_category to verb_category with var verb

                    if var verb_category and var verb not matches /\// do
                        set var verb to var verb concat "/" concat var verb_category
                        set from array verb_array 1st element to var verb
                        push into array override_verb_array, array verb_array
                    done

                    if var verb_category matches 'want' do
                        set flag verb_flag_want to 1
                        go to next
                    done
                    if var verb_category matches 'must' do
                        set flag verb_flag_must to 1
                        go to next
                    done
                    if var verb_category matches 'can' do
                        set flag verb_flag_can to 1
                        go to next
                    done
                    if var verb_category matches 'may' do
                        set flag verb_flag_may to 1
                        go to next
                    done
                    if var verb_category matches 'should' do
                        set flag verb_flag_should to 1
                        go to next
                    done
                done
                push into array new_verbs, array verb_array
                push into array override_verb_array, array verb_array
            done
            set elements of array request_verb_array to elements of array new_verbs

            # if there is only one verb which is a modal verb
            #
            # then do nothing!
            #
            ##if is an empty array override_verb_array do
            ##    set new array verb_array to an empty array
            ##    push into array verb_array, "*"
            ##    push into array override_verb_array, array verb_array
            ##done
            ##if is an empty array request_verb_array do
            ##    set new array verb_array to an empty array
            ##    push into array verb_array, "*"
            ##    push into array request_verb_array, array verb_array
            ##done
        done
        else do
            if from hash parsed element { 'verbs' } do
                set elements of array override_verb_array to elements of that array: from hash parsed element { 'verbs' } end of elements
            done
        done
    done
    set elements of that array: from hash parsed element { 'verbs' } end of elements to elements of array override_verb_array

    set new array request_verb to an empty array
    for each new array verb in array request_verb_array is rw do
        set new var multiple_choices_verb to multiple_choices_verb with from array verb 1st element
        push into array request_verb, var multiple_choices_verb
    done

    set new array request_subjects_array to from hash parsed element { 'subjects' }
    set new array request_subjects to an empty array
    for each new array subjects in array request_subjects_array is rw do
        push into array request_subjects, from array subjects 1st element
    done

    set new array request_objects_array to from hash parsed element { 'objects' }
    set new array request_objects to an empty array
    for each new array objects in array request_objects_array is rw do
        if not from array objects 1st element matches /nothing/ do
            push into array request_objects, from array objects 1st element
        done
    done

    set new array request_adverbs_array to from hash parsed element { 'adverbs' }
    set new array request_adverbs to an empty array
    for each new array adverbs in array request_adverbs_array is rw do
        if not from array adverbs 1st element matches /nothing/ do
            push into array request_adverbs, from array adverbs 1st element
        done
    done

    set new array request_extra_array to from hash parsed element { 'extra' }
    set new array request_extra to an empty array
    for each new array extra in array request_extra_array is rw do
        if not from array extra 1st element matches /nothing/ do
            push into array request_extra, from array extra 1st element
        done
    done

    set elements of array request_verb to sort with elements of array request_verb

    set new var request_verb_string to join using ' ', elements of array request_verb
    set new var request_subjects_string to join using ' ', elements of array request_subjects
    set new var request_objects_string to join using ' ', elements of array request_objects
    set new var request_adverbs_string to join using ' ', elements of array request_adverbs
    set new var request_extra_string to join using ' ', elements of array request_extra

    if var request_context_string matches "enum_all" do
        set var request_extra_string to get_plural with var request_extra_string
    done

    if var request_verb_string or var request_subjects_string or var request_objects_string or var request_adverbs_string do
        set new var flowchart_log to handle for file name var path concat '/flowchart.log', append
        print into var flowchart_log data "begin box"
        print into var flowchart_log data new line
        print into var flowchart_log data "bckgrndcolr D0FFCF"
        print into var flowchart_log data new line
        print into var flowchart_log data "bordercolor D0FFCF"
        print into var flowchart_log data new line
        print into var flowchart_log data "linesoftext 7"
        print into var flowchart_log data new line
        print into var flowchart_log data "draw"
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Verbs:\t" concat var request_verb_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Subjects:\t" concat var request_subjects_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Objects:\t" concat var request_objects_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Adverbs:\t" concat var request_adverbs_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Other:\t" concat var request_extra_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Context:\t" concat var request_context_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Modal verbs:\twant: " concat flag verb_flag_want concat "\tmust: " concat flag verb_flag_must concat "\tcan: " concat flag verb_flag_can concat "\tmay: " concat flag verb_flag_may concat "\tshould: " concat flag verb_flag_should
        print into var flowchart_log data new line
        print into var flowchart_log data "end box"
        print into var flowchart_log data new line
        do close with var flowchart_log
    done

    set array request_subjects to stem_nouns with [ var request_subjects_string ]
    set array request_objects to stem_nouns with [ var request_objects_string ]
    set array request_extra to stem_nouns with [ var request_extra_string ]
    set var request_subjects_string to from array request_subjects 1st element
    set var request_objects_string to from array request_objects 1st element
    set var request_extra_string to from array request_extra 1st element

    set new var request_primary_key to from hash parsed element { 'primary_key' }
    if not var request_primary_key do
        set var request_primary_key to "0"
    done

    set new var output_file_name to '_output__get_csv'
    set new var output to ''
    set var output to var output concat ( lc(var request_verb_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_subjects_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_objects_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_adverbs_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_extra_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_context_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_primary_key) || '0' )

    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_want   || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_must   || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_can    || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_may    || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_should || '0' )


    do unlink with '_input__get_csv'
    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data var output
    do close with var output_handle
    do trigger_check_files without arguments

    do wait 0.3 seconds

    while not exists: '_input__get_csv', end test do
        do wait 0.5 seconds
    done
    print "File exists now: _input__get_csv"
    print new line

    set new array results_true to an empty array
    set new array results_other_modal_verb_true to an empty array
    set new array results_false to an empty array
    set new array results_other_modal_verb_false to an empty array
    set new array results_maybe to an empty array
    set new array results_other_modal_verb_maybe to an empty array

    set new var input_file_name to '_input__get_csv'
    set new var input_handle to handle for file name var input_file_name, read

    for each new var line from var input_handle is rw do
        print var line
        print new line
        if var line matches /^<[\^]>/ do
            go to next
        done
        if length(var line) < 3 do
            go to next
        done

        if "/err:TOOMUCH" matches var line do
            do return using "TOOMUCH"
        done

        set new array result to an empty array
        set new array rawresult to split using /\^/, var line

        # TEXT
        # Shift Primary key
        # CODE
        set new var primary_key to shift with elements of array rawresult


        # TEXT
        # Divide main clause and sub clauses
        # CODE
        push into array result, an empty array
        set new var number_of_clause to 0
        set new var i to 0
        while var i < 7 do
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ var i ]
            set var i to var i + 1
        done

        # TEXT
        # Truth goes from 1.0 to 0.0.
        # CODE

        set new var truth to from array rawresult element [ var i ]
        do adjust_truth with array result, from array rawresult element [ var i ], var number_of_clause, 0
        set var i to var i + 1

        # TEXT
        # Now add the subclauses to the array.
        # CODE

        set new var offs to var i
        push into array result, an empty array
        set var number_of_clause to var number_of_clause + 1
        set var i to 0
        while var i < 10 do
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 0 ]
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 1 ]
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 2 ]
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 3 ]
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 4 ]
            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 5 ]
#            push into that array: from array result element [ var number_of_clause ], from array rawresult element [ (var i * 6) + var offs + 6 ]
            do adjust_truth with array result, from array rawresult element [ var offs - 1 + 6 ], var number_of_clause, var i
            set var i to var i + 1
            push into array result, an empty array
            set var number_of_clause to var number_of_clause + 1
        done

        # TEXT
        # Unshift Primary key
        # CODE
        do unshift with elements of array result, var primary_key



        # TEXT
        # Be sure that the modal verbs are matched
        # CODE
        set new var modal_verb_template to var verb_flag_want concat var verb_flag_must concat var verb_flag_can concat var verb_flag_may concat var verb_flag_should
        if (not from array rawresult element [ 0 ] matches /var modal_verb_template/) and from array rawresult element [ 0 ] matches /([01])([01])([01])([01])([01])/ do
            print "Not matching to: " concat var modal_verb_template
            print new line

            if var truth > 0.75 do
                push into array results_other_modal_verb_true, array result
            done
            else if var truth < 0.25 do
                push into array results_other_modal_verb_false, array result
            done
            else do
                push into array results_other_modal_verb_maybe, array result
            done
        done
        else do
            if var truth > 0.75 do
                push into array results_true, array result
            done
            else if var truth < 0.25 do
                push into array results_false, array result
            done
            else do
                push into array results_maybe, array result
            done
        done
    done

    if is an empty array results_true and is an empty array results_maybe and not is an empty array results_false do
        set array results_other_modal_verb_maybe to an empty array
    done

    if is an empty array results_true do
        set array results_true to array results_other_modal_verb_true
    done
    if is an empty array results_false do
        set array results_false to array results_other_modal_verb_false
    done
    if is an empty array results_maybe do
        set array results_maybe to array results_other_modal_verb_maybe
    done

    print "Found " concat elements of array results_true concat " true sentences" concat new line
    print "Found " concat elements of array results_false concat " false sentences" concat new line
    print "Found " concat elements of array results_maybe concat " maybe sentences" concat new line

    set new hash in_true to an empty hash
    set new hash in_false to an empty hash
    for each new array result in array results_true do
        set new var expr to from array result 2nd element element [ 0 ] concat ' ' concat from array result 2nd element element [ 1 ]
        if not from hash in_true element { var expr } do
            set from hash in_true element { var expr } to an empty array
        done
        push into that array: from hash in_true element { var expr }, array result

        print "A true expression:  " concat var expr concat new line
    done
    for each new array result in array results_false do
        set new var expr to from array result 2nd element element [ 0 ] concat ' ' concat from array result 2nd element element [ 1 ]
        if not from hash in_false element { var expr } do
            set from hash in_false element { var expr } to an empty array
        done
        push into that array: from hash in_false element { var expr }, array result

        print "A false expression: " concat var expr concat new line
    done

    set new array results to an empty array

    for each new array result in array results_maybe do
        set new var expr to from array result 2nd element element [ 0 ] concat ' ' concat from array result 2nd element element [ 1 ]

        print "A maybe expression: " concat var expr concat new line

        if from hash in_true element { var expr } do
            push into array results, elements of that array: from hash in_true element { var expr } end of elements
            set from hash in_true element { var expr } to an empty array
        done
        else if from hash in_false element { var expr } do
            push into array results, elements of that array: from hash in_false element { var expr } end of elements
            set from hash in_false element { var expr } to an empty array
        done
        else do
            push into array results, array result
        done
    done

    set new array true_arrays to an empty array
    set elements of array true_arrays to values of hash in_true
    for each new array result_array in array true_arrays do
        push into array results, elements of array result_array
    done
    set new array false_arrays to an empty array
    set elements of array false_arrays to values of hash in_false
    for each new array result_array in array false_arrays do
        push into array results, elements of array result_array
    done


    print "After t/m/f correction: found " concat elements of array results concat " sentences"
    print new line

    # TEXT
    # Exception: If we are in the "enum_all" context, all subjects together are the object
    # CODE
    if var request_context_string matches "enum_all" and elements of array results do
        set new hash subjects to an empty hash

        for each new array result in array results do
            print from array result 2nd element 1st element concat new line
            print from array result 2nd element 2nd element concat new line
            print from array result 2nd element element [ 2 ] concat new line
            print from array result 2nd element element [ 3 ] concat new line
            print from array result 2nd element element [ 4 ] concat new line
            print from array result 2nd element element [ 5 ] concat new line
            print from array result 2nd element element [ 6 ] concat new line
            print from array result 2nd element element [ 7 ] concat new line
            print "---"
            print new line
            print new line

            set new var single_subject to from array result 2nd element 2nd element
            do regex with var single_subject: /\((a|the)\)\s*?/ -> "" :global

            set from hash subjects element { var single_subject } to 1
        done

        set new array overall_result to an empty array
        do unshift with elements of array overall_result, 0
        push into array overall_result, an empty array
        set from array overall_result 2nd element 2nd element to join ', ', keys of hash subjects

        set array results to an empty array
        push into array results, array overall_result
    done

    do unlink with '_input__get_csv'

    do return using array results
done

define action to_array_from_pro_line with var line, var lang do
    set new array results to an empty array
    set new array result to an empty array
    push into array result, an empty array

    do regex with var line: / <[<]><[>]> / -> "<>" :global
    do regex with var line: / <[;]><[;]> / -> ";;<>" :global
    set new array parts to split with /[<][>]/, var line
    do pop with elements of array parts

    set new array clause to an empty array
    push into array clause, filter_nothing(from array parts 1st element)
    push into array clause, filter_nothing(from array parts 2nd element)
    push into array clause, filter_nothing(from array parts element [ 2 ])
    push into array clause, filter_nothing(from array parts element [ 3 ])
    push into array result, array clause

    print "1.: " concat from array clause 1st element concat new line
    print "2.: " concat from array clause 2nd element concat new line
    print "3.: " concat from array clause 3rd element concat new line
    print "4.: " concat from array clause 4th element concat new line
    print "5.: " concat from array clause 5th element concat new line
    print "6.: " concat from array clause 6th element concat new line
    print "----" concat new line

    set new var i to 4
    while var i < 100 do
        set new array clause to an empty array
        push into array clause, filter_nothing(from array parts element [ var i + 0 ])
        push into array clause, filter_nothing(from array parts element [ var i + 1 ])
        push into array clause, filter_nothing(from array parts element [ var i + 2 ])
        push into array clause, filter_nothing(from array parts element [ var i + 3 ])
        push into array clause, filter_nothing(from array parts element [ var i + 4 ])

        set var i to var i + 1
        while var i < 100 and from array parts element [ var i ] not matches /<[;]><[;]>/ do
            set var i to var i + 1
        done

    print "1.: " concat from array clause 1st element concat new line
    print "2.: " concat from array clause 2nd element concat new line
    print "3.: " concat from array clause 3rd element concat new line
    print "4.: " concat from array clause 4th element concat new line
    print "5.: " concat from array clause 5th element concat new line
    print "6.: " concat from array clause 6th element concat new line
    print "----" concat new line

        if from array clause 1st element matches 50 do
            go to next
        done
        if from array clause 1st element matches 100 do
            go to next
        done
        push into array result, array clause
    done

    push into array results, array result

    do return with array results
done

define action to_array_from_hash_parsed with var line, var lang do
    set new array results to an empty array
    set new array result to an empty array
    push into array result, an empty array

    do regex with var line: / [<][>] / -> "<>" :global
    set new array parts to split with /[<][>]/, var line
    do pop with elements of array parts

    set new array clause to an empty array
    push into array clause, filter_nothing(from array parts 1st element)
    push into array clause, filter_nothing(from array parts 2nd element)
    push into array clause, filter_nothing(from array parts element [ 2 ])
    push into array clause, filter_nothing(from array parts element [ 3 ])
    push into array result, array clause

    set new var i to 4
    while var i < 100 do
        set new array clause to an empty array
        push into array clause, filter_nothing(from array parts element [ var i + 0 ])
        push into array clause, filter_nothing(from array parts element [ var i + 1 ])
        push into array clause, filter_nothing(from array parts element [ var i + 2 ])
        push into array clause, filter_nothing(from array parts element [ var i + 3 ])
        push into array clause, filter_nothing(from array parts element [ var i + 4 ])

        set var i to var i + 5

        if from array clause 1st element matches 50 do
            go to next
        done
        if from array clause 1st element matches 100 do
            go to next
        done
        push into array result, array clause
    done

    push into array results, array result

    do return with array results
done

define action save_input with var input, var current_language, var path do
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/input.history', append
    print into var output_handle data var input concat new line
    do close with var output_handle
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/dialog.history', append
    print into var output_handle data "input: " concat var input concat new line
    do close with var output_handle
done

define action save_output with var input, var current_language, var path do
    do regex with var input: /\(.*/ -> "" :global
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', append
    set new array outputs to split with /([<]br[>].*?\s)/, var input
    for each new var output in array outputs do
        if not var output matches /[<]br[>]/ do
            print into var output_handle data var output concat new line
        done
    done
    do close with var output_handle
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/dialog.history', append
    print into var output_handle data "output: " concat var input concat new line
    do close with var output_handle
done

define action give_output with var input is rw, var only_learn, array facts_to_save, hash tags, var current_language, var path do
    # TEXT
    # --- SCORE
    # We try to use the answer as a judgement
    # CODE
    set new array score to check_score using var input
    if from array score 2nd element do
        if from array score 1st element do
            do set_score_for_num with from array score 2nd element, from array score 1st element, var current_language, var path
        done
        else do
            do set_score_for_last with from array score 2nd element, var current_language, var path
        done

        set new var answer to get_score_answer without arguments
        do return with [ var answer ]
    done

    set array score to check_score_command using var input, var current_language, var path
    if array score and from array score 1st element do
        do set_score with from array score 2nd element, from array score 3rd element, from array score 1st element, var current_language, var path

        set new var answer to get_score_answer without arguments
        do return with [ var answer ]
    done

    # TEXT
    # --- COMPUTE INPUT
    # CODE
    set (var input, new var no_change_pronouns) to compute_input with var input, var current_language, var path
    if not var input do
        do return with an empty array
    done

    print "Got input:          "
    print var input
    print new line
    set var input to modify_input with var input, var current_language, var path
    do save_input with var input, var current_language, var path
    print "Transformed (?) to: "
    print var input
    print new line

    # TEXT
    # --- GET OUTPUT
    # CODE
    print "Input is computed... Going on."
    print new line
    set new var mode to find_mode_of_input using var input, var only_learn, var current_language, var path
    set new array sentences to use_mode with var input, array facts_to_save, hash tags, var mode, var current_language, var path
    print "Output is..."
    print new line
    for each new array sentence in array sentences do
        if from array sentence 2nd element do
            print "    - "
            print from array sentence 2nd element
            print new line
        done
    done

    # TEXT
    # --- Flow chart
    # CODE
    do flowchart_out_answers with array sentences, var current_language, var path


    # TEXT
    # --- NO SUCCESS
    # CODE
    if is an empty array sentences do
        print "Well, no logic answer available."
        print new line
        set new array random to use_random with var input, var current_language, var path, var mode
        push into array sentences, elements of array random
    done

    do return using array sentences
done

define action flowchart_out_answers with array sentences, var current_language, var path do

    set new var num to elements of array sentences
    set var num to var num + 1
    set new var flowchart_log to handle for file name var path concat '/flowchart.log', append
    print into var flowchart_log data "begin box"
    print into var flowchart_log data new line
    print into var flowchart_log data "bckgrndcolr FFD0BB"
    print into var flowchart_log data new line
    print into var flowchart_log data "bordercolor FFD0BB"
    print into var flowchart_log data new line
    print into var flowchart_log data "linesoftext " concat var num
    print into var flowchart_log data new line
    print into var flowchart_log data "draw"
    print into var flowchart_log data new line
    print into var flowchart_log data "textcontent 000000 Answers:"
    print into var flowchart_log data new line
    set new hash primary_keys to an empty hash
    for each new array sentence in array sentences do
        if from array sentence 2nd element do
            if ( not from array sentence 1st element ) or ( not from hash primary_keys element { from array sentence 1st element } ) do

                print into var flowchart_log data "linkcontent 000000 \t - " concat from array sentence 1st element concat ": " concat from array sentence 2nd element
                print into var flowchart_log data new line
                print into var flowchart_log data "property    pk     " concat from array sentence 1st element
                print into var flowchart_log data new line

                set from hash primary_keys element { from array sentence 1st element } to 1

            done
        done
        else do
            print into var flowchart_log data "textcontent 000000 \t - (invalid)"
            print into var flowchart_log data new line
        done
    done
    print into var flowchart_log data "end box"
    print into var flowchart_log data new line
    do close with var flowchart_log
done

define action decide with array output, var input, flag all_output_phrases, var lang, var path do
    set new hash parsed to fake_hash_parsed without arguments
    set new var mode to "statement"

    if flag all_output_phrases do
        set new var output_str to ''
        set new var i to elements of array output
        for each new array _element in array output do
            # no subclauses here
            # set new var element_str to post_phrase with var lang, var path, var mode, hash parsed, array _element

            set new var element_str to from array _element 2nd element
            set var output_str to var output_str concat var i concat ".) " concat var element_str concat ' <br> '
            set var i to var i - 1
        done
        return var output_str
    done
    else do

        if 2 <= size of array output do
            set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/output.history', read
            set new var last_output to ''
            for each new var line from var input_handle do
                set var last_output to var line
            done

            print "previous output: " concat var last_output concat new line

            for each new var _output in array output do
                set new var output to from array _output 2nd element

                do regex with var output: /\(.*/ -> "" :global
                do regex with var output: /\((<[+]>+?)\)\s/ -> "" :global
                do regex with var output: /\((<[-]>+?)\)\s/ -> "" :global
                do regex with var output: /\((<[+]>+?)\)/ -> "" :global
                do regex with var output: /\((<[-]>+?)\)/ -> "" :global

                print "maybe current output: " concat var output concat new line

                if lc(var last_output) matches lc(var output) do
                    set from array _output 2nd element to ''
                    go to last
                done
            done

            set new array replacement_for_output to an empty array
            for each new var _output in array output do
                if from array _output 2nd element do
                    push into array replacement_for_output, var _output
                done
            done
            set array output to array replacement_for_output
        done

        set new array words to split with " ", lc(var input)
        set new array rel_output to an empty array
        for each new array _element in array output do
            print "Score of " concat from array _element 2nd element concat " is "
            set new var score to get_score with array words, from array _element 2nd element, var lang, var path
            print var score
            print new line
            set new var k to 0
            while var k < var score + 1 do
                push into array rel_output, array _element
                set var k to var k + 1
            done
        done

        # TEXT
        # If all scores are negative...
        # CODE
        if is an empty array rel_output do
            set array rel_output to array output
        done

        # TEXT
        # Choose an answer
        # CODE
        set new var random_number to rand using elements of array rel_output
        set new array final_output to from array rel_output element [ var random_number ]
        set new var final_output_str to post_phrase with var lang, var path, var mode, hash parsed, array final_output
        do return var final_output_str
    done
done

define action shell with var current_language, var path do
    set new var input_file_name to '_input'
    set new var input_handle to handle for file name var input_file_name, read

    set new var time_first to time without arguments
    set new var do_learn to 1
    set new var do_talk  to 1

    for each new var sentences_as_line_2 from var input_handle is rw do
        if var sentences_as_line_2 matches /^do_learn_do_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 1
            set var do_talk  to 1
        done
        if var sentences_as_line_2 matches /^do_learn_no_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 1
            set var do_talk  to 0
        done
        if var sentences_as_line_2 matches /^no_learn_do_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 0
            set var do_talk  to 1
        done
        if var sentences_as_line_2 matches /^no_learn_no_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 0
            set var do_talk  to 0
        done

        print "Do learn: " concat var do_learn concat new line
        print "Do talk:  " concat var do_talk  concat new line

        do regex with var sentences_as_line_2: /[?]+/ -> "?" :global
        do regex with var sentences_as_line_2: /([?])/ -> "$0." :global
        do regex with var sentences_as_line_2: /[.!~]\s*?[.!~]/ -> "~" :global
        do regex with var sentences_as_line_2: /[.!~]\s*?[.!~]/ -> "~" :global
        do regex with var sentences_as_line_2: /<[.]>(\s|$)/ -> " STOP " :global
        do regex with var sentences_as_line_2: /(\d) STOP / -> "$0. " :global
        do regex with var sentences_as_line_2: / STOP \((.*)\)/ -> " ($0) STOP . " :global

        set var sentences_as_line_2 to divide_input with var sentences_as_line_2, var current_language, var path

        set new array sentences_as_line_array to split with /\sSTOP\s/, var sentences_as_line_2
        for each new var sentences_as_line in array sentences_as_line_array do

            set new array facts_to_save to an empty array
            set new hash tags to an empty hash

            set new array sentences to split with /[!~]/, var sentences_as_line

            for each new var line in array sentences do

                do regex with var line: /^\s+/ -> "" :global
                do regex with var line: /\s+$/ -> "" :global
                do regex with var line: /\.$/ -> "" :global
                do regex with var line: /^\./ -> "" :global
                if not var line do
                    go to next
                done

                set new flag all_output_phrases to 0
                if lc(var line) matches /^\/all / do
                    do regex with var line: /^\/all / -> "" :global:i
                    set flag all_output_phrases to 1
                done
                if lc(var line) matches /^\/gen list/ do
                    do regex with var line: /^\/gen list / -> "" :global:i
                    do regex with var line: /^\/gen list/ -> "" :global:i
                    do regex with var line: /.pro/ -> "" :global:i
                    if not var line do
                        set var line to ""
                    done
                    do update_list_of_pro_files with var line, var current_language, var path
                    go to next
                done

#                do unlink with '_output'
                set new array output to give_output with var line, (not var do_talk), array facts_to_save, hash tags, var current_language, var path
#                do unlink with '_output'

                set new var final_output to decide using array output, var line, flag all_output_phrases, var current_language, var path

                set var final_output to upper_case_correction with var final_output, hash tags, var current_language, var path
                do regex with var final_output: /\((<[+]>+?)\)\s/ -> "" :global
                do regex with var final_output: /\((<[-]>+?)\)\s/ -> "" :global
                do regex with var final_output: /\((<[+]>+?)\)/ -> "" :global
                do regex with var final_output: /\((<[-]>+?)\)/ -> "" :global

                set new var time_second to time without arguments
                set var final_output to var final_output concat " (" concat (var time_second - var time_first) concat " sec)"

#                do unlink with '_output'
                do save_output with var final_output, var current_language, var path
                if var do_talk do
                    set new var output_file_name to '_output'
                    set new var output_handle to handle for file name var output_file_name, write
                    print into var output_handle data var final_output
                    do close with var output_handle
                    do trigger_check_files without arguments
                done

                print "Final output is..."
                print new line
                print "      "
                print var final_output
                print new line
            done

            set new var saved_data to ''
            if var do_learn do
                set var saved_data to save_facts with array facts_to_save, hash tags, '',  '', 0, var current_language, var path
                set var saved_data to escape_html using var saved_data
            done
            else do
                set var saved_data to save_facts with array facts_to_save, hash tags, '-', '', 0, var current_language, var path
                set var saved_data to escape_html using var saved_data
            done

            if not var do_talk do
                if var saved_data and length(var saved_data) > 5 do
                    set new var output_file_name to '_output'
                    set new var output_handle to handle for file name var output_file_name, write
                    print into var output_handle data var saved_data
                    do close with var output_handle
                done
            done

            print "Do learn: " concat var do_learn concat new line
            print "Do talk:  " concat var do_talk  concat new line
        done
    done

    do memory_limit with "word_types.memory", var current_language, var path
    do memory_limit with "word_types.self-taggered", var current_language, var path

    do wait 3 seconds

    set new var exit_file_name to '_exit'
    set new var exit_handle to handle for file name var exit_file_name, write
    do close with var exit_handle
    do trigger_check_files without arguments
    do exit with 0
done
