#
# This file is part of FreeHAL 2009.
#
# Copyright(c) 2006, 2007, 2008, 2009 Tobias Schulz and contributors.
# http://freehal.org
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

# TEXT
# ~~~~~~ INTRODUCTION ~~~~~~
# This is the main FreeHAL 2009 source file.
# ~~~~~~ IMPLEMENTATION ~~~~~~
# ~~~~~ HEADER ~~~~~
# Include some files:
# CODE
compile source hal2009-lang-indep.hal
require source hal2009-lang-indep.hal

# TEXT
# A part of speech is represented as a string.
# sym_* is always a hash containing these representations as keys.
# CODE
set new hash sym_noun to { "2" => 1, "n" => 1, "n," => 1, "f,m" => 1, "f,n" => 1, "f,n,m" => 1, "f,m,n" => 1, "m,f" => 1, "m,n" => 1, "m,f,n" => 1, "m,n,f" => 1, "m" => 1, "f" => 1, "n,pl" => 1, "ppron" => 1, }
set new hash sym_prep to { "6" => 1, "prep" => 1, }
set new hash sym_questionword to { "5" => 1, "fw" => 1, "questionword" => 1, }
set new hash sym_verb to { "1" => 1, "verb" => 1, "vt" => 1, "vi" => 1 }
set new hash sym_inter to { "7" => 1, "inter", }
set new hash sym_adj to { "3" => 1, "adj" => 1, "adv" => 1, }
set new hash sym_pp to { "pron" => 1, }
set new hash sym_unimportant to { "nothing" => 1, }
set new hash sym_linking to { "linking" => 1, }
set new hash sym_art to { "art" => 1, }
set new hash sym_entity to { items of hash sym_adj, items of hash sym_art, items of hash sym_noun }
set new hash sym_keyword to { "ISUNKNOWN" => 1, "ENUMALL" => 1, }

set new hash val_omit to { "a" => 1, "b" => 1, "c" => 1, "d" => 1, "e" => 1, "f" => 1, "g" => 1, "h" => 1, }

# TEXT
# The constant variables TYPE and GENUS are defined as 0 and 1. They are used as array indices.
# CODE
set new const TYPE to 0
set new const GENUS to 1

# TEXT
# If a message is printed, "ident" contains the amount of spaces at the left
# CODE
set new var ident to ""

# TEXT
# Cache, only used when high memory support used
# CODE
set new global array cache_memory to [ ]

# TEXT
# An example: If the german word Baecker is not found, maybe Baeckerin is there
# CODE
set new array standard_suffixes to [ "", "in", "e", "s", "es", "er", "en", "em" ]
set new global var be_slow__last_time to time without arguments

define action be_slow without arguments do
    if exists: "SLOW", end test do
        set new var be_slow__new_time to time without arguments
        set new var diff to var be_slow__new_time - var be_slow__last_time - 1
        if var diff > 3 do
            set var diff to 3
        done
        if var diff > 1 do
            print STDERR "Micro-managing freehal process: "
            print STDERR var diff
            print STDERR " cpu seconds were used."
            print STDERR new line
            do wait 20 * var diff seconds
            set var be_slow__last_time to time without arguments
        done
    done
done

# TEXT
# ~~~~~ SCORE CODE ~~~~~
# CODE

define action check_score with var possible_score do
    set new var output_num to 0
    if var possible_score matches /^(<[0-9]>+)\s?/ do
        set var output_num to $0
        print "( Output number: " concat var output_num concat " ) "
        do regex using var possible_score: /^<[0-9]>+\s?/, "", :global
    done

    if not var possible_score matches /[a-zA-Z]/ do
        if var possible_score matches /[+]/ do
            return [ var output_num, 5 ]
        done
        if var possible_score matches /[+][+]/ do
            return [ var output_num, 20 ]
        done
        if var possible_score matches /[+][+][+]/ do
            return [ var output_num, 50 ]
        done
        if var possible_score matches /[+][+][+][+]/ do
            return [ var output_num, 800 ]
        done
        if var possible_score matches '-' do
            return [ var output_num, -5 ]
        done
        if var possible_score matches '--' do
            return [ var output_num, -20 ]
        done
        if var possible_score matches '---' do
            return [ var output_num, -50 ]
        done
        if var possible_score matches '----' do
            return [ var output_num, -800 ]
        done
    done

    do return with [ var output_num, undef ]
done

define action set_score with array words, var sentence, var score, var lang, var path do
    set new var output_file_name to var path concat '/lang_' concat var lang concat '/index_of_combination.cfg'
    set new var output_handle to handle for file name var output_file_name, append

    for each new var word in array words do
        print into var output_handle data '[' concat var word concat ']'
        print into var output_handle data new line
        print into var output_handle data var sentence
        print into var output_handle data ": "
        print into var output_handle data var score
        print into var output_handle data new line
    done

    do close with var output_handle
done

define action set_score_for_last with var score, var lang, var path do
    set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/output.history', read
    set new var last_output to ''
    for each new var line from var input_handle do
        set var last_output to var line
    done
    
    set var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/input.history', read
    set new var last_input to ''
    for each new var line from var input_handle do
        set var last_input to var line
    done

    set new array words to split with " ", var last_input
    
    if var last_output do
        do set_score with array words, var last_output, var score, var lang, var path
    done
done

define action set_score_for_num with var score, var num, var lang, var path do
    print "Search output no "
    print var num
    print new line

    set new var score_answer to get_score_answer without arguments

    set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/output.history', read
    set new array last_output to an empty array
    for each new var line from var input_handle do
        if var line matches /var score_answer/ do
            go to next
        done

        push into array last_output, var line
        if items of array last_output > var num - 1 do
            do shift with items of array last_output
        done
    done
    
    set var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/input.history', read
    set new var last_input to ''
    for each new var line from var input_handle do
        set var last_input to var line
    done

    set new array words to split with " ", var last_input
    
    if var last_output do
        do set_score with array words, from array last_output first item, var score, var lang, var path
    done
done

define action get_score with array words, var sentence, var lang, var path do
    set new array maybe_is_score to check_score with var sentence
    if array maybe_is_score and from array maybe_is_score item [1] do
        return 0
    done

    set var sentence to lc with var sentence
    do regex using var sentence: /<[?]>|<[!.,\-]>/, "", :global
    set new var sum to 1
    set new var num_words to items of array words
    for each new var word in array words do
        set new var input_file_name to var path concat '/lang_' concat var lang concat '/index_of_combination.cfg'
        set new var input_handle to handle for file name var input_file_name, read
        for each new var line from var input_handle do
        
            set new flag redo to 1
            while flag redo do
                set flag redo to 0
                
                do regex using var word: /<[?]>|<[!.,\-]>/, "", :global
                if not var line matches /[+]/ and var line matches /\[var word\]/ do
                    for each new var line_2 from var input_handle do
                        if var line_2 matches "" do
                            go to last
                        done
                        if var line_2 matches /[\[\]]/ do
                            set var line to var line_2
                            set flag redo to 1
                            go to last
                        done
                        if lc(var line_2) matches /var sentence/ do
                            set new array parts to split with ":", var line_2
                            set new var score_here to from array parts item [ 1 ]
                            do regex using var score_here: /\s/, "", :global

                            # print "score_here:" concat var score_here concat new line
                            if (0+var score_here) > -1 do
                                set var sum to var sum + 20*var score_here*(10/var sum) + 1 
                            done
                            else do
                                #set var num_words to var num_words - 1
                            done
                        done
                    done
                done
            done
        done
        do close with var input_handle
    done

    if var num_words < 1 do
        set var num_words to 1
    done

    set var sum to (var sum + 1) / var num_words 
    
    do return with var sum
done

# TEXT
# ~~~~~ TAGGER CODE ~~~~~
# CODE

define action get_tag_part_of_speech with var word, var lang do
    set new var output_file_name to '_output__pos'
    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data var word
    do close with var output_handle

    while 1 do
        set new var input_file_name to '_input__pos'
        set new var input_handle to handle for file name var input_file_name, read

        if var input_handle do
            set new var response to the next line from var input_handle
            if var response do
                print "Got input."
                print new line
                do close with var input_handle
                do unlink with '_input__pos'
                do return using var response
            done
        done
        do wait 1 seconds
    done
done

# TEXT
# Save the word "name_of_entry" in the memory file.
# The memory file contains the parts of speech.
# CODE
define action memory_set_by_name with var file_name, var name_of_entry, array tags, var lang, var path do

    set new array check_tags to memory_get_by_name using var file_name, var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in ?-file: " concat var name_of_entry
        print new line
        do return without arguments
    done
    set new array check_tags to memory_get_by_name using "word_types.memory", var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in memory file: " concat var name_of_entry
        print new line
        do return without arguments
    done
    set new array check_tags to memory_get_by_name using "word_types.brain", var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in brain file: " concat var name_of_entry
        print new line
        do return without arguments
    done
    set new array check_tags to memory_get_by_name using "protocol.memory", var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in protocol file: " concat var name_of_entry
        print new line
        do return without arguments
    done

    if var name_of_entry matches /br[0-9]+?$/ do
        print "Illegal word: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /__$/ do
        print "Illegal word: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /_/ do
        print "Do not save \"_\" words: " concat var name_of_entry
        print new line
        do return without arguments
    done

    do be_slow without arguments
    print "Setting   " concat var name_of_entry concat "    \tin file " concat var file_name
    print new line
    
    if not from array tags item [ 0 ] do
        set from array tags item [ 0 ] to 'q'
    done
    if not from array tags item [ 1 ] do
        set from array tags item [ 1 ] to 'q'
    done

    if from array tags item [ 0 ] is 1 do
        set from array tags item [ 0 ] to 'vi'
    done
    if from array tags item [ 0 ] is 2 do
        set from array tags item [ 0 ] to 'n'
    done
    if from array tags item [ 0 ] is 3 do
        set from array tags item [ 0 ] to 'adj'
    done
    if from array tags item [ 0 ] is 5 do
        set from array tags item [ 0 ] to 'questionword'
    done
    if from array tags item [ 0 ] is 6 do
        set from array tags item [ 0 ] to 'prep'
    done
    if from array tags item [ 0 ] is 7 do
        set from array tags item [ 0 ] to 'inter'
    done

    set new var output_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, append
    print into var output_handle data var name_of_entry concat ":"
    print into var output_handle data new line
    print into var output_handle data "  type: "
    print into var output_handle data from array tags item [ 0 ]
    print into var output_handle data new line
    if not from array tags item [ 1 ] matches /q/ do
        print into var output_handle data "  genus: "
        print into var output_handle data from array tags item [ 1 ]
        print into var output_handle data new line
    done

    do close with var output_handle

    # TEXT
    # Protocol file:
    # CODE
    set new var output_handle to handle for file name var path concat "/lang_" concat var lang concat "/protocol.memory", append
    print into var output_handle data var name_of_entry concat ":"
    print into var output_handle data new line
    print into var output_handle data "  type: "
    print into var output_handle data from array tags item [ 0 ]
    print into var output_handle data new line
    if not from array tags item [ 1 ] matches /q/ do
        print into var output_handle data "  genus: "
        print into var output_handle data from array tags item [ 1 ]
        print into var output_handle data new line
    done

    do close with var output_handle
done

# TEXT
# Search in the memory file for the word "name_of_entry".
# The memory file contains the parts of speech.
# CODE
define action memory_get_by_name with var file_name, var name_of_entry, var lang, var path do
    if exists: "SLOW", end test do
        print "Running in SLOW mode... "
        print new line
        
        #set new array result to cache_memory_get_by_name with var file_name, var name_of_entry, var lang, var path
        #do return with array result
    done
    
    
    do be_slow without arguments
    print "Searching   " concat var name_of_entry concat "    \tin file " concat var file_name
    print new line
    
    set new var input_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, read
    set new var end_of_entry_line to ':'
    do regex using var name_of_entry: /[\(\)]/, "", :global:i
    set var name_of_entry to var name_of_entry concat "("
    for each new var suffix in array standard_suffixes do
        set var name_of_entry to var name_of_entry concat "|"
        set var name_of_entry to var name_of_entry concat var suffix
    done
    set var name_of_entry to var name_of_entry concat ")"
    set var name_of_entry to var name_of_entry concat var end_of_entry_line
    
    do regex using var name_of_entry: /[\[\]]/, "", :global:i
    
    set new var type to 'q'
    set new var genus to 'q'
    
    do be_slow without arguments
    
    # go through the lines
    for each new var line from var input_handle is rw do
        # no line ending
        do chomp using var line
        
        # line starts with a space?
        if var line matches /^\s/ do
            go to next
        done
        else do
        
            if var line matches /^var name_of_entry/ do
                print "Found do      " concat var name_of_entry concat "    \tin file " concat var file_name concat ":"
                print var name_of_entry
                print new line
                print var line
                print new line
                # we've found the right entry!
                for each new var line from var input_handle is rw do
                    if var line matches /^\s*?(\S*?)<[var end_of_entry_line]>\s*?(\S+)/ do
                        if $0 matches "type" do
                            set var type to $1
                        done
                        else if $0 matches "genus" do
                            set var genus to $1
                        done
                        do be_slow without arguments
                    done
                    else do
                        go to last
                    done
                done
                if (not var type matches "q") or (not var genus matches "q") do
                    print "Found do      " concat var name_of_entry concat "    \tin file " concat var file_name
                    print new line
                    
                    print "type do  " concat var type
                    print new line
                    print "genus do " concat var genus
                    print new line
                    do return with [ var type, var genus ]
                done
            done
        done
    done
    do be_slow without arguments

    print "Not found do  " concat var name_of_entry concat "    \tin file " concat var file_name
    print new line
    do return using an empty array
done

# TEXT
# Search in RAM for the word "name_of_entry".
# This a version of memory_get_by_name which uses much memory, but less CPU
# CODE
define action cache_memory_get_by_name with var file_name, var name_of_entry, var lang, var path do
    if is an empty global array cache_memory do
        print "Scanning file " concat var file_name
        print new line
        
        set new var input_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, read
        for each new var line from var input_handle is rw do
            push into global array cache_memory, var line
        done
        do close with var input_handle
    done

    do be_slow without arguments
    print "Searching   " concat var name_of_entry concat "    \tin memory"
    print new line
    
    set new var end_of_entry_line to ':'
    set var name_of_entry to var name_of_entry concat "("
    for each new var suffix in array standard_suffixes do
        set var name_of_entry to var name_of_entry concat "|"
        set var name_of_entry to var name_of_entry concat var suffix
    done
    set var name_of_entry to var name_of_entry concat ")"
    set var name_of_entry to var name_of_entry concat var end_of_entry_line
    
    set new var type to 'q'
    set new var genus to 'q'
    
    do be_slow without arguments
    
    # go through the lines
    set new var k to 0
    while from global array cache_memory item [ var k ] do
        set new var line to from global array cache_memory item [ var k ]
        # no line ending
        do chomp using var line
                
        # line starts with a space?
        if var line matches /^\s/ do
            go to next
        done
        else do
        
            if var line matches /^var name_of_entry/ do
                print "Found do      " concat var name_of_entry concat "    \tin file " concat var file_name
                print new line

                # we've found the right entry!
                while from global array cache_memory item [ var k ] do
                    set new var line to from global array cache_memory item [ var k ]

                    if var line matches /^\s*?(\S*?)<[var end_of_entry_line]>\s*?(\S+)/ do
                        if $0 matches "type" do
                            set var type to $1
                        done
                        else if $0 matches "genus" do
                            set var genus to $1
                        done
                        do be_slow without arguments
                    done
                    else do
                        print "Found do      " concat var name_of_entry concat "    \tin file " concat var file_name
                        print new line
                        
                        print "type do  " concat var type
                        print new line
                        print "genus do " concat var genus
                        print new line
                        do return with [ var type, var genus ]
                    done
                    set var k to var k + 1
                done
            done
        done
        set var k to var k + 1
    done
    do be_slow without arguments

    print "Not found do  " concat var name_of_entry concat "    \tin file " concat var file_name
    print new line
    do return using an empty array
done

# TEXT
# Find out the part of speech
# CODE
define action compute_tags with var word, var lang, var path do
    set new array tags to an empty array
    
    # TEXT
    # Is it built in into FreeHAL?
    # CODE
    if is an empty array tags do
        set from array tags first item to from global hash builtin_part_of_speech item { var word }
        
        if not from array tags first item do
            set array tags to an empty array
        done
        else do
            print "built in: " concat from array tags first item
            print new line
        done
    done
    if is an empty array tags do
        set from array tags first item to from global hash builtin_part_of_speech item { lc(var word) }
        
        if not from array tags first item do
            set array tags to an empty array
        done
        else do
            print "built in: " concat from array tags first item
            print new line
        done
    done
    
    if is an empty array tags do
        if lc(var word) matches /no-question/ do
            set from array tags first item to "qq"
        done
        if lc(var word) matches /_(wie|wer|was|wo|wann|warum|wieso|weshalb)_/ do
            set from array tags first item to "adj"
        done
        if lc(var word) matches /^in_/ do
            set from array tags first item to "adj"
        done
        if lc(var word) matches /^zu<[rm]>_/ do
            set from array tags first item to "adj"
        done
        if lc(var word) matches /tion(|en)?$/ do
            set from array tags first item to "n"
        done
        if lc(var word) matches /^jahr/ do
            set from array tags first item to "n"
        done
        if var word matches /<[0123456789]>/ do
            set from array tags first item to "adj"
        done
        if var word matches /<[_]>/ do
            set from array tags first item to "n"
        done
        if lc(var word) matches var word and var lang matches "de" do
            if var word matches /ist$/ do
                set from array tags first item to "n"
            done
            if var word matches /st$/ do
                set from array tags first item to "vi"
            done
            if var word matches /iert$/ do
                set from array tags first item to "vi"
            done
            if var word matches /ieren$/ do
                set from array tags first item to "vi"
            done
            if var word matches /iere$/ do
                set from array tags first item to "vi"
            done
            if var word matches /ierst$/ do
                set from array tags first item to "vi"
            done
        done
        else if ucfirst(var word) matches var word and var lang matches "de" do
            if var word matches /est$/ do
                set from array tags first item to "vi"
            done
        done
        else if var word matches /<[ABCDEFGHIJKLMNOPQRSTUVWXYZ]>/ do
            set from array tags first item to "n"
        done
    done
    
    if not is an empty array tags do
        do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
    done
    
    # TEXT
    # Look if the lower case variant of the word is a verb in the memory file.
    # CODE
    if is an empty array tags do
        set array tags to memory_get_by_name using "word_types.memory", lc(var word), var lang, var path
        
        if not from hash sym_verb item { from array tags first item } do
            set array tags to an empty array
        done
    done
    if is an empty array tags do
        set array tags to memory_get_by_name using "word_types.brain", lc(var word), var lang, var path
        
        if not from hash sym_verb item { from array tags first item } do
            set array tags to an empty array
        done
    done

    # TEXT
    # Look if the lower case variant of the word is a preposition in the memory file.
    # CODE
    if is an empty array tags do
        set array tags to memory_get_by_name using "word_types.memory", lc(var word), var lang, var path
        
        if not from hash sym_prep item { from array tags first item } do
            set array tags to an empty array
        done
    done
    if is an empty array tags do
        set array tags to memory_get_by_name using "word_types.brain", lc(var word), var lang, var path
        
        if not from hash sym_prep item { from array tags first item } do
            set array tags to an empty array
        done
    done
    
    # TEXT
    # Look in the memory file.
    # CODE
    if is an empty array tags do
        set array tags to memory_get_by_name using "word_types.memory", var word, var lang, var path
    done
    if is an empty array tags do
        set array tags to memory_get_by_name using "word_types.brain", var word, var lang, var path
    done
    
    # TEXT
    # Ask the user.
    # CODE
    if is an empty array tags do
        if exists: var path concat "/no-tagger.txt", end test do
            set array tags to an empty array
            set from array tags first item to get_tag_part_of_speech using var word, var lang
            do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
        done
    done

    # TEXT
    # Look for similar words.
    # CODE
    if is an empty array tags do
        set new var modified_word to var word
        for each new var suffix in array standard_suffixes do
            do regex using var modified_word: /var suffix$/, "", :global
        done
        
        set array tags to memory_get_by_name using "word_types.memory", var modified_word, var lang, var path
    done
    do be_slow without arguments
    if is an empty array tags do
        set new var modified_word to var word
        for each new var suffix in array standard_suffixes do
            do regex using var modified_word: /var suffix$/, "", :global
        done
        
        set array tags to memory_get_by_name using "word_types.brain", var modified_word, var lang, var path
    done
    do be_slow without arguments
    
    # TEXT
    # Guess.
    # CODE
    if is an empty array tags do
        if not exists: var path concat "/no-tagger.txt", end test do
            set array tags to an empty array
            set from array tags first item to guess_part_of_speech using var word
            
            if not from array tags first item do
                set array tags to an empty array
            done
            else do
                do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
            done
        done
    done
    do be_slow without arguments
    
    # TEXT
    # Ask the user.
    # CODE
    if is an empty array tags do
        set array tags to an empty array
        set from array tags first item to get_tag_part_of_speech using var word, var lang
        do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
    done
    
    do regex using from array tags first item: /,/, "", :global

    # TEXT
    # Return the result.
    # CODE
    do return using array tags
done

# TEXT
# ~~~~~ PARSER CODE ~~~~~
#
# This function returns the next few words from "array words" which are either nouns, acticles, or adjectives.
# CODE

define action parse_using_entity with var lang, array words, hash tags, flag found_subject, var what do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_entity."
    print new line

    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array

    # TEXT
    # Decide whether this entity is a subject or an object
    # CODE
    set new var entity_key_name to "subjects"
    if flag found_subject do
        set var entity_key_name to "objects"
    done

    # TEXT
    # Here the current word and the following word are assigned to variables.
    # CODE
    set new var current_word to from array words item [ 0 ]
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words item [ 1 ]
    set new array next_tag to from hash tags item { var next_word }

    print var ident
    print "#    "
    print 'var entity_key_name: ' concat var entity_key_name concat ' ( ' concat var current_word concat ' -> ' concat var next_word concat ' )'
    print new line


    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So add it to "hash full_entity"
    # <br /><br />
    # If there isn't the same part of speech twice, add the current word to 
    # "hash full_entity" and leave the following word as it is
    # CODE
    if not from hash sym_noun item { from array current_tag first item } and from hash sym_noun item { from array next_tag first item } do
        set from hash full_entity item { var entity_key_name } to [ [ var current_word ] ]
        shift from array words
    done
    # TEXT
    # <br /><br />
    # If there's the same part of speech twice or more times, 
    # and the first one is not declared as an entity end,
    # add them all to the hash
    # CODE
    
    while (from hash sym_noun item { from array current_tag first item } or from hash sym_linking item { from array current_tag first item }) and (from hash sym_noun item { from array next_tag first item } or from hash sym_linking item { from array next_tag first item } or not from array next_tag first item ) do

        print "now:  " concat from array current_tag first item concat " - " concat var current_word
        print new line
        print "next: " concat from array next_tag first item concat " - " concat var next_word
        print new line
        
        if (not items of that array: from hash full_entity item { var entity_key_name } end-items-of) or (not from hash full_entity item { var entity_key_name } item [ items of that array: from hash full_entity item { var entity_key_name } end-items-of - 1 ] first item matches var current_word) do
            do push using items of that array: ( from hash full_entity item { var entity_key_name } ) end-items-of, [ var current_word ]
        done
        shift from array words
        
        if from global hash builtin_entity_ends item { lc(var current_word) } do
            set flag found_subject to 1
            set var entity_key_name to "subjects"
            if flag found_subject do
                set var entity_key_name to "objects"
            done
        done
        
        set new array pairs to global array builtin_entity_ends_pair
        for each new array pair in array pairs do
            
            if lc(var current_word) matches from array pair item [ 0 ] and lc(var next_word) matches from array pair item [ 1 ] do
                set flag found_subject to 1
                set var entity_key_name to "subjects"
                if flag found_subject do
                    set var entity_key_name to "objects"
                done
            done
        done
        
        set var current_word to var next_word
        set array current_tag to array next_tag
        set var next_word to from array words item [ 0 ]
        set array next_tag to from hash tags item { var next_word }
    done

    print "end of loop"
    print new line
    print "now:  " concat from array current_tag first item concat " - " concat var current_word
    print new line
    print "next: " concat from array next_tag first item concat " - " concat var next_word
    print new line

    if from global hash builtin_entity_ends item { lc(var current_word) } do
        set flag found_subject to 1
        set var entity_key_name to "subjects"
        if flag found_subject do
            set var entity_key_name to "objects"
        done
    done

    set new array pairs to global array builtin_entity_ends_pair
    for each new array pair in array pairs do
        
        if lc(var current_word) matches from array pair item [ 0 ] and lc(var next_word) matches from array pair item [ 1 ] do
            set flag found_subject to 1
            set var entity_key_name to "subjects"
            if flag found_subject do
                set var entity_key_name to "objects"
            done
        done
    done
    
    # TEXT
    # The subject ends when there is a noun which is followed by an adjective or an adverb or a verb or nothing.
    # CODE
    if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
        if from hash sym_adj item { from array next_tag item [ const TYPE ] } || from hash sym_art item { from array next_tag item [ const TYPE ] } || from hash sym_verb item { from array next_tag item [ const TYPE ] } || from hash sym_prep item { from array next_tag item [ const TYPE ] } do
            set flag found_subject to 1
        done
    done
    
    # TEXT
    # The subject ends when the current word is an article and the next one is a verb
    # CODE
    if from hash sym_art item { from array current_tag item [ const TYPE ] } do
        if from hash sym_verb item { from array next_tag item [ const TYPE ] } do
            set flag found_subject to 1
        done
    done
    
    # TEXT
    # The subject ends when the current word is an adjective/adverb and the next one is a verb
    # CODE
    if from hash sym_adj item { from array current_tag item [ const TYPE ] } do
        if from hash sym_verb item { from array next_tag item [ const TYPE ] } do
            set flag found_subject to 1
        done
    done
    
    if not var what matches "nothing" do

        # TEXT
        # In "hash parsed" there will be the next word, if it's also either a noun, an adjective or an article.
        # Otherwise it will be empty
        # CODE
        set new hash parsed to parse_what with var lang, array words, hash tags, var what, flag found_subject
        if defined hash parsed && is an empty hash parsed do
            # TEXT
            # It's empty. The "1", which is returned as the second array element,
            # means that there's another following part of speech, probably a verb
            # CODE

            print var ident
            print "#    "
            print "End do parse_using_entity."
            print new line
            set var ident to var ident concat "\b\b"
            do return using [ hash full_entity, 1 ]
        done
        else if defined hash parsed do
            # TEXT
            # It's not empty. The "0" means that we are at the end of the sentence.
            # In "hash parsed", there is the last word, either a noun, an adjective or an article.
            # CODE
            
            set new array keys to [ keys of hash parsed ]
            for each new var key in array keys do
                set new array new_value to from hash full_entity item { var key }
                push into array new_value, items of that array: from hash parsed item { var key } end items of
                set from hash full_entity item { var key } to array new_value
            done
        done
    done
        
    print var ident
    print "#    "
    print "End do parse_using_entity."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_using_verb with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_verb."
    print new line
    
    set new array full_entity to an empty array
    
    set new var current_word to from array words item [ 0 ]
    push into array full_entity, [ var current_word ]
    shift from array words
    
    print var ident
    print "#    "
    print "End do parse_using_verb."
    print new line
    set var ident to var ident concat "\b\b"
    do return using array full_entity
done

define action parse_using_preposition with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_preposition."
    print new line
    
    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array

    # TEXT
    # Participle constructions, prepositions and adverbs are the same in FreeHAL english and FreeHAL german.
    # CODE
    set new var entity_key_name to "adverbs"

    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So push it into "hash full_entity"
    # CODE
    set new var current_word to from array words item [ 0 ]
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words item [ 1 ]
    set new array next_tag to from hash tags item { var next_word }

    set new var entity to var current_word
    shift from array words
    
    if from hash sym_adj item { from array current_tag item [ const TYPE ] } do
        # The word is an adverb. Do nothing.
    done
    if from hash sym_prep item { from array current_tag item [ const TYPE ] } do
    
        # The word is a preposition. Search an entitiy after this word.
        set new hash parsed to parse_what with var lang, array words, hash tags, "nothing", flag found_subject
        
        if defined hash parsed && that hash is not empty: hash parsed end check do
            # TEXT
            # It's not empty.
            # In "hash parsed", there is the last word, either a noun, an adjective or an article.
            # CODE
            
            if not from hash parsed item { "questionword" } do
                set from hash parsed item { "questionword" } to an empty array
            done
            if not that array is empty: from hash parsed item { "questionword" } end check do
                # TEXT
                # A question word was found! DO NOT add everything to the "adverbs" column.
                # Instead, add everything where it fits best.
                # CODE
                
                set new array keys to [ keys of hash parsed ]
                for each new var key in array keys do
                    set new array new_value to from hash full_entity item { var key }
                    push into array new_value, items of that array: from hash parsed item { var key } end items of
                    set from hash full_entity item { var key } to array new_value
                done
            done
            else do
                # TEXT
                # No question word found...
                # CODE
                    
                
                set new array keys to [ 'adverbs', 'subjects', 'objects' ]
                for each new var key in array keys do
                    if from hash parsed item { var key } do
                        set new array new_value to from hash parsed item { var key }
                        for each new var value in array new_value is rw do
                            set var value to from array value item [ 0 ]
                        done
                        # push into array new_value, items of that array: [ values items of hash parsed ] item [ 0 ] end items of
                        if is not an empty array new_value do
                            set var entity to var entity concat ' ' concat do join using " ", items of array new_value
                        done
                    done
                done
                
                # TEXT
                # Example for this feature: durch die 1905 _entwickelte_ Relativitaetstheorie
                # CODE
                if from hash sym_verb item { from hash tags item { from array words first item } first item } do
                    if from hash sym_noun item { from hash tags item { from array words item [ 1 ] } first item } do
                        set var entity to var entity concat ' ' concat from array words first item
                        do shift with items of array words
                        set var entity to var entity concat ' ' concat from array words first item
                        do shift with items of array words
                    done
                done
                if from hash sym_linking item { from hash tags item { from array words first item } first item } do
                    set var entity to var entity concat ' ' concat from array words first item
                    do shift with items of array words
                done
                
            done
        done
    done

    set from hash full_entity item { var entity_key_name } to [ [ var entity ] ]

    print var ident
    print "#    "
    print "End do parse_using_preposition."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_using_questionword with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_questionword."
    print new line
    
    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array

    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So push it into "hash full_entity"
    # CODE
    set new var current_word to from array words item [ 0 ]
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words item [ 1 ]
    set new array next_tag to from hash tags item { var next_word }
    set new var nextnext_word to from array words item [ 2 ]
    set new array nextnext_tag to from hash tags item { var nextnext_word }

    shift from array words
    if from hash sym_adj item { from array next_tag item [ const TYPE ] } and not from hash sym_noun item { from array nextnext_tag item [ const TYPE ] } do
        # The word is an adverb. Fetch it.
        set from hash full_entity item { "extra" } to [ [ var next_word ] ]
        shift from array words
    done
    if from hash sym_noun item { from array next_tag item [ const TYPE ] } and not from hash val_omit item { lc(var next_word) } do
        if from hash sym_verb item { from array nextnext_tag item [ const TYPE ] } do
            # The word is a noun folowed by a verb. Fetch it.
            set from hash full_entity item { "extra" } to [ [ var next_word ] ]
            shift from array words
        done
    done
    
    set from hash full_entity item { "questionword" } to [ [ lc(var current_word) ] ]

    print var ident
    print "#    "
    print "End do parse_using_questionword."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_using_keyword with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_keyword."
    print new line
    
    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array
    set from hash full_entity item { "extra" } to an empty array

    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So push it into "hash full_entity"
    # CODE
    shift from array words
    set new var current_word to from array words item [ 0 ]
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words item [ 1 ]
    set new array next_tag to from hash tags item { var next_word }

        # Fetch all words.
    while var current_word do
        do push using items of that array: from hash full_entity item { "extra" } end-items-of, [ var current_word ]
        shift from array words
        set var current_word to from array words item [ 0 ]
        set array current_tag to from hash tags item { var current_word }
        set var next_word to from array words item [ 1 ]
        set array next_tag to from hash tags item { var next_word }
        
        if from hash sym_prep item { from array current_tag first item } do
            go to last
        done
        if from hash sym_verb item { from array current_tag first item } do
            go to last
        done
    done
    
    print var ident
    print "#    "
    print "End do parse_using_keyword."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_what with var lang, array words, hash tags, var what, flag found_subject do
    do be_slow without arguments

    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print 'Begin do parse_what: flag found_subject is ' concat flag found_subject concat ', var what is ' concat var what
    print new line


    set new hash parsed to an empty hash
    set from hash parsed item { "subjects" } to an empty array
    set from hash parsed item { "objects" } to an empty array
    set from hash parsed item { "verbs" } to an empty array
    set from hash parsed item { "adverbs" } to an empty array

    set new var go_on to 1
    while var go_on do
    
        do be_slow without arguments

        set new var current_word to from array words item [ 0 ]
        set new array current_tag to from hash tags item { var current_word }
        set new var next_word to from array words item [ 1 ]
        set new array next_tag to from hash tags item { var next_word }
        
        if not var current_word do
            print var ident
            print "#    "
            print "End do parse_what(->3)."
            print new line
            set var ident to var ident concat "\b\b"
            if is an empty hash parsed do
                do return using undef
            done
            else do
                do return using hash parsed
            done
        done

        print var ident
        print "#    "
        print "  :: current " concat var current_word concat " - " concat from array current_tag item [ const TYPE ]
        print new line

        if from hash sym_keyword item { var current_word } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_keyword using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
            
            if var current_word matches "ENUMALL" do
                do unshift using items of that array: from hash parsed item { "extra" } end-items-of, [ var current_word ]
            done
        done
        else if from global hash builtin_time_place_adverbs item { var current_word } or var current_word matches /^in_/ or ( from hash sym_adj item { from array current_tag item [ const TYPE ] } and not from hash sym_entity item { from array next_tag item [ const TYPE ] } ) do
            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
            
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_preposition using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
        done
        else if from hash sym_entity item { from array current_tag item [ const TYPE ] } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_entity using var lang, array words, hash tags, flag found_subject, var what
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done

            if var what matches "nothing" do
                if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
                    print var ident
                    print "#    "
                    print "End do parse_what(->5)."
                    print new line
                    set var ident to var ident concat "\b\b"
                    do return using hash parsed
                done
            done

            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->3)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
        done
        else if from hash sym_linking item { from array current_tag item [ const TYPE ] } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_entity using var lang, array words, hash tags, flag found_subject, var what
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done

            if var what matches "nothing" do
                if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
                    print var ident
                    print "#    "
                    print "End do parse_what(->5)."
                    print new line
                    set var ident to var ident concat "\b\b"
                    do return using hash parsed
                done
            done

            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->3)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
        done
        else if from hash sym_questionword item { from array current_tag item [ const TYPE ] } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_questionword using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
        done
        else if from hash sym_prep item { from array current_tag item [ const TYPE ] } do
            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
            
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_preposition using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
            
            set new var preposition to var current_word
            set var current_word to from array words item [ 0 ]
            set array current_tag to from hash tags item { var current_word }
            set var next_word to from array words item [ 1 ]
            set array next_tag to from hash tags item { var next_word }
            while from hash sym_linking item { from array current_tag item [ const TYPE ] } do
                set from array words first item to var preposition concat " " concat from array words first item
                set ( new hash add_parsed, new var go_on ) to array-returning parse_using_preposition using var lang, array words, hash tags, flag found_subject
                set new array keys to [ keys of hash add_parsed ]
                for each new var key in array keys do
                    set new array new_value to from hash parsed item { var key }
                    push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                    set from hash parsed item { var key } to array new_value
                done

                set var current_word to from array words item [ 0 ]
                set array current_tag to from hash tags item { var current_word }
                set var next_word to from array words item [ 1 ]
                set array next_tag to from hash tags item { var next_word }
            done
        done
        else if from hash sym_verb item { from array current_tag item [ const TYPE ] } do
            if var what matches "nothing" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done

            set new array add_parsed to parse_using_verb using var lang, array words, hash tags, flag found_subject

            if that array is not empty: from hash parsed item { "subjects" } end check do
                set flag found_subject to 1
            done

            if not from hash parsed item { "verbs" } do
                set from hash parsed item { "verbs" } to an empty array
            done
            do push using items of that array: from hash parsed item { "verbs" } end-items-of, items of array add_parsed
        done
        else do
            print var ident
            print "#    "
            print "Unknown part of speech: " concat var current_word
            print new line
            shift from array words
        done
    end loop

    print var ident
    print "#    "
    print "End do parse_what(->1)."
    print new line
    set var ident to var ident concat "\b\b"

    do return using hash parsed
done

define action pre_parse with array list_of_words, hash tags, var lang, var path do
    set new array list_of_list_of_words to an empty array
    set new array list_of_questionwords to an empty array
    push into array list_of_list_of_words, an empty array
    push into array list_of_questionwords, an empty array
    set new var array_index to 0

    set new var i to 0
    for each new var word in array list_of_words is rw do
        if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_verb item { from hash tags item { from array list_of_words item [ var i - 1 ] } first item } and from hash sym_entity item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            do push with items of that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
        done
        else if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_verb item { from hash tags item { from array list_of_words item [ var i - 1 ] } first item } and from hash sym_prep item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            do push with items of that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
        done
        else if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_verb item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            do push with items of that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
        done
        else do
            do push with items of that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
            
            if from hash sym_questionword item { from hash tags item { var word } first item } do
                do push with items of that array: from array list_of_questionwords item [ var array_index ] end-items-of, var word
            done
        done

        set var i to var i + 1
    done
    
    do return with array list_of_list_of_words
done

define action parse with var lang, array words, hash tags do
    set new hash parsed to an empty hash
    
    # TEXT
    # In German, there are many verbs which are sometimes written as
    # "$prefix$verb", but also as "$verb $prefix" (as two words).
    # Changing the second form into the first one is done by
    # first searching the prefixes and then prepending them to the verb.
    # <br /><br />
    # Search prefixes:
    # CODE
    
    set new var prefix to ''
    
    set new array words_correct to an empty array
    set new var i to 0
    for each new var word in array words is copy do
        if from global hash builtin_verb_prefixes item { lc(var word) } and from array words item [ var i + 1 ] matches "" do
            # TEXT
            # It is a prefix.
            # CODE
            
            if var word do
                set var prefix to var word
            done
        done
        else do
            # TEXT
            # It's another word. Add it to the new words array.
            # CODE
            
            push into array words_correct, var word
        done
        set var i to var i + 1
    done
    
    
    
    # TEXT
    # Add prefixes to the verb(s):
    # CODE
    if var prefix do
        set array words to [ items of array words_correct ]
        set array words_correct to an empty array
        for each new var word in array words is copy do
            if from hash sym_verb item { from hash tags item { var word } first item } do
                # TEXT
                # It is a verb.
                # CODE
                
                set from hash tags item { var prefix concat var word } to from hash tags item { var word }
                
                set var word to var prefix concat var word
            done

            push into array words_correct, var word
        done
    done
    
    set hash parsed to parse_what using var lang, array words_correct, hash tags, "full", 0
    DEBUG VAR: hash parsed STOP DEBUG
    do return using hash parsed
done

define action compute_context with hash parsed do
    set new array questionword_array to from hash parsed item { 'questionword' } item [ 0 ]
    set new array verb_array to from hash parsed item { 'verbs' }
    set new array extra_array to from hash parsed item { 'extra' }
    
    if from array questionword_array first item matches "wie" or from array questionword_array first item matches "how" do
        do return with "q_how"
    done
    if from array questionword_array first item matches /^welch/ do
        do return with "q_what_prep"
    done
    if from array questionword_array first item matches /^woher/ do
        do return with "q_from_where"
    done
    if from array questionword_array first item matches /^wo/ or from array questionword_array first item matches "where" do
        do return with "q_where"
    done
    if from array questionword_array first item matches /^wer/ or from array questionword_array first item matches "who" do
        do return with "q_who"
    done
    if lc(from array questionword_array first item) matches "was" or lc(from array questionword_array first item) matches "what" do
        if from array verb_array first item matches "bist" do
            do return with "q_what_exactly"
        done
        else do
            do return with "q_what_weakly"
        done
    done

    if lc(from array extra_array first item first item) matches "enumall" do
        do shift with items of that array: from array extra_array first item end-items-of
        set from hash parsed item { 'extra' } to array extra_array
        do return with "enum_all"
    done

    do return with "default"
done

define action logic with var input, var lang, var path, hash parsed do
    set new array request_verb_array to an empty array
    if from hash parsed item { 'verbs' } do
        push into array request_verb_array, items of that array: from hash parsed item { 'verbs' } end-items-of
    done
    set new array override_verb_array to an empty array

    set new flag verb_flag_want   to 0
    set new flag verb_flag_must   to 0
    set new flag verb_flag_can    to 0
    set new flag verb_flag_may    to 0
    set new flag verb_flag_should to 0

    if array request_verb_array do
        set new var num_of_verbs to items of array request_verb_array
        if var num_of_verbs >= 2 do
            set new array new_verbs to an empty array
            set new flag do_removed to 0
            for each new array verb_array in array request_verb_array is rw do
                set new var verb to from array verb_array first item
                if not flag do_removed do
                    # TEXT
                    # Remove "do" and "does" in englishs entences
                    # CODE
                    if var verb matches /^(does|do)$/ do
                        set flag do_removed to 1
                        go to next
                    done
                    
                    # TEXT
                    # Turn verbs like "must" or "want" into flags
                    # CODE
                    set new var verb_category to verb_category with var verb
                    
                    if var verb_category do
                        set var verb to var verb concat "/" concat var verb_category
                        set from array verb_array first item to var verb
                        push into array override_verb_array, array verb_array
                    done
                    
                    if var verb_category matches 'want' do
                        set flag verb_flag_want to 1
                        go to next
                    done
                    if var verb_category matches 'must' do
                        set flag verb_flag_must to 1
                        go to next
                    done
                    if var verb_category matches 'can' do
                        set flag verb_flag_can to 1
                        go to next
                    done
                    if var verb_category matches 'may' do
                        set flag verb_flag_may to 1
                        go to next
                    done
                    if var verb_category matches 'should' do
                        set flag verb_flag_should to 1
                        go to next
                    done
                done
                push into array new_verbs, array verb_array
                push into array override_verb_array, array verb_array
            done
            set items of array request_verb_array to items of array new_verbs
        done
        else do
            if from hash parsed item { 'verbs' } do
                set items of array override_verb_array to items of that array: from hash parsed item { 'verbs' } end-items-of
            done
        done
    done
    set items of that array: from hash parsed item { 'verbs' } end-items-of to items of array override_verb_array

    set new array request_verb to an empty array
    for each new array verb in array request_verb_array is rw do
        set new var multiple_choices_verb to multiple_choices_verb with from array verb first item
        push into array request_verb, var multiple_choices_verb
    done

    set new array request_subjects_array to from hash parsed item { 'subjects' }
    set new array request_subjects to an empty array
    for each new array subjects in array request_subjects_array is rw do
        push into array request_subjects, from array subjects first item
    done

    set new array request_objects_array to from hash parsed item { 'objects' }
    set new array request_objects to an empty array
    for each new array objects in array request_objects_array is rw do
        if not from array objects first item matches /nothing/ do
            push into array request_objects, from array objects first item
        done
    done

    set new array request_adverbs_array to from hash parsed item { 'adverbs' }
    set new array request_adverbs to an empty array
    for each new array adverbs in array request_adverbs_array is rw do
        if not from array adverbs first item matches /nothing/ do
            push into array request_adverbs, from array adverbs first item
        done
    done

    set new var request_context_string to compute_context using hash parsed

    set new array request_extra_array to from hash parsed item { 'extra' }
    set new array request_extra to an empty array
    for each new array extra in array request_extra_array is rw do
        if not from array extra first item matches /nothing/ do
            push into array request_extra, from array extra first item
        done
    done
    
    set items of array request_verb to sort with items of array request_verb
    
    set new var request_verb_string to join using ' ', items of array request_verb
    set new var request_subjects_string to join using ' ', items of array request_subjects
    set new var request_objects_string to join using ' ', items of array request_objects
    set new var request_adverbs_string to join using ' ', items of array request_adverbs
    set new var request_extra_string to join using ' ', items of array request_extra

    if var request_verb_string or var request_subjects_string or var request_objects_string or var request_adverbs_string do
        set new var flowchart_log to handle for file name var path concat '/flowchart.log', append
        print into var flowchart_log data "begin box"
        print into var flowchart_log data new line
        print into var flowchart_log data "bckgrndcolr D0FFCF"
        print into var flowchart_log data new line
        print into var flowchart_log data "bordercolor D0FFCF"
        print into var flowchart_log data new line
        print into var flowchart_log data "linesoftext 7"
        print into var flowchart_log data new line
        print into var flowchart_log data "draw"
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Verbs:\t" concat var request_verb_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Subjects:\t" concat var request_subjects_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Objects:\t" concat var request_objects_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Adverbs:\t" concat var request_adverbs_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Other:\t" concat var request_extra_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Context:\t" concat var request_context_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Modal verbs:\twant: " concat flag verb_flag_want concat "\tmust: " concat flag verb_flag_must concat "\tcan: " concat flag verb_flag_can concat "\tmay: " concat flag verb_flag_may concat "\tshould: " concat flag verb_flag_should
        print into var flowchart_log data new line
        print into var flowchart_log data "end box"
        print into var flowchart_log data new line
        do close with var flowchart_log
    done

    set array request_subjects to stem_nouns with [ var request_subjects_string ]
    set array request_objects to stem_nouns with [ var request_objects_string ]
    set array request_extra to stem_nouns with [ var request_extra_string ]
    set var request_subjects_string to from array request_subjects first item
    set var request_objects_string to from array request_objects first item
    set var request_extra_string to from array request_extra first item

    set new var request_primary_key to from hash parsed item { 'primary_key' }
    if not var request_primary_key do
        set var request_primary_key to "0"
    done

    set new var output_file_name to '_output__get_csv'
    set new var output to ''
    set var output to var output concat ( lc(var request_verb_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_subjects_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_objects_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_adverbs_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_extra_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_context_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_primary_key) || '0' )
    
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_want   || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_must   || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_can    || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_may    || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_should || '0' )


    do unlink with '_input__get_csv'

    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data var output
    do close with var output_handle

    while not exists: '_input__get_csv', end test do
        do wait 0.5 seconds
    done
    print "File exists now: _input__get_csv"
    print new line
    
    set new array results to an empty array
    set new var input_file_name to '_input__get_csv'
    set new var input_handle to handle for file name var input_file_name, read

    for each new var line from var input_handle is rw do
        print var line
        print new line
        set new array result to an empty array
        set new array rawresult to split using /\^/, var line
        
        # TEXT
        # Shift Primary key
        # CODE
        set new var primary_key to shift with items of array rawresult
        
        # TEXT
        # Divide main clause and sub clauses
        # CODE
        push into array result, an empty array
        set new var number_of_clause to 0
        set new var i to 0
        while var i < 6 do
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ var i ]
            set var i to var i + 1
        done
        
        # TEXT
        # Truth goes from 1.0 to 0.0.
        # CODE
        
        do adjust_truth with array result, from array rawresult item [ var i ], var number_of_clause, 0
        set var i to var i + 1
        
        # TEXT
        # Now add the subclauses to the array.
        # CODE
        
        set new var offs to var i
        push into array result, an empty array
        set var number_of_clause to var number_of_clause + 1
        set var i to 0
        while var i < 10 do
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 0 ]
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 1 ]
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 2 ]
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 3 ]
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 4 ]
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 5 ]
            do push using items of that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 6 ]
            do adjust_truth with array result, from array rawresult item [ var offs - 1 + 6 ], var number_of_clause, var i
            set var i to var i + 1
            push into array result, an empty array
            set var number_of_clause to var number_of_clause + 1
        done
        
        # TEXT
        # Unshift Primary key
        # CODE
        do unshift with items of array result, var primary_key
        
        push into array results, array result
    done

    print "Found " concat items of array results concat " sentences"
    print new line

    # TEXT
    # Exception: If we are in the "enum_all" context, all subjects together are the object
    # CODE
    if var request_context_string matches "enum_all" do
        set new hash subjects to an empty hash
    
        for each new array result in array results do
            print from array result item [ 1 ] item [ 0 ] concat new line
            print from array result item [ 1 ] item [ 1 ] concat new line
            print from array result item [ 1 ] item [ 2 ] concat new line
            print from array result item [ 1 ] item [ 3 ] concat new line
            print from array result item [ 1 ] item [ 4 ] concat new line
            print from array result item [ 1 ] item [ 5 ] concat new line
            print from array result item [ 1 ] item [ 6 ] concat new line
            print from array result item [ 1 ] item [ 7 ] concat new line
            print "---"
            print new line
            print new line
        
            set from hash subjects item { from array result item [ 1 ] item [ 1 ] } to 1
        done

        set new array overall_result to an empty array
        do unshift with items of array overall_result, 0
        push into array overall_result, an empty array
        set from array overall_result item [ 1 ] item [ 1 ] to join ', ', keys of hash subjects

        set array results to an empty array
        push into array results, array overall_result
    done
    
    do unlink with '_input__get_csv'

    do return using array results
done

define action phrase with var lang, var mode, array results, hash parsed do
    set new array phrases to an empty array

    # TEXT
    # Iterate through all results.
    # CODE
    for each new array result in array results do
        set new var primary_key to shift with items of array result

        set new var final_sentence to ""
        
        for each new array clause in array result do
            set new array sentence to an empty array

            # TEXT
            # Tag and sort all verbs.
            # CODE
            set new array raw_verbs to [ split ' ', from array clause item [0] ]
            set new array proper_verbs to an empty array
            set new array auxiliary_verbs to an empty array
            
            for each new var verb in array raw_verbs do
                if var verb matches /=>/ do
                    # TEXT
                    # We have such a sentence:
                    # "Clause to match , => Clause to print"
                    # SO we have to remove the first one
                    # CODE
                    set var final_sentence to ""
                done
                
                if var verb matches /([01])([01])([01])([01])([01])$/ do
                    set new var person to get_person with hash parsed item { 'subjects' } first item
                    
                    set new var is_want to $0
                    set new var is_must to $1
                    set new var is_can to $2
                    set new var is_may to $3
                    set new var is_should to $4
                    
                    if var is_want do
                        set new var new_verb to get_verb with "want", var person
                        if var new_verb do
                            push into array auxiliary_verbs, var new_verb
                        done
                    done
                    
                    if var is_must do
                        set new var new_verb to get_verb with "must", var person
                        if var new_verb do
                            push into array auxiliary_verbs, var new_verb
                        done
                    done
                    
                    if var is_can do
                        set new var new_verb to get_verb with "can", var person
                        if var new_verb do
                            push into array auxiliary_verbs, var new_verb
                        done
                    done
                    
                    if var is_may do
                        set new var new_verb to get_verb with "may", var person
                        if var new_verb do
                            push into array auxiliary_verbs, var new_verb
                        done
                    done
                    
                    if var is_should do
                        set new var new_verb to get_verb with "should", var person
                        if var new_verb do
                            push into array auxiliary_verbs, var new_verb
                        done
                    done
                    
                    do regex using var verb: /([01])([01])([01])([01])([01])$/, "", :global
                done
                
                if from global hash builtin_auxiliary_verbs item { var verb } do
                    push into array auxiliary_verbs, var verb
                done
                else do
                    push into array proper_verbs, var verb
                done
            done
            
            
            # TEXT
            # Build the final sentence.
            # CODE
            if items of array auxiliary_verbs or items of array proper_verbs or from array clause item [1] do
                print "auxiliary verbs: "
                print items of array auxiliary_verbs
                print new line
                print "proper verbs: "
                print items of array proper_verbs
                print new line
                
                if not items of array auxiliary_verbs do
                    set items of array auxiliary_verbs to items of array proper_verbs
                    set array proper_verbs to an empty array
                done
                
                # TEXT
                # Replace *s
                # CODE
                if from array clause item [1] matches "*" do
                    if from array clause item [2] matches "*" do
                        if lc( hash parsed item { 'subjects' } first item ) matches /array/ do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item first item
                        done
                        else do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item
                        done
                    done
                    else do
                        if lc( hash parsed item { 'subjects' } first item ) matches /array/ do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item first item
                        done
                        else do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item
                        done
                    done
                done
                if from array clause item [2] matches "*" do
                    if from array clause item [1] matches "*" do
                        if lc( hash parsed item { 'objects' } first item ) matches /array/ do
                            set from array clause item [2] to hash parsed item { 'objects' } first item first item
                        done
                        else do
                            set from array clause item [2] to hash parsed item { 'objects' } first item
                        done
                    done
                    else do
                        if lc( hash parsed item { 'subjects' } first item ) matches /array/ do
                            set from array clause item [2] to hash parsed item { 'subjects' } first item first item
                        done
                        else do
                            set from array clause item [2] to hash parsed item { 'subjects' } first item
                        done
                    done
                done
                
                if from array clause item [2] matches "NULL" do
                    push into array sentence, from array clause item [1]
                    push into array sentence, items of array auxiliary_verbs
                    push into array sentence, from array clause item [3]
                    push into array sentence, items of array proper_verbs
                done
                else if from array clause item [3] matches /von/ do
                    push into array sentence, from array clause item [1]
                    push into array sentence, items of array auxiliary_verbs
                    push into array sentence, from array clause item [2]
                    push into array sentence, from array clause item [3]
                    push into array sentence, items of array proper_verbs
                done
                else do
                    push into array sentence, from array clause item [1]
                    push into array sentence, items of array auxiliary_verbs
                    push into array sentence, from array clause item [2]
                    push into array sentence, from array clause item [3]
                    push into array sentence, items of array proper_verbs
                done
                
                if var final_sentence do
                    set var final_sentence to var final_sentence concat ', '
                done
                
                set var final_sentence to var final_sentence concat join ' ', items of array sentence
            done
        done

        if var final_sentence matches / dacht/ and not var final_sentence matches /<[,]>/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches / [=] / and not var final_sentence matches /<[,]>/ do
            # TEXT
            # A Sentence must not have the verb "="
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        set var final_sentence to compute_output with var final_sentence
        push into array phrases, [ var primary_key, var final_sentence ]
    done
    
    do return using array phrases
done

define action post_phrase with var lang, var path, var mode, hash parsed, array output do
    set new var primary_key to shift with items of array output
    
    set new var final_sentence to from array output first item

    # TEXT
    # Add linked sentences...
    # CODE
    if var primary_key do
        # TEXT
        # After the sentence.
        # CODE
        set new hash hash_link_order to an empty hash
        set from hash hash_link_order item { 'primary_key' } to var primary_key
        set new array results_link_order to logic with '', var lang, var path, hash hash_link_order
        for each new array result_link_order in array results_link_order do
            set from array result_link_order first item to ''
        done
        set array results_link_order to phrase with var lang, var mode, array results_link_order, hash parsed
        set new var i_random to rand with items of array results_link_order
        set new var result_link_order to from array results_link_order item [ var i_random ]
        if var result_link_order do
            set var final_sentence to var final_sentence concat ". " concat var result_link_order
        done

        # TEXT
        # Before the sentence.
        # CODE
        set new hash hash_link_order to an empty hash
        set from hash hash_link_order item { 'primary_key' } to 0 - var primary_key
        set new array results_link_order to logic with '', var lang, var path, hash hash_link_order
        for each new array result_link_order in array results_link_order do
            set from array result_link_order first item to ''
        done
        set array results_link_order to phrase with var lang, var mode, array results_link_order, hash parsed
        set new var i_random to rand with items of array results_link_order
        set new var result_link_order to from array results_link_order item [ var i_random ]
        if var result_link_order do
            set var final_sentence to var result_link_order concat ". " concat var final_sentence
        done
    done

    do return with var final_sentence
done

define action use_mode with var input is copy, array facts_to_save, hash tags, var lang, var path, var mode do
    set new var is_question to "no"
    if var input matches /<[?]>/ do
        set var is_question to "yes"
    done
    do regex using var input: /(<[.!?]>)/, "", :global
    
    set new var save_input to "no"
    if var mode matches "statement" do
        set var save_input to "yes"
    done
    if lc(var input) matches /^\/save / do
        do regex using var input: /^\/save /, "", :global:i
        set var save_input to "yes"
    done
    
    # TEXT
    # First we try some methods for finding out an answer without logic.
    # CODE
    set new flag is_a_greeting to check_for_greeting using var input
    if flag is_a_greeting do
        set new var greeting to greet with ''
        do return with [ var greeting ]
    done
    set new flag is_math to check_for_math using var input
    if flag is_math do
        do return with [ flag is_math ]
    done
    set new var appname to check_invoke using var input
    if var appname do
        set new var answer to invoke with var appname
        do return with [ var answer ]
    done
    set new var place to check_sentence_for_weather with var input
    if var place do
        do check_for_weather with var place, var lang, var path
    done

    # TEXT
    # No unlogical answers? Make the komma's readable.
    # CODE
    set var input to make_parsable with var input
    do regex using var input: /<[,]>\s/, " KOMMA ", :global:i
    do regex using var input: /(\D)<[.]>/, "${1} DOT ", :global:i
    do regex using var input: /\s+/, " ", :global:i
    print "Parsable sentence(s): "
    print var input
    print new line
    
    set new hash genus_of to an empty hash

    set new array clauses_input to split with " KOMMA ", var input
    set new hash parsed to an empty hash
    for each new var clause in array clauses_input do
        # TEXT
        # Split the sentence.
        # CODE
        set new array list_of_words to split with " ", var clause
        
        # TEXT
        # Then compute the parts of speech etc.
        # CODE
        for each new var word in array list_of_words is rw do
            set from hash tags item { var word } to compute_tags with var word, var lang, var path
            set from hash genus_of item { lc(var word) } to from hash tags item { var word } first item
        end for
        
        set new array list_of_list_of_words to pre_parse with array list_of_words, hash tags, var lang, var path
        
        for each new array words in array list_of_list_of_words is rw do
            # TEXT
            # Then toggle the identities (user <-> machine).
            # CODE
            if is an empty hash parsed do
                set hash parsed to parse with var lang, array words, hash tags
                set new array entities to an empty array
                push into array entities, items of that array: from hash parsed item { 'subjects' } end items of
                push into array entities, items of that array: from hash parsed item { 'objects' } end items of
                set from hash parsed item { 'verbs' } to toggle_verbs using from hash parsed item { 'verbs' }, array entities
                set from hash parsed item { 'subjects' } to toggle_entities using from hash parsed item { 'subjects' }
                set from hash parsed item { 'objects' } to toggle_entities using from hash parsed item { 'objects' }
                set from hash parsed item { 'adverbs' } to toggle_entities using from hash parsed item { 'adverbs' }
                set from hash parsed item { 'extra' } to toggle_entities using from hash parsed item { 'extra' }
                set from hash parsed item { 'clauses' } to an empty array
            done
            else do
                set new hash parsed_clause to parse with var lang, array words, hash tags
                set new array entities to an empty array
                push into array entities, items of that array: from hash parsed_clause item { 'subjects' } end items of
                push into array entities, items of that array: from hash parsed_clause item { 'objects' } end items of
                set from hash parsed_clause item { 'verbs' } to toggle_verbs using from hash parsed_clause item { 'verbs' }, array entities
                set from hash parsed_clause item { 'subjects' } to toggle_entities using from hash parsed_clause item { 'subjects' }
                set from hash parsed_clause item { 'objects' } to toggle_entities using from hash parsed_clause item { 'objects' }
                set from hash parsed_clause item { 'adverbs' } to toggle_entities using from hash parsed_clause item { 'adverbs' }
                set from hash parsed_clause item { 'extra' } to toggle_entities using from hash parsed_clause item { 'extra' }
                set from hash parsed_clause item { 'clauses' } to an empty array
                do push using items of that array: from hash parsed item { 'clauses' } end-items-of, hash parsed_clause
            done
        done
    done
    
    # TEXT
    # Save male and female substantives
    # CODE
    set new array copy_subjects to from hash parsed item { 'subjects' }
    set new var genus_subject to 'q'
    set new var subject to ''
    set new var male_names to global array builtin_male_names
    for each new array arr in array copy_subjects do
        if var subject do
            set var subject to var subject concat ' '
        done
        set var subject to var subject concat join " ", items of array arr
        
        if from hash genus_of item { lc(join " ", items of array arr) } matches /m|f/ do
            set var genus_subject to from hash genus_of item { lc(join " ", items of array arr) }
        done
        for each new var male_name in array male_names do
            if var male_name matches lc(join " ", items of array arr) do
                set var genus_subject to 'm'
            done
        done
    done

    set new array copy_objects to from hash parsed item { 'objects' }
    set new var genus_object to 'q'
    set new var object to ''
    for each new array arr in array copy_objects do
        if var object do
            set var object to var object concat ' '
        done
        set var object to var object concat join " ", items of array arr
        
        if from hash genus_of item { lc(join " ", items of array arr) } matches /m|f/ do
            set var genus_object to from hash genus_of item { lc(join " ", items of array arr) }
        done
        for each new var male_name in array male_names do
            if var male_name matches lc(join " ", items of array arr) do
                set var genus_subject to 'm'
            done
        done
    done
    
    print "genus of subject: ", var genus_subject, new line
    print "genus of object:  ", var genus_object,  new line
    
    if var subject matches /^(er|sie|es|ihn|ihm|ihr)$/ do
        set var subject to ''
    done
    if var object matches /^(er|sie|es|ihn|ihm|ihr)$/ do
        set var object to ''
    done
    
    set new var male_file to handle for file name var path concat '/lang_' concat var lang concat '/male.history', append
    if var genus_subject matches "m" and var subject do
        print into var male_file data var subject
        print into var male_file data new line
    done
    if var genus_object matches "m" and var object do
        print into var male_file data var object
        print into var male_file data new line
    done
    do close with var male_file
    
    set new var female_file to handle for file name var path concat '/lang_' concat var lang concat '/female.history', append
    if var genus_subject matches "f" and var subject do
        print into var female_file data var subject
        print into var female_file data new line
    done
    if var genus_object matches "f" and var object do
        print into var female_file data var object
        print into var female_file data new line
    done
    do close with var female_file

    # TEXT
    # Go on.
    # CODE
    set new array results to an empty array

    # TEXT
    # Then use logic.
    # CODE
    if var mode matches "question" do
        set array results to logic with var input, var lang, var path, hash parsed
        
        set new flag bug_feature to but_feature_is_useful with var input
        if flag bug_feature do
            set array results to use_bug_feature with array results, hash parsed
        done
    done
    if var mode matches "statement" do
        set array results to logic with var input, var lang, var path, hash parsed
    done
    if var save_input matches "yes" do
        push into array facts_to_save, hash parsed
        
        # TEXT
        # Grab the primary key of the fact
        # CODE
        ##set new var key_file to hndle for file name "_input_key", read
        ##set new var key to the next line from var key_file
        ##do close with var key_file
        
        ##push into array facts_to_link, var key
    done
    set array results to sort_out with array results, var mode, hash parsed
    set new array phrases to phrase with var lang, var mode, array results, hash parsed
    
    do return with array phrases
done

define action sort_out with array results, var mode, hash parsed do
    set new array results_proper to an empty array
    set new array results_variable_answer to an empty array
    set new array results_important to an empty array

    for each new array result in array results do
        set new var primary_key to shift with items of array result
        
        set new flag is_proper to 1
        set new flag is_important to 0
        for each new array clause in array result do
            set new array sentence to an empty array

            # TEXT
            # Look at the verbs. Do they contain "=>"? Verbs with "=>" would only be used if no other verbs are there.
            # CODE
            set new array raw_verbs to [ split ' ', from array clause item [0] ]
            set new var symbol to "=>"
            for each new var verb in array raw_verbs do
                if var verb matches /var symbol/ do
                    set flag is_proper to 0
                done
            done
            
            if lc( from array clause item [2] ) matches /freehal/ do
                if lc( from hash parsed item { 'questionword' } first item first item ) matches /wer|who/ do
                    set flag is_important to 1
                done
            done
        done
        
        do unshift with items of array result, var primary_key
        
        # TEXT
        # It is an important fact, for example "I am FreeHAL", because it contains "freehal"
        if flag is_important do
            push into array results_important, array result
        done
        
        # TEXT
        # Result is a proper result.
        # CODE
        if flag is_proper do
            push into array results_proper, array result
        done
        # TEXT
        # Result is no proper result.
        # CODE
        else do
            push into array results_variable_answer, array result
        done
    done
    
    set new array questionword_array to from hash parsed item { 'questionword' } item [ 0 ]
    # TEXT
    # First, prefer important answers
    # CODE
    if is not an empty array results_important do
        print "There are important sentences."
        print new line
        return array results_important
    done
    else do
        print "There are not any important sentences."
        print new line
    done
    # TEXT
    # If there is no questionword, prefer proper answers
    # CODE
    if not from array questionword_array first item do
        if is an empty array results_variable_answer or (items of array results_variable_answer)+50 < (items of array results_proper) do
            print "-> results_proper (1): " concat items of array results_proper concat " <-> " concat items of array results_variable_answer concat " = " concat items of array results
            print new line
            return array results_proper
        done
        else do
            print "-> results_variable_answer (2): " concat items of array results_variable_answer concat " <-> " concat items of array results_proper concat " = " concat items of array results
            print new line
            return array results_variable_answer
        done
    done
    else do
        if is an empty array results_proper do
            print "-> results_variable_answer (1): " concat items of array results_variable_answer concat " <-> " concat items of array results_proper concat " = " concat items of array results
            print new line
            return array results_variable_answer
        done
        else do
            print "-> results_proper (2): " concat items of array results_proper concat " <-> " concat items of array results_variable_answer concat " = " concat items of array results
            print new line
            return array results_proper
        done
    done
done

define action save_facts with array facts_parsed, var pro_file_name, var lang, var path do
    if not var pro_file_name do
        set var pro_file_name to var path concat '/lang_' concat var lang concat '/facts.pro'
    done
    set new var pro_file to handle for file name var pro_file_name, append
    
    print "Write some facts into " concat var pro_file_name concat "."
    print new line

    set new array line_array to an empty array

    for each new hash parsed in array facts_parsed do
        set new var line to ''
        
        set new array verbs to from hash parsed item { 'verbs' }
        for each new array verb in array verbs do
            set var verb to from array verb first item
        done
        set new array subjects to from hash parsed item { 'subjects' }
        for each new array subject in array subjects do
            set var subject to from array subject first item
        done
        set new array objects to from hash parsed item { 'objects' }
        for each new array object in array objects do
            set var object to from array object first item
        done
        set new array adverbs to from hash parsed item { 'adverbs' }
        for each new array adverb in array adverbs do
            set var adverb to from array adverb first item
        done

        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'verbs' } end-items-of
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'subjects' } end-items-of
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'objects' } end-items-of
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'adverbs' } end-items-of
        
        if not from hash parsed item { 'clauses' } do
            set from hash parsed item { 'clauses' } to an empty array
            set new hash empty_clause to an empty hash
            set from hash empty_clause item { 'verbs' } to an empty array
            set from hash empty_clause item { 'subjects' } to an empty array
            set from hash empty_clause item { 'objects' } to an empty array
            set from hash empty_clause item { 'adverbs' } to an empty array
            set from hash empty_clause item { 'questionword' } to an empty array
            do push items of that array: from hash parsed item { 'clauses' } end-items-of, hash empty_clause
        done
        
        if that array is empty: from hash parsed item { 'verbs' } end check and that array is empty: from hash parsed item { 'clauses' } end check do
            go to next
        done
        
        set new array clauses to from hash parsed item { 'clauses' }
        
        set new var number_of_clauses to 0
        for each new hash parsed in array clauses is rw do
            if var number_of_clauses do
                # TEXT
                # We can only add one ; per line because it's a keyword in hal2009 language
                # CODE
                set var line to var line concat ' ;'
                set var line to var line concat '; '
            done
            else do
                set var line to var line concat ' <> '
            done
        
            set new array verbs to from hash parsed item { 'verbs' }
            for each new array verb in array verbs do
                set var verb to from array verb first item
            done
            set new array subjects to from hash parsed item { 'subjects' }
            for each new array subject in array subjects do
                set var subject to from array subject first item
            done
            set new array objects to from hash parsed item { 'objects' }
            for each new array object in array objects do
                set var object to from array object first item
            done
            set new array adverbs to from hash parsed item { 'adverbs' }
            for each new array adverb in array adverbs do
                set var adverb to from array adverb first item
            done
            if not from hash parsed item { 'questionword' } do
                set from hash parsed item { 'questionword' } to an empty array
            done
            set new array questionwords to from hash parsed item { 'questionword' }
            for each new array questionword in array questionwords do
                set var questionword to from array questionword first item
            done
            
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'verbs' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'subjects' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'objects' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'adverbs' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'questionword' } end-items-of
            
            set var number_of_clauses to var number_of_clauses + 1
        done
        set var line to var line concat ' <> '
        set var line to var line concat '50'
        
        push into array line_array, var line
    done
    
    set new var divisor to ' ~ '
    set new var line to join with var divisor, items of array line_array
    
    if var line do
        print into var pro_file data lc(var line)
        print into var pro_file data new line
    done
    
    do close with var pro_file
    
    do reread_pro_file with var pro_file_name
done

define action reread_pro_file with var file do
    # TEXT
    # Write the signal file for re-reading
    # CODE
    set new var output_handle to handle for file name "_output__add_pro_file", write
    print into var output_handle data var file
    do close with var output_handle
done

define action execute_exe with var appname do
    set var appname to lc with var appname
    
    do regex using var appname: /<[-,+!?=]>/, "", :global

    set new flag is_unix to system with "uname"
    if not flag is_unix do
        # TEXT
        # A Linux/Unix system
        # CODE
        
        
        if exists: var appname, end test do
            do system with var appname concat " &"
        done
        else do
            set new flag is_in_path to system with "which " concat var appname
            if not flag is_in_path do
                do system with "bash -c '" concat `which var appname ` concat " &'"
            done
        done
    done
    else do
        # TEXT
        # No Unix, probably Windows
        # CODE
        
        set new flag is_in_path to system with var appname
        
        if 1 do

            set new var disk to "C:/"
            do opendir with new var dir_handle, var disk
            set new array files to [ readdir(var dir_handle) ]
            # TEXT
            # Search for Windows programs
            # CODE
            for each new var file_name in array files is rw do
                print var file_name
                print new line
                if not lc(var file_name) matches /^pro/ do
                    go to next
                done
                do opendir with new var dir_handle, var disk concat "/" concat var file_name
                set new array files to [ readdir(var dir_handle) ]
                for each new var sub_file_name in array files is rw do
                    print var sub_file_name
                    print new line
                    if not lc(var sub_file_name) matches /var appname/ do
                        go to next
                    done
                    do opendir with new var dir_handle, var disk concat "/" concat var file_name concat "/" concat var sub_file_name
                    set new array files to [ readdir(var dir_handle) ]
                    for each new var sub_sub_file_name in array files is rw do
                        print var sub_sub_file_name
                        print new line
                        if not lc(var sub_sub_file_name) matches /exe$/ do
                            go to next
                        done
                        do system with var disk concat "/" concat var file_name concat "/" concat var sub_file_name concat "/" concat var sub_sub_file_name
                    done
                    do closedir with var dir_handle
                done
                do closedir with var dir_handle
            done
            do closedir with var dir_handle
        done
        
    done
    
    do return with var appname
done

define action invoke with var appname do
    set new var answer_success to var appname concat "..."
    
    set new var exe to execute_exe with var appname
    print var exe
    print new line
    if var @ do
        print var @
        print new line
    done
    
    do return with var answer_success
done

define action make_ascii with var text is rw do
    do return with var text
done

define action modify_input with var input, var current_language, var path do
    if length(var input) < 10 and var input matches /warum/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', read
        set new var last_output to ''
        for each new var line from var input_handle do
            set var last_output to var line
        done
        
        if var last_output do
            set var input to "warum " concat var last_output
        done
    done
    if length(var input) < 15 and var input matches /warum das/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', read
        set new var last_output to ''
        for each new var line from var input_handle do
            set var last_output to var line
        done
        
        if var last_output do
            set var input to "warum " concat var last_output
        done
    done
    if var input matches /^weil/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/input.history', read
        set new var last_input to ''
        for each new var line from var input_handle do
            set var last_input to var line
        done
        
        if var last_input do
            set var input to var last_input concat " " concat var input
        done
    done
    
    return var input
done

define action save_input with var input, var current_language, var path do
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/input.history', append
    print into var output_handle data var input concat new line
    do close with var output_handle
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/dialog.history', append
    print into var output_handle data "input: " concat var input concat new line
    do close with var output_handle
done

define action save_output with var input, var current_language, var path do
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', append
    set new array outputs to split with /([<]br[>].*?\s)/, var input
    for each new var output in array outputs do
        if not var output matches /[<]br[>]/ do
            print into var output_handle data var output concat new line
        done
    done
    do close with var output_handle
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/dialog.history', append
    print into var output_handle data "output: " concat var input concat new line
    do close with var output_handle
done

define action give_output with var input is rw, array facts_to_save, hash tags, var current_language, var path do
    # TEXT
    # We try to use the answer as a judgement
    # CODE
    set new array score to check_score using var input
    if from array score item [ 1 ] do
        if from array score first item do
            do set_score_for_num with from array score item [ 1 ], from array score first item, var current_language, var path
        done
        else do
            do set_score_for_last with from array score item [ 1 ], var current_language, var path
        done

        set new var answer to get_score_answer without arguments
        do return with [ var answer ]
    done

    set (var input, new var no_change_pronouns) to compute_input with var input, var current_language, var path
    if not var input do
        do return with an empty array
    done

    print "Got input:          "
    print var input
    print new line
    set var input to modify_input with var input, var current_language, var path
    do save_input with var input, var current_language, var path
    print "Transformed (?) to: "
    print var input
    print new line
    
    print "Input is computed... Going on."
    print new line
    set new var mode to find_mode using var input
    set new array sentences to use_mode with var input, array facts_to_save, hash tags, var current_language, var path, var mode
    print "Output is..."
    print new line
    for each new array sentence in array sentences do
        if from array sentence item [ 1 ] do
            print "    - "
            print from array sentence item [ 1 ]
            print new line
        done
    done
    
    # TEXT
    # Flow chart log
    # CODE
    set new var num to items of array sentences
    set var num to var num + 1
    set new var flowchart_log to handle for file name var path concat '/flowchart.log', append
    print into var flowchart_log data "begin box"
    print into var flowchart_log data new line
    print into var flowchart_log data "bckgrndcolr FFD0BB"
    print into var flowchart_log data new line
    print into var flowchart_log data "bordercolor FFD0BB"
    print into var flowchart_log data new line
    print into var flowchart_log data "linesoftext " concat var num
    print into var flowchart_log data new line
    print into var flowchart_log data "draw"
    print into var flowchart_log data new line
    print into var flowchart_log data "textcontent 000000 Answers:"
    print into var flowchart_log data new line
    for each new array sentence in array sentences do
        if from array sentence item [ 1 ] do
            print into var flowchart_log data "linkcontent 000000 \t - " concat from array sentence item [ 0 ] concat ": " concat from array sentence item [ 1 ]
            print into var flowchart_log data new line
            print into var flowchart_log data "property    pk     " concat from array sentence item [ 0 ]
            print into var flowchart_log data new line
        done
        else do
            print into var flowchart_log data "textcontent 000000 \t - (invalid)"
            print into var flowchart_log data new line
        done
    done
    print into var flowchart_log data "end box"
    print into var flowchart_log data new line
    do close with var flowchart_log
    

    if is an empty array sentences do
        print "Well, no logic answer available."
        print new line
        set new array random to use_random with var input, var current_language, var path, var mode
        push into array sentences, items of array random
    done
    
    ##print "Primary keys are:"
    ##print new line
    ##for each new var key in array facts_to_link do
    ##    print "  - "
    ##    print var key
    ##    print new line
    ##done
    
    do return using array sentences
done

define action fake_hash_parsed without arguments do
    set new hash parsed to an empty hash
    set from hash parsed item { 'verbs' } to an empty array
    set from hash parsed item { 'subjects' } to an empty array
    set from hash parsed item { 'objects' } to an empty array
    set from hash parsed item { 'clauses' } to an empty array
    set from hash parsed item { 'adverbs' } to an empty array
    set from hash parsed item { 'questionword' } to an empty array
    do return with hash parsed
done

define action work_prot_line with var input, var file_name, var lang, var path do
    do be_slow without arguments
    do regex using var input: /(<[.!?]>)/, "", :global
    # TEXT
    # Make the komma's readable.
    # CODE
    set (var input, new var no_change_pronouns) to compute_input with var input, var lang, var path
    set var input to make_parsable with var input
    do regex using var input: /<[,]>\s/, " KOMMA ", :global:i
    do regex using var input: /(\D)<[.]>/, "${1} DOT ", :global:i
    do regex using var input: /\s+/, " ", :global:i
    set new array clauses_input to split with " KOMMA ", var input
    set new hash parsed to an empty hash
    set from hash parsed item { 'verbs' } to an empty array
    set from hash parsed item { 'subjects' } to an empty array
    set from hash parsed item { 'objects' } to an empty array
    set from hash parsed item { 'clauses' } to an empty array
    set from hash parsed item { 'adverbs' } to an empty array
    set from hash parsed item { 'questionword' } to an empty array
    set new flag number_of_clause to 0
    for each new var clause in array clauses_input do
        do be_slow without arguments

        # TEXT
        # Split the sentence.
        # CODE
        set new hash tags to an empty hash
        set new array words to split with " ", var clause
        
        # TEXT
        # Then compute the parts of speech etc.
        # CODE
        for each new var word in array words is rw do
            do be_slow without arguments
            set from hash tags item { var word } to compute_tags with var word, var lang, var path
        end for
        
        # TEXT
        # Then toggle the identities (user <-> machine).
        # CODE
        if flag number_of_clause is 0 do
            set hash parsed to parse with var lang, array words, hash tags
            set from hash parsed item { 'verbs' } to toggle_verbs using from hash parsed item { 'verbs' }
            set from hash parsed item { 'subjects' } to toggle_entities using from hash parsed item { 'subjects' }
            set from hash parsed item { 'objects' } to toggle_entities using from hash parsed item { 'objects' }
            set from hash parsed item { 'adverbs' } to toggle_entities using from hash parsed item { 'adverbs' }
            set from hash parsed item { 'clauses' } to an empty array
            
            set flag number_of_clause to 1
        done
        else do
            set new hash parsed_clause to parse with var lang, array words, hash tags
            set from hash parsed_clause item { 'verbs' } to toggle_verbs using from hash parsed_clause item { 'verbs' }
            set from hash parsed_clause item { 'subjects' } to toggle_entities using from hash parsed_clause item { 'subjects' }
            set from hash parsed_clause item { 'objects' } to toggle_entities using from hash parsed_clause item { 'objects' }
            set from hash parsed_clause item { 'adverbs' } to toggle_entities using from hash parsed_clause item { 'adverbs' }
            set from hash parsed_clause item { 'clauses' } to an empty array
            if not from hash parsed_clause item { 'questionword' } do
                set from hash parsed_clause item { 'questionword' } to an empty array
            done
            do push using items of that array: from hash parsed item { 'clauses' } end-items-of, hash parsed_clause
        done
    done
    if not is an empty hash parsed do
        do save_facts with [ hash parsed ], var file_name, var lang, var path
    done
done

define action init_prot_files with var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set new array sub_directories to [ '', '/thesaurus', '/..' ]
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .prot files by parsing them
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name
        
            do be_slow without arguments
            if not var file matches /prot$/ do
                go to next
            done

            set new var pro_file to var file
            do regex using var pro_file: /t$/, "", :i
            do unlink with var pro_file
            
            if (not var pro_file matches /data/) and exists: var pro_file, end test do
                go to next
            done

            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done

            if not var i is var j do

                do be_slow without arguments
                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

                print "Read (prot) file "
                print var file
                print new line
                
                do be_slow without arguments
                
                set new var pro_handle to handle for file name var pro_file, write
                do close with var pro_handle
                do be_slow without arguments
                
                set new var translation_input_handle to handle for file name var file, read
                for each new var line from var translation_input_handle is rw do
                    do be_slow without arguments
                    set new var line to work_prot_line with var line, var pro_file, var current_language, var path
                done
                do close using var translation_input_handle
            done
        done
    done
done

define action init with var current_language, var path do
    do init_prot_files with var current_language, var path
    do init_pro_files with var current_language, var path
done

define action init_pro_files with var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set new array sub_directories to [ '', '/thesaurus' ]
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .pro files by sending a signal to the C thread
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name

            if not var file matches /\.pro$/ do
                go to next
            done

            do unlink with '_output__add_pro_file'
            do unlink with '_input__add_pro_file'

            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done

            if not var i is var j do

                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

                print "Read file "
                print var file
                print new line

                # TEXT
                # Write the signal file
                # CODE
                set new var output_handle to handle for file name "_output__add_pro_file", write
                print into var output_handle data var file
                do close with var output_handle
                do wait 3 seconds

                # TEXT
                # Wait...
                # CODE
                while not exists: '_input__add_pro_file', end test do
                    do wait 0.1 seconds
                done
            done
            else do
                print "No changes have been made in file "
                print var save_path concat var file_name
                print "."
                print new line

            done
        done
    done
done

define action decide with array output, var input, flag all_output_phrases, var lang, var path do
    set new hash parsed to fake_hash_parsed without arguments
    set new var mode to "statement"

    if flag all_output_phrases do
        set new var output_str to ''
        set new var i to items of array output
        for each new array _item in array output do
            set new var item_str to post_phrase with var lang, var path, var mode, hash parsed, array _item
            set var output_str to var output_str concat var i concat ".) " concat var item_str concat '<br>'
            set var i to var i - 1
        done
        return var output_str
    done
    else do
        set new array words to split with " ", lc(var input)
        set new array rel_output to an empty array
        for each new array _item in array output do
            print "Score of " concat from array _item item [ 1 ] concat " is "
            set new var score to get_score with array words, from array _item item [ 1 ], var lang, var path
            print var score
            print new line
            set new var k to 0
            while var k < var score + 1 do
                push into array rel_output, array _item
                set var k to var k + 1
            done
        done
        
        # TEXT
        # If all scores are negative...
        # CODE
        if is an empty array rel_output do
            set array rel_output to array output
        done
        
        # TEXT
        # Choose an answer
        # CODE
        set new var random_number to rand using items of array rel_output
        set new array final_output to from array rel_output item [ var random_number ]
        set new var final_output_str to post_phrase with var lang, var path, var mode, hash parsed, array final_output
        do return var final_output_str
    done
done

define action link_facts with var type, var f1, var f2 do
    print "Linking " concat var f1 concat " and " concat var f2 concat " as " concat var type
    print new line
    set new var output_handle to handle for file name "_output__link", write
        print into var output_handle data var type
        print into var output_handle data new line
        print into var output_handle data var f1
        print into var output_handle data new line
        print into var output_handle data var f2
        print into var output_handle data new line
    do close with var output_handle
done

define action shell with var current_language, var path do
    set new var input_file_name to '_input'
    set new var input_handle to handle for file name var input_file_name, read

    set new array facts_to_save to an empty array

    for each new var sentences_as_line from var input_handle is rw do
        do regex using var sentences_as_line: /([?])/, "$0.", :global
        do regex using var sentences_as_line: /[.!~]\s*?[.!~]/, "~", :global
        do regex using var sentences_as_line: /[.!~]\s*?[.!~]/, "~", :global
        
        set var sentences_as_line to divide_input with var sentences_as_line, var current_language
        set new array sentences to split with /[.!~]/, var sentences_as_line

        for each new var line in array sentences do
        
            do regex using var line: /^\s+/, "", :global
            do regex using var line: /\s+$/, "", :global
            if not var line do
                go to next
            done

            set new flag all_output_phrases to 0
            if lc(var line) matches /^\/all / do
                do regex using var line: /^\/all /, "", :global:i
                set flag all_output_phrases to 1
            done
            
            do unlink with '_output'
            set new hash tags to an empty hash
            set new array output to give_output with var line, array facts_to_save, hash tags, var current_language, var path
            do unlink with '_output'

            set new var final_output to decide using array output, var line, flag all_output_phrases, var current_language, var path
            
            set var final_output to upper_case_correction with var final_output, hash tags, var current_language, var path
    
            do unlink with '_output'
            do save_output with var final_output, var current_language, var path
            set new var output_file_name to '_output'
            set new var output_handle to handle for file name var output_file_name, write
            print into var output_handle data var final_output
            do close with var output_handle

            print "Final output is..."
            print new line
            print "      "
            print var final_output
            print new line
        done
    done
    
    do save_facts with array facts_to_save, '', var current_language, var path
    do wait 2 seconds
    
    #set new var f1 to shift with items of array facts_to_link
    #set new var f2 to shift with items of array facts_to_link
    #if var f1 and var f2 do
    #    do link_facts with "order", var f1, var f2
    #
    #    set var f1 to var f2
    #    set var f2 to shift with items of array facts_to_link
    #done
    
    set new var exit_file_name to '_exit'
    set new var exit_handle to handle for file name var exit_file_name, write
    do close with var exit_handle
done

if 0 do
    set new var output_file_name to '_output__get_csv'
    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data "ist^"
    do close with var output_handle

    do wait 1000000 seconds
done
