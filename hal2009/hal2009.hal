#
# This file is part of FreeHAL 2010.
#
# Copyright(c) 2006, 2007, 2008, 2009, 2010 Tobias Schulz and contributors.
# http://freehal.org
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

# TEXT
# ~~~~~~ INTRODUCTION ~~~~~~
# This is the main FreeHAL 2010 source file.
# ~~~~~~ IMPLEMENTATION ~~~~~~
# ~~~~~ HEADER ~~~~~
# Include some files:
# CODE
compile source hal2009-lang-indep.hal
require source hal2009-lang-indep.hal

# TEXT
# A part of speech is represented as a string.
# sym_* is always a hash containing these representations as keys.
# CODE
set new hash sym_noun to { "2" => 1, "n" => 1, "n," => 1, "f,m" => 1, "f,n" => 1, "f,n,m" => 1, "f,m,n" => 1, "m,f" => 1, "m,n" => 1, "m,f,n" => 1, "m,n,f" => 1, "m" => 1, "f" => 1, "n,pl" => 1, "ppron" => 1, }
set new hash sym_prep to { "6" => 1, "prep" => 1, }
set new hash sym_questionword to { "5" => 1, "fw" => 1, "questionword" => 1, }
set new hash sym_verb to { "1" => 1, "verb" => 1, "vt" => 1, "vi" => 1, "v" => 1 }
set new hash sym_inter to { "7" => 1, "inter", }
set new hash sym_adj to { "3" => 1, "adj" => 1, "adv" => 1, }
set new hash sym_pp to { "pron" => 1, }
set new hash sym_unimportant to { "nothing" => 1, }
set new hash sym_linking to { "linking" => 1, }
set new hash sym_art to { "art" => 1, }
set new hash sym_entity to { items of hash sym_adj, items of hash sym_art, items of hash sym_noun }
set new hash sym_keyword to { "ISUNKNOWN" => 1, "ENUMALL" => 1, }

set new hash val_omit to { "a" => 1, "b" => 1, "c" => 1, "d" => 1, "e" => 1, "f" => 1, "g" => 1, "h" => 1, }

# TEXT
# The constant variables TYPE and GENUS are defined as 0 and 1. They are used as array indices.
# CODE
set new const TYPE to 0
set new const GENUS to 1

# TEXT
# If a message is printed, "ident" contains the amount of spaces at the left
# CODE
set new var ident to ""

# TEXT
# Cache, only used when high memory support used
# CODE
set new global array cache_memory to [ ]

# TEXT
# An example: If the german word Baecker is not found, maybe Baeckerin is there
# CODE
 #, "es", "er", "en", "em"
set new array standard_suffixes to [ "", "in", "e", "s" ]
set new global var be_slow__last_time to time without arguments

define action be_slow without arguments do
    if exists: "SLOW", end test do
        set new var be_slow__new_time to time without arguments
        set new var diff to var be_slow__new_time - var be_slow__last_time
        if var diff > 3 do
            set var diff to 3
        done
        if var diff >= 0.5 do
            print STDERR "Micro-managing freehal process: "
            print STDERR var diff
            print STDERR " cpu seconds were used."
            print STDERR new line
            
            set new var timeout to 25 * var diff
            set new var last_time to time without arguments
            while var timeout > 0 do
                do wait var timeout seconds
                
                set new var new_time to time without arguments
                set var timeout to var timeout - var new_time + var last_time
                set var last_time to var new_time
            done
            
            set var be_slow__last_time to time without arguments
        done
    done
done

# TEXT
# ~~~~~ CONFIG CODE ~~~~~
# CODE

define action check_config with var name, var default, var lang, var path do
    set new var file_name to "config.txt"

    set new var config_path to var path concat "/" concat var file_name
    set new var input_handle to handle for file name var config_path, read
    if not var input_handle do
        set var config_path to var path concat "/../" concat var file_name
        set var input_handle to handle for file name var config_path, read
    done
    if not var input_handle do
        set var config_path to var file_name
        set var input_handle to handle for file name var config_path, read
    done
    if not var input_handle do
        set var config_path to "../" concat var file_name
        set var input_handle to handle for file name var config_path, read
    done
    
    if var input_handle do
        for each new var line from var input_handle do
            if var line matches /var name\s*?<[=]>\s*?(.*?)\s*?$/ do
                set new var value to $0
                do regex using var value: /^\s+?/, "", :global
                do regex using var value: /\s+?$/, "", :global
                print var config_path concat ": " concat var name concat " = " concat var value
                print new line
                do return with var value
            done
        done
    done
    
    set new var output_handle to handle for file name var config_path, append
    if not var output_handle do
        set var config_path to var path concat "/" concat var file_name
        set var output_handle to handle for file name var config_path, append
    done
    if var output_handle do
        print into var output_handle data var name concat " = " concat var default concat new line
        do close with var output_handle
    done
    
    print var config_path concat ": " concat var name concat " = ???, default = " concat var default
    print new line
    do return with var default
done

# TEXT
# ~~~~~ SCORE CODE ~~~~~
# CODE

define action check_score_command with var possible_score, var lang, var path do
    if var possible_score matches /^\/SCORE\s+?(<[-+0-9]>+)\s+?(.*?)$/ do
        set new var plusminus to $0
        set new var output to $1
        
        set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/input.history', read
        set new var last_input to ''
        for each new var line from var input_handle do
            set var last_input to var line
        done
        set new array words to split with " ", var last_input
        
        do return with [ $0, array words, var output ]
    done
    do return with 0
done

define action check_score with var possible_score do
    set new var output_num to 0
    if var possible_score matches /^(<[0-9]>+)\s?/ do
        set var output_num to $0
        print "( Output number: " concat var output_num concat " ) "
        do regex using var possible_score: /^<[0-9]>+\s?/, "", :global
    done

    if not var possible_score matches /[a-zA-Z]/ do
        if var possible_score matches /[+]/ do
            do return with [ var output_num, 5 ]
        done
        if var possible_score matches /[+][+]/ do
            do return with [ var output_num, 20 ]
        done
        if var possible_score matches /[+][+][+]/ do
            do return with [ var output_num, 50 ]
        done
        if var possible_score matches /[+][+][+][+]/ do
            do return with [ var output_num, 800 ]
        done
        if var possible_score matches '-' do
            do return with [ var output_num, -5 ]
        done
        if var possible_score matches '--' do
            do return with [ var output_num, -20 ]
        done
        if var possible_score matches '---' do
            do return with [ var output_num, -50 ]
        done
        if var possible_score matches '----' do
            do return with [ var output_num, -800 ]
        done
    done

    do return with [ var output_num, undef ]
done

define action set_score with array words, var sentence, var score, var lang, var path do
    set new var output_file_name to var path concat '/lang_' concat var lang concat '/index_of_combination.cfg'
    set new var output_handle to handle for file name var output_file_name, append

    for each new var word in array words do
        print into var output_handle data '[' concat var word concat ']'
        print into var output_handle data new line
        print into var output_handle data var sentence
        print into var output_handle data ": "
        print into var output_handle data var score
        print into var output_handle data new line
    done

    do close with var output_handle
done

define action set_score_for_last with var score, var lang, var path do
    set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/output.history', read
    set new var last_output to ''
    for each new var line from var input_handle do
        set var last_output to var line
    done
    
    set var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/input.history', read
    set new var last_input to ''
    for each new var line from var input_handle do
        set var last_input to var line
    done

    set new array words to split with " ", var last_input
    
    if var last_output do
        do set_score with array words, var last_output, var score, var lang, var path
    done
done

define action set_score_for_num with var score, var num, var lang, var path do
    print "Search output no "
    print var num
    print new line

    set new var score_answer to get_score_answer without arguments

    set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/output.history', read
    set new array last_output to an empty array
    for each new var line from var input_handle do
        if var line matches /var score_answer/ do
            go to next
        done

        push into array last_output, var line
        if items of array last_output > var num - 1 do
            do shift with items of array last_output
        done
    done
    
    set var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/input.history', read
    set new var last_input to ''
    for each new var line from var input_handle do
        set var last_input to var line
    done

    set new array words to split with " ", var last_input
    
    if var last_output do
        do set_score with array words, from array last_output first item, var score, var lang, var path
    done
done

set new hash content_of_score_file to an empty hash

define action get_score with array words, var sentence, var lang, var path do
    set new array maybe_is_score to check_score with var sentence
    if array maybe_is_score and from array maybe_is_score item [1] do
        return 0
    done

    if is an empty hash content_of_score_file do
        set new var input_file_name to var path concat '/lang_' concat var lang concat '/index_of_combination.cfg'
        set new var input_handle to handle for file name var input_file_name, read
        set new var last_word to ""
        for each new var line from var input_handle do
            set var line to lc with var line
            do regex using var line: /<[?]>|<[!.,+]>|<[\s\r\n]>+?/, "", :global
            if var line matches /[\[]/ do
                set var last_word to var line
            done
            else do
                push into that array: from hash content_of_score_file item { var last_word } (end array), var line
            done
        done
        do close with var input_handle
    done

    set var sentence to lc with var sentence
    do regex using var sentence: /<[?]>|<[!.,\-]>|\s/, "", :global
    do regex using var sentence: /(<[)(+-]>)/, "\\$0", :global
    set new var sum to 1
    set new var num_words to items of array words
    set new var index_of_this_word to -1
    for each new var word in array words do

        set var index_of_this_word to var index_of_this_word + 1

        if from hash content_of_score_file item { "[var word]" } do
            set new var line_no to -1
            set new var size to size of that array: from hash content_of_score_file item { "[var word]" } (end array)
            do regex using var word: /<[?]>|<[!.,\-]>/, "", :global

            while var line_no < var size do
                set var line_no to var line_no + 1

                set new var line_2 to from hash content_of_score_file item { "[var word]" } item [ var line_no ]

                if var line_2 matches "" do
                    go to next
                done
                if var line_2 matches /var sentence/ do
                    set new array parts to split with ":", var line_2
                    set new var score_here to from array parts second item
                    do regex using var score_here: /\s/, "", :global
#                    print "score: " concat var score_here concat new line

                    if (0+var score_here) > -1 do
                        if var score_here > 5000 do
                            go to last
                        done

                        set var sum to var sum + (100/(var index_of_this_word+1))*var score_here*(10/var sum) + 1
                    done
                done
            done
        done
    done

    if var num_words < 1 do
        set var num_words to 1
    done


    if var sentence matches /\(<[+]><[+]><[+]>\)/ do
        set var sum to var sum + 100 * var num_words
    done
    if var sentence matches /\(<[+]><[+]>\)/ do
        set var sum to var sum + 70 * var num_words
    done
    if var sentence matches /\(<[+]>\)/ do
        set var sum to var sum + 40 * var num_words
    done
    if var sentence matches /\(<[-]><[-]><[-]>\)/ do
        set var sum to var sum - 100 * var num_words
    done
    if var sentence matches /\(<[-]><[-]>\)/ do
        set var sum to var sum - 70 * var num_words
    done
    if var sentence matches /\(<[-]>\)/ do
        set var sum to var sum - 40 * var num_words
    done
    
    set var sum to (var sum + 1) / var num_words 
    if var sum < 1 do
        set var sum to 1
    done
    
    do return with var sum
done

# TEXT
# ~~~~~ TAGGER CODE ~~~~~
# CODE

define action get_tag_part_of_speech with var word, var lang do
    if (not var word) or (var word matches /^\s*?$/) or exists: "_no_user_ask", end test do
        set new array return_array to an empty array
        push into array return_array, "q"
        push into array return_array, "q"
        do return with array return_array
    done
    
    set new var output_file_name to '_output__pos'
    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data var word
    do close with var output_handle

    set new var timeout to 120
    while var timeout > 0 do
        set new var input_file_name to '_input__pos'
        set new var input_handle to handle for file name var input_file_name, read

        if var input_handle do
            set new var response to the next line from var input_handle
            if var response do
                print "Got input: '" concat var response concat "'"
                print new line
                do close with var input_handle
                do wait 1 seconds
                do unlink with '_input__pos'
                
                set new array return_array to split with /<[,:]>/, var response
                do return with array return_array
            done
        done
        do wait 1 seconds
        set var timeout to var timeout - 1
    done
    
    set new array return_array to an empty array
    push into array return_array, "q"
    push into array return_array, "q"
    do return with array return_array
done

set new global hash content_of_memory_file to an empty hash

# TEXT
# Save the word "name_of_entry" in the memory file.
# The memory file contains the parts of speech.
# CODE
define action memory_set_by_name with var file_name, var name_of_entry, array tags, var lang, var path do
    set new var write_protocol to 1
    if var file_name matches /NO PROTOCOL / do
        set var write_protocol to 0
        do regex using var file_name: /NO PROTOCOL /, "", :global:i
    done

    set new array check_tags to memory_get_by_name using var file_name, var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in ?-file: " concat var name_of_entry
        print new line
        do return without arguments
    done
    set new array check_tags to memory_get_by_name using "word_types.memory", var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in memory file: " concat var name_of_entry
        print new line
        do return without arguments
    done
    set new array check_tags to memory_get_by_name using "word_types.self-taggered", var name_of_entry, var lang, var path
    if not is an empty array check_tags do
        print "Already in self-taggered file: " concat var name_of_entry
        print new line
        do return without arguments
    done
    #set new array check_tags to memory_get_by_name using "protocol.memory", var name_of_entry, var lang, var path
    #if not is an empty array check_tags do
    #    print "Already in protocol file: " concat var name_of_entry
    #    print new line
    #    do return without arguments
    #done
    #set new array check_tags to memory_get_by_name using "word_types.brain", var name_of_entry, var lang, var path
    #if not is an empty array check_tags do
    #    print "Already in brain file: " concat var name_of_entry
    #    print new line
    #    do return without arguments
    #done

    if var name_of_entry matches /br[0-9]+?$/ do
        print "Illegal word: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /[0-9]+?/ do
        print "Illegal word: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /<[}{]>/ do
        print "Illegal word: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /__$/ do
        print "Illegal word: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /_/ do
        print "Do not save \"_\" words: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /\s/ do
        print "Do not save words with spaces: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if var name_of_entry matches /[-]$/ do
        print "Do not save words with minus: " concat var name_of_entry
        print new line
        do return without arguments
    done
    if from array tags first item is 1 and var name_of_entry matches /zu/ do
        print "Do not save verbs with 'zu': " concat var name_of_entry
        print new line
        do return without arguments
    done
    if not var name_of_entry do
        print "Do not save empty words: " concat var name_of_entry
        print new line
        do return without arguments
    done

    do be_slow without arguments
    print "Setting   " concat var name_of_entry concat "    \tin file " concat var file_name concat "\t to " concat from array tags first item
    print new line
    
    if not from array tags first item do
        set from array tags first item to 'q'
    done
    if not from array tags second item do
        set from array tags second item to 'q'
    done

    if from array tags first item is 1 do
        set from array tags first item to 'v'
    done
    if from array tags first item is 2 do
        set from array tags first item to 'n'
    done
    if from array tags first item is 3 do
        set from array tags first item to 'adj'
    done
    if from array tags first item is 5 do
        set from array tags first item to 'questionword'
    done
    if from array tags first item is 6 do
        set from array tags first item to 'prep'
    done
    if from array tags first item is 7 do
        set from array tags first item to 'inter'
    done
    
    if from array tags first item matches /q/ do
        print "POS matches 'q', exiting memory_set_by_name..."
        print new line
        do return without arguments
    done

    set new var output_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, append
    print into var output_handle data var name_of_entry concat ":"
    print into var output_handle data new line
    if not from array tags second item matches /q/ do
        print into var output_handle data "  genus: " concat from array tags second item concat new line
        do push into that array: from global hash content_of_memory_file item { var file_name } item { var name_of_entry concat ":" } end-items-of, "  genus: " concat from array tags second item
    done
    print into var output_handle data "  type: " concat from array tags first item concat new line
    do push into that array: from global hash content_of_memory_file item { var file_name } item { var name_of_entry concat ":" } end-items-of, "  type: " concat from array tags first item
    
    if not var file_name matches /brain/ do
        if not from array tags first item matches /q/ do
            #print into var output_handle data "  count: 1" concat new line
        done
    done

    do close with var output_handle

    if var write_protocol do
        # TEXT
        # Protocol file:
        # CODE
        set new var output_handle to handle for file name var path concat "/lang_" concat var lang concat "/protocol.memory", append
        print into var output_handle data var name_of_entry concat ":"
        print into var output_handle data new line
        if not from array tags second item matches /q/ do
            print into var output_handle data "  genus: " concat from array tags second item concat new line
            do push into that array: from global hash content_of_memory_file item { "protocol.memory" } item { var name_of_entry concat ":" } end-items-of, "  genus: " concat from array tags second item
        done
        print into var output_handle data "  type: " concat from array tags first item concat new line
        do push into that array: from global hash content_of_memory_file item { "protocol.memory" } item { var name_of_entry concat ":" } end-items-of, "  type: " concat from array tags first item
    done

    do close with var output_handle
done

define action memory_build_cache with var file_name, var lang, var path do
    if not from global hash content_of_memory_file item { var file_name } do
        
        # read file into cache if there is no cache yet
        set new var input_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, read
        
        do be_slow without arguments
        print "Caching file " concat var file_name concat "..."
        print new line
        
        set new var entry to ""
        set new array lines to an empty array
        set items of array lines to all lines from var input_handle
        for each new var line in array lines is rw do
            # no line ending
            do regex using var line: /<[\r\n]>/, "", :global
            
            if var line matches /^ / do
                do push into that array: from global hash content_of_memory_file item { var file_name } item { var entry } end-items-of, var line
            done
            else do
                set var entry to var line
            done
        done
    done
done

# TEXT
# Search in the memory file for the word "name_of_entry".
# The memory file contains the parts of speech.
# CODE
define action memory_get_by_name with var file_name, var name_of_entry, var lang, var path do
    if exists: "SLOW", end test do
        print "Running in SLOW mode... "
        print new line
    done
    
    if not var name_of_entry or var name_of_entry matches /^\s*?$/ do
        do return using an empty array
    done
    
    do memory_build_cache with var file_name, var lang, var path
    
    do be_slow without arguments
    print "Searching   " concat var name_of_entry concat "    \tin file " concat var file_name
    print new line
    
    set new array contents to an empty array
    set new var end_of_entry_line to ':'
    do regex using var name_of_entry: /[\[\]]/, "", :global:i
    
    set new var matched_id to ""
    
    if (not array contents) or is an empty array contents do
        set array contents to from global hash content_of_memory_file item { var file_name } item { var name_of_entry concat var end_of_entry_line }
        set var matched_id to var name_of_entry concat var end_of_entry_line
    done
    do regex using var name_of_entry: /[\(\)]/, "", :global:i
    if (not array contents) or is an empty array contents do
        set array contents to from global hash content_of_memory_file item { var file_name } item { var name_of_entry concat var end_of_entry_line }
        set var matched_id to var name_of_entry concat var end_of_entry_line
    done
    for each new var suffix in array standard_suffixes do
        if (not array contents) or is an empty array contents do
            set array contents to from global hash content_of_memory_file item { var file_name } item { var name_of_entry concat var suffix concat var end_of_entry_line }
            set var matched_id to var name_of_entry concat var suffix concat var end_of_entry_line
        done
    done
    
    
    set new var type to 'q'
    set new var genus to 'q'
    set new var count to 0
    
    do be_slow without arguments
    
    set new var i to 0
    # go through the lines
    while array contents and var i < items of array contents do
        set new var line to from array contents item [ var i ]
        do regex using var line: /\s*?<[var end_of_entry_line]>/, "var end_of_entry_line", :global
        
        if var line matches /^\s*?(\S*?)<[var end_of_entry_line]>\s*?(\S+)/ do
            set new var t to $1
            if $0 matches /type/ do
                set var type to var t
            done
            else if $0 matches /genus/ do
                set var genus to var t
            done
            else if $0 matches /count/ do
                set var count to var t
            done
            do be_slow without arguments
        done
        else if var line matches /^\s*?(\S*?)<[var end_of_entry_line\s]>*?(\S+)/ do
            set new var t to $1
            if $0 matches /type/ do
                set var type to var t
            done
            else if $0 matches /genus/ do
                set var genus to var t
            done
            else if $0 matches /count/ do
                set var count to var t
            done
            do be_slow without arguments
        done
        else do
            go to last
        done
        
        set var i to var i + 1
    done
    if (not var type matches "q") or (not var genus matches "q") do
        print "Found do      " concat var name_of_entry concat "    \tin file " concat var file_name
        print new line
        
        print "type do  " concat var type
        print new line
        print "genus do " concat var genus
        print new line
        print "count do " concat var count
        print new line
        
        do memory_plus with var file_name, var matched_id, var count + 1, var lang, var path
        
        do return with [ var type, var genus ]
    done

    print "Not found do  " concat var name_of_entry concat "    \tin file " concat var file_name
    print new line
    do return using an empty array
done

# TEXT
# Ensure the memory limit
# CODE
define action memory_limit with var file_name, var lang, var path do
    if var file_name matches /brain/ do
        do return without arguments
    done
    
    set new var limit to 1000
    
    print "There is a memory limit of " concat var limit concat ", file " concat var file_name
    print new line
    
    # TEXT
    # read file
    # CODE
    set new var input_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, read
    set new var average_count to 0
    set new var count_items to 1
    set new var entry to ""
    set new array lines to an empty array
    set new array names to an empty array
    set new hash file_to_limit to an empty hash
    set new hash count_values to an empty hash
    set items of array lines to all lines from var input_handle
    do close with var input_handle
    for each new var line in array lines is rw do
        # no line ending
        do regex using var line: /<[\r\n]>/, "", :global
        
        if var line matches /type.?.?q/ do
            go to next
        done
        else if var line matches /^ / do
            do push into that array: from hash file_to_limit item { var entry } end-items-of, var line
            
            if var line matches /count..(.*)/ do
                set var average_count to var average_count + $0
                set var count_items to var count_items + 1
                
                do push into that array: from hash count_values item { var entry } end-items-of, $0
            done
        done
        else do
            set var entry to var line
            do push into array names, var entry
        done
    done
    
    set var average_count to var average_count / var count_items
    
    print "Average is " concat var average_count
    print new line
    
    # TEXT
    # ensure that the limit is not exceeded
    # CODE
    
    set new var count_over_avg to 0
    set new var count_under_avg to 0
    set new array entries_over_avg to an empty array
    set new array entries_under_avg to an empty array
    for each new var entry_name in array names do
        if from hash count_values item { var entry } >= var average_count do
            set var count_over_avg to var count_over_avg + 1
            push into array entries_over_avg, var entry_name
        done
        if from hash count_values item { var entry } < var average_count do
            set var count_under_avg to var count_under_avg + 1
            push into array entries_under_avg, var entry_name
        done
    done
    
    print "Over  average: " concat var count_over_avg concat new line
    print "Under average: " concat var count_under_avg concat new line
    print "All          : " concat items of array names concat new line
    
    set items of array entries_over_avg to sort with items of array entries_over_avg
    set items of array entries_under_avg to sort with items of array entries_under_avg
    set items of array entries_over_avg to reverse with items of array entries_over_avg
    #set items of array entries_under_avg to reverse with items of array entries_under_avg
    
    if var count_over_avg > var limit do
        set new var count_to_remove to var count_over_avg - var limit
        print "Remove over  average: " concat var count_to_remove concat new line
        while var count_to_remove > 0 do
            do shift with items of array entries_over_avg
        
            set var count_to_remove to var count_to_remove - 1
        done
    done
    if var count_under_avg > var limit do
        set new var count_to_remove to var count_under_avg - var limit
        print "Remove under average: " concat var count_to_remove concat new line
        while var count_to_remove > 0 do
            do shift with items of array entries_under_avg
        
            set var count_to_remove to var count_to_remove - 1
        done
    done
    
    set items of array entries_over_avg to reverse with items of array entries_over_avg
    #set items of array entries_under_avg to reverse with items of array entries_under_avg
    
    # TEXT
    # save everything
    # CODE
    set new var output_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, write
    for each new var entry in array entries_over_avg is rw do
        print into var output_handle data var entry
        print into var output_handle data new line
        
        set new array lines to from hash file_to_limit item { var entry }
        
        if array lines do
            for each new var line in array lines is rw do
                print into var output_handle data var line
                print into var output_handle data new line
            done
        done
    done
    for each new var entry in array entries_under_avg is rw do
        print into var output_handle data var entry
        print into var output_handle data new line
        
        set new array lines to from hash file_to_limit item { var entry }
        
        if array lines do
            for each new var line in array lines is rw do
                print into var output_handle data var line
                print into var output_handle data new line
            done
        done
    done
    do close with var output_handle
done

# TEXT
# Update the "count" value
# CODE
define action memory_plus with var file_name, var matched_id, var count, var lang, var path do
    if var file_name matches /brain/ do
        do return without arguments
    done
    
    print "Updating count field in " concat var file_name concat "..."
    print new line
    set new var input_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, read
    do be_slow without arguments
    print "Reading file " concat var file_name concat "..."
    print new line
    
    set new var entry to ""
    set new array lines to an empty array
    set items of array lines to all lines from var input_handle
    set new flag found to 0
    for each new var line in array lines is rw do
        if var line matches /var matched_id/ do
            set var entry to var line
            go to next
        done
        
        if var entry do
            if var line matches /^ / do
                if var line matches /count/ do
                    set var line to "  count: " concat var count concat new line
                    set flag found to 1
                    go to last
                done
            done
            else do
                go to last
            done
        done
    done
    
    if not flag found do
        for each new var line in array lines is rw do
            if var line matches /var matched_id/ do
                set var entry to var line
                set var line to var line concat "  count: " concat var count concat new line
                go to last
            done
        done
    done
    
    do close with var input_handle
    set new var output_handle to handle for file name var path concat "/lang_" concat var lang concat "/" concat var file_name, write
    for each new var line in array lines is rw do
        print into var output_handle data var line
    done
    do close with var output_handle
done

# TEXT
# For BOINC
# CODE
define action boinc_guess_part_of_speech with var word, var lang, var path do
    if var word matches /[A-Z]/ do
        do return with "n"
    done
    else do
        do return with "adj"
    done
done

# TEXT
# Time management
# CODE

define action make_yearday_from_monthday with var mday, var mon do
    set new var yday to var mday
    set var mon to var mon - 1
    while var mon >= 0 do
        if var mon is 0 do
            set var yday to var yday + 31
        done
        if var mon is 1 do
            set var yday to var yday + 28
        done
        if var mon is 2 do
            set var yday to var yday + 31
        done
        if var mon is 3 do
            set var yday to var yday + 30
        done
        if var mon is 4 do
            set var yday to var yday + 31
        done
        if var mon is 5 do
            set var yday to var yday + 30
        done
        if var mon is 6 do
            set var yday to var yday + 31
        done
        if var mon is 7 do
            set var yday to var yday + 31
        done
        if var mon is 8 do
            set var yday to var yday + 30
        done
        if var mon is 9 do
            set var yday to var yday + 31
        done
        if var mon is 10 do
            set var yday to var yday + 30
        done
        if var mon is 11 do
            set var yday to var yday + 31
        done
        
        set var mon to var mon - 1
    done
    
    do return with var yday
done

define action timelocal with var sec, var min, var hour, var mday, var mon, var year, var wday, var yday, var isdst do
    if var year > 1000 do
        set var year to var year - 1900
    done
    set var year to var year - 70

    set new var seconds to 0
    
    set var seconds to var seconds + var sec
    set var seconds to var seconds + var min        * 60
    set var seconds to var seconds + var hour       * 60*60
    set var seconds to var seconds + var yday       * 60*60*24
    set var seconds to var seconds + var year       * 60*60*24*365
    
    # leap years
    set new var full_year to var year + 1970
    while var full_year >= 1970 do
        if (var full_year % 4 == 0 and var full_year % 100 != 0) or (var full_year % 400 == 0) do
            set var seconds to var seconds + 60*60*24
        done
    
        set var full_year to var full_year - 1
    done
    
    if not var isdst do
        set var seconds to var seconds - 60*60
    done
    
    do return with var seconds
done

define action to_unixtime with var sentence, var lang, var path do
    set new array _builtin_time_relations_names to global array builtin_time_relations_names
    set new hash _builtin_time_relations to global hash builtin_time_relations
    
    print "to_unixtime called."
    print new line
    
    print "First:               "
    print var sentence
    print new line
    
    set var sentence to time_pre_transformations with var sentence, var lang, var path
    print "Pre-Transformations: "
    print var sentence
    print new line
    
    set new var i_begin to 0
    set new var i_end to 0
    set new var c_time to time without arguments
    set new var replacement to ""
    
    for each new var rel in array _builtin_time_relations_names do
        if lc(var sentence) matches /(^|\s)var rel(\s|$)/ do
            set new array date_time_array to items-returning localtime with var c_time
            set new var sec to from array date_time_array item [ 0 ]
            set new var min to from array date_time_array item [ 1 ]
            set new var hour to from array date_time_array item [ 2 ]
            set new var mday to from array date_time_array item [ 3 ]
            set new var mon to from array date_time_array item [ 4 ]
            set new var year to from array date_time_array item [ 5 ]
            set new var wday to from array date_time_array item [ 6 ]
            set new var yday to from array date_time_array item [ 7 ]
            set new var isdst to from array date_time_array item [ 8 ]
            
            print "Time, now:       "
            print var c_time
            print " = "
            print var sec concat ", " concat var min concat ", " concat var hour concat ", " concat var mday concat ", " concat var mon concat ", " concat var year concat ", " concat var wday concat ", " concat var yday concat ", " concat var isdst
            print new line
            
            set new var i_range to from hash _builtin_time_relations item { var rel } first item
            set new var i_plusminus to from hash _builtin_time_relations item { var rel } second item
            
            if lc(var sentence) matches /(^|\s)(\d+?)<[*]>\svar rel(\s|$)/ do
                set var i_plusminus to var i_plusminus * $1
            done
            
            print "Time, interval:  "
            print var i_range
            print " sec"
            print new line
            if var i_range is 24*60*60 do
                set var sec to 0
                set var min to 0
                set var hour to 0
            done
            if var i_range is 7*24*60*60 do
                if var wday is 0 do
                    set var wday to 7
                done
                set new var daydiff to var wday - 1
                set var wday to 1
                set var yday to var yday - var daydiff
                set var mday to var mday - var daydiff
                if var mday < 1 do
                    set var mon to var mon - 1
                    set var mday to 31 + var mday
                done
                set var sec to 0
                set var min to 0
                set var hour to 0
            done
            
            
            set var i_begin to timelocal with var sec, var min, var hour, var mday, var mon, var year, var wday, var yday, var isdst
            set var i_begin to var i_begin + var i_plusminus * var i_range
            print "Time, begin:     "
            print var i_begin
            print " = "
            print var sec concat ", " concat var min concat ", " concat var hour concat ", " concat var mday concat ", " concat var mon concat ", " concat var year concat ", " concat var wday concat ", " concat var yday concat ", " concat var isdst
            print new line
            
            set var i_end to var i_begin + var i_range
            print "Time, end:       "
            print var i_end
            print " = ..."
            print new line
            
            do regex using var sentence: /(^|\s)(\d+?)<[*]>\s(var rel)(\s|$)/, "$0$2$3", :i
            if lc(var sentence) matches /(von|ab|seit|since)(^|\s)var rel(\s|$)/ do
                set var replacement to var replacement concat " time_from-" concat var i_begin
                do regex using var sentence: /(von|ab|seit|since)(^|\s)var rel(\s|$)/, "$2", :global:i
            done
            else if lc(var sentence) matches /(bis|till|until)(^|\s)var rel(\s|$)/ do
                set var replacement to var replacement concat " time_to-" concat var i_end
                do regex using var sentence: /(bis|till|until)(^|\s)var rel(\s|$)/, "$2", :global:i
            done
            else do
                set var replacement to var replacement concat " time_from-" concat var i_begin concat " " concat "time_to-" concat var i_end
                do regex using var sentence: /(^|\s)var rel(\s|$)/, "$1", :global:i
            done
            
            set var i_begin to 0
            set var i_end to 0
        done
    done
    
    while 1 do
        if lc(var sentence) matches /(am|vom|bis)<[-]>(\d+?)\.(\d+?)\.(\d+?) / do
            set new var prep to $0
            
            set new var sec to 0
            set new var min to 0
            set new var hour to 0
            set new var mday to $1 - 1
            set new var mon to $2 - 1
            set new var year to $3
            set new var wday to 0
            set new var yday to make_yearday_from_monthday with var mday, var mon
            set new var isdst to 0
            
            print "Day of month:    "
            print var mday
            print new line
            print "Month:           "
            print var mon
            print new line
            print "Year:            "
            print var year
            print new line
            print "Day of year:     "
            print var yday
            print new line
            
            if var prep matches "am" do
                set var i_begin to timelocal with var sec, var min, var hour, var mday, var mon, var year, var wday, var yday, var isdst
                set var yday to var yday + 1
                set var i_end to timelocal with var sec, var min, var hour, var mday, var mon, var year, var wday, var yday, var isdst
            done
            if var prep matches "vom" do
                set var i_begin to timelocal with var sec, var min, var hour, var mday, var mon, var year, var wday, var yday, var isdst
            done
            if var prep matches "bis" do
                set var yday to var yday + 1
                set var i_end to timelocal with var sec, var min, var hour, var mday, var mon, var year, var wday, var yday, var isdst
            done
            print var sentence
            print new line
            do regex using var sentence: /(am|vom|bis)<[-]>(\d+?)\.(\d+?)\.(\d+?) /, "", :i
        done
        else do
            go to last
        done
    done
    
    if var i_begin do
        set var replacement to var replacement concat " time_from-" concat var i_begin
        set var i_begin to 0
    done
    if var i_end do
        set var replacement to var replacement concat " time_to-" concat var i_end
        set var i_end to 0
    done
    
    if var replacement do
        do regex using var sentence: /(<[?!.,]>|$)/, "var replacement $0", :i
    done
    
    print "to_unixtime finished."
    print new line
    
    do return with var sentence
done

# TEXT
# Find out the part of speech
# CODE
define action compute_tags with var word, var lang, var path do
    do regex using var word: /<[\x80-\xFF]>/, "", :global
    do regex using var word: /<[)(]>/, "", :global
    
    set new var is_tagger_on to check_config with "tagger", 1, var lang, var path

    set new array tags to an empty array
    
    set new array main_files to an empty array
    push into array main_files, "word_types.memory"
    push into array main_files, "word_types.self-taggered"
    push into array main_files, "word_types.brain"

    for each new var main_file in array main_files do
    
        if is an empty array tags do
            if lc(var word) matches /time_/ do
                set from array tags first item to "adj"
            done
            
            if ( not is an empty array tags ) and ( not from array tags first item matches /n/ ) do
                go to last
            done
        done
    
        # TEXT
        # Is it built in into FreeHAL?
        # CODE
        if is an empty array tags do
            set array tags to memory_get_by_name using var main_file, var word, var lang, var path
            set from array tags first item to from global hash builtin_part_of_speech item { var word }
            
            if not from array tags first item do
                set array tags to an empty array
                print "NOT built in: " concat var word
                print new line
            done
            else do
                print "built in: " concat from array tags first item
                print new line
                
                # TEXT
                # If no noun, we need no genus, so skip the rest
                # CODE
                if not from array tags first item matches /n/ do
                    go to last
                done
            done
        done
        if is an empty array tags do
            set array tags to memory_get_by_name using var main_file, ucfirst(var word), var lang, var path
            set from array tags first item to from global hash builtin_part_of_speech item { ucfirst(var word) }
            
            if not from array tags first item do
                set array tags to an empty array
                print "NOT built in: " concat var word
                print new line
            done
            else do
                print "built in: " concat from array tags first item
                print new line
                
                # TEXT
                # If no noun, we need no genus, so skip the rest
                # CODE
                if not from array tags first item matches /n/ do
                    go to last
                done
            done
        done
        if is an empty array tags do
            set array tags to memory_get_by_name using var main_file, lc(var word), var lang, var path
            set from array tags first item to from global hash builtin_part_of_speech item { lc(var word) }
            
            if not from array tags first item do
                set array tags to an empty array
                print "NOT built in: " concat var word
                print new line
            done
            else do
                print "built in: " concat from array tags first item
                print new line
                
                # TEXT
                # If no noun, we need no genus, so skip the rest
                # CODE
                if not from array tags first item matches /n/ do
                    go to last
                done
            done
        done
        
        if is an empty array tags do
            if lc(var word) matches /<[{]><[{]><[{]>(.*?)<[}]><[}]><[}]>/ do
                print "predefined: " concat $0
                print new line
                set from array tags first item to $0
                go to last
            done
            if lc(var word) matches /no-question/ do
                set from array tags first item to "qq"
            done
            if lc(var word) matches /_(wie|wer|was|wo|wann|warum|wieso|weshalb)_/ do
                set from array tags first item to "adj"
            done
            if lc(var word) matches /^in_/ do
                set from array tags first item to "adj"
            done
            if lc(var word) matches /^zu<[rm]>_/ do
                set from array tags first item to "adj"
            done
            if lc(var word) matches /tion(|en)?$/ do
                set from array tags first item to "n"
            done
            if lc(var word) matches /^jahr/ do
                set from array tags first item to "n"
            done
            if var word matches /<[0123456789]>/ do
                set from array tags first item to "adj"
            done
            if var word matches /<[_]>/ do
                set from array tags first item to "n"
            done
            if var word matches /<[-]>$/ do
                set from array tags first item to "adj"
            done
            if var word matches /\s/ do
                set from array tags first item to "n"
            done
            if lc(var word) matches var word and var lang matches "de" do
                if lc(var word) matches /ste<[nmrs]>?$/ do
                    set from array tags first item to "adj"
                done
                if var word matches /ist$/ do
                    set from array tags first item to "n"
                done
                if var word matches /(los|voll|frei|ig)(e|es|er|en|em)?$/ do
                    set from array tags first item to "adj"
                done
                if var word matches /ere(n|r|m|s)$/ do
                    set from array tags first item to "adj"
                done
                if var word matches /st$/ do
                    set from array tags first item to "vi"
                done
                if var word matches /iert$/ do
                    set from array tags first item to "vi"
                done
                if var word matches /ieren$/ do
                    set from array tags first item to "vi"
                done
                if var word matches /iere$/ do
                    set from array tags first item to "vi"
                done
                if var word matches /ierst$/ do
                    set from array tags first item to "vi"
                done
                
                # write it
                if from array tags first item do
                    do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
                done
            done
            if var word matches /system$/ do
                set from array tags first item to "n"
            done
            else if ucfirst(var word) matches var word and var lang matches "de" do
                if var word matches /est$/ do
                    set from array tags first item to "vi"
                done
            done
            else if var word matches /<[ABCDEFGHIJKLMNOPQRSTUVWXYZ]>/ do
                set from array tags first item to "n"
            done
            
            if ( not is an empty array tags ) and ( not from array tags first item matches /n/ ) do
                go to last
            done
        done
        
        # TEXT
        # Look if the lower case variant of the word is a verb in the memory file.
        # CODE
        if is an empty array tags and lc(var word) matches var word do
            set array tags to memory_get_by_name using var main_file, ucfirst(var word), var lang, var path
            
            if not from hash sym_noun item { from array tags first item } do
                set array tags to an empty array
            done
        done

        # TEXT
        # Look if the lower case variant of the word is a verb in the memory file.
        # CODE
        if is an empty array tags do
            set array tags to memory_get_by_name using var main_file, lc(var word), var lang, var path
            
            if not from hash sym_verb item { from array tags first item } do
                set array tags to an empty array
            done
        done

        # TEXT
        # Look if the lower case variant of the word is a preposition in the memory file.
        # CODE
        if is an empty array tags do
            set array tags to memory_get_by_name using var main_file, lc(var word), var lang, var path
            
            if not from hash sym_prep item { from array tags first item } do
                set array tags to an empty array
            done
        done
        
        # TEXT
        # Look in the memory file.
        # CODE
        if is an empty array tags do
            set array tags to memory_get_by_name using var main_file, var word, var lang, var path
        done
        
        if not is an empty array tags do
            do memory_set_by_name with "NO PROTOCOL word_types.memory", var word, array tags, var lang, var path
            go to last
        done

        # TEXT
        # Look for similar words.
        # CODE
        #if is an empty array tags do
        #    set new var modified_word to var word
        #    for each new var suffix in array standard_suffixes do
        #        do regex using var modified_word: /var suffix$/, "", :global
        #    done
        #    
        #    set array tags to memory_get_by_name using var main_file, var modified_word, var lang, var path
        #done
        do be_slow without arguments
        
        if not is an empty array tags do
            go to last
        done
    done
    
    if is an empty array tags and exists: "SLOW", end test do
        set from array tags first item to boinc_guess_part_of_speech, var word, var lang, var path
        go to last
    done
    
    # TEXT
    # Ask the user.
    # CODE
    if is an empty array tags do
        print "Ask the user: "
        print ( exists: var path concat "/no-tagger.txt", end test )
        print " or "
        print not var is_tagger_on
        print new line
        if exists: var path concat "/no-tagger.txt", end test or not var is_tagger_on do
            if not var word matches /\s/ do
                set array tags to an empty array
                set from array tags to get_tag_part_of_speech using var word, var lang
                do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
            done
        done
    done
    
    # TEXT
    # Guess.
    # CODE
    if is an empty array tags do
        print "Guess: "
        print ( not exists: var path concat "/no-tagger.txt", end test )
        print " or "
        print var is_tagger_on
        print new line
        if ( not exists: var path concat "/no-tagger.txt", end test ) or ( var is_tagger_on ) do
            set array tags to an empty array
            set from array tags first item to guess_part_of_speech using var word, var lang, var path
            
            if not from array tags first item do
                set array tags to an empty array
            done
            else do
                do memory_set_by_name with "word_types.self-taggered", var word, array tags, var lang, var path
            done
        done
    done
    
    # TEXT
    # Ask the user.
    # CODE
    if is an empty array tags do
        set array tags to an empty array
        set from array tags to get_tag_part_of_speech using var word, var lang
        do memory_set_by_name with "word_types.memory", var word, array tags, var lang, var path
    done
    
    do regex using from array tags first item: /,/, "", :global
    
    if var word matches /^_(.*?)_$/ do
        do compute_tags with $0, var lang, var path
    done

    # TEXT
    # Return the result.
    # CODE
    do return using array tags
done

define action guess_part_of_speech with var word, var lang, var path do
    print "Tagger..." concat new line
    print "word: " concat var word concat new line
    print "" concat new line
    
    if from global hash builtin_part_of_speech item { var word } do
        do return with from global hash builtin_part_of_speech item { var word }
    done
    
    do memory_build_cache with "word_types.brain", var lang, var path
    set new hash cache to from global hash content_of_memory_file item { "word_types.brain" }
    set new array cache_keys to an empty array
    set items of array cache_keys to keys with items of hash cache
    
    set new var end_of_entry_line to ':'
    set new hash pos_to_rating to an empty hash
    set new hash pos_to_count_words to an empty hash
    
    set new var word_e_1 to var word
    do regex using var word_e_1: /^.*?(.)$/, "$0", :i
    set new var word_e_2 to var word
    do regex using var word_e_2: /^.*?(..)$/, "$0", :i
    set new var word_e_3 to var word
    do regex using var word_e_3: /^.*?(...)$/, "$0", :i
    set new var word_e_4 to var word
    do regex using var word_e_4: /^.*?(....)$/, "$0", :i
    set new var word_e_5 to var word
    do regex using var word_e_5: /^.*?(.....)$/, "$0", :i
    set new var word_e_6 to var word
    do regex using var word_e_6: /^.*?(......)$/, "$0", :i
    set new var word_b_1 to var word
    do regex using var word_b_1: /^(.).*?$/, "$0", :i
    set new var word_b_2 to var word
    do regex using var word_b_2: /^(..).*?$/, "$0", :i
    set new var word_b_3 to var word
    do regex using var word_b_3: /^(...).*?$/, "$0", :i
    set new var word_b_4 to var word
    do regex using var word_b_4: /^(....).*?$/, "$0", :i
    
    for each new var _key in array cache_keys do
        set new var factor to 1
        if var _key matches /<[A-Z]>/ and not var word matches /<[A-Z]>/ do
            set var factor to 0
        done
        if var word matches /<[A-Z]>/ and not var _key matches /<[A-Z]>/ do
            set var factor to 0
        done
        
        set new var key to var _key
        do regex using var key: /var end_of_entry_line$/, "", :i
        
        if var _key matches /<[A-Z]>/ and lc(var key) matches /^var word$/ and length(var word) > 6 do
            #do return with "n"
        done
        
        
        # get part of speech from hash
        set new var _pos to 'q'
        set new array _lines to from hash cache item { var key concat ":" }
        for each new var _line in array _lines do
            if var _line matches /^\s*?(type)<[var end_of_entry_line]>\s*?(\S+)/ do
                set var _pos to $1
                go to last
            done
        done
        set var _pos to lc with var _pos
        
        if var _key not matches /<[A-Z]>/ and var word not matches /<[A-Z]>/ and var _pos matches /n/ do
            set var factor to 0.05
        done
        
        # set points
        if var key matches /var word_e_6$/ do
            set from hash pos_to_rating item { var _pos } to 12 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        if var key matches /var word_e_5$/ do
            set from hash pos_to_rating item { var _pos } to 10 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        if var key matches /var word_e_4$/ do
            set from hash pos_to_rating item { var _pos } to 8 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        if var key matches /var word_e_3$/ do
            set from hash pos_to_rating item { var _pos } to 12 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        else if var key matches /var word_e_2$/ do
            set from hash pos_to_rating item { var _pos } to 6 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        else if var key matches /var word_e_1$/ do
            set from hash pos_to_rating item { var _pos } to 2 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        if var key matches /^var word_b_4/ do
            set from hash pos_to_rating item { var _pos } to 4 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        if var key matches /^var word_b_3/ do
            set from hash pos_to_rating item { var _pos } to 3 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        if var key matches /^var word_b_2/ do
            set from hash pos_to_rating item { var _pos } to 3 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
        else if var key matches /^var word_b_1/ do
            set from hash pos_to_rating item { var _pos } to 1 * var factor + from hash pos_to_rating item { var _pos }
            set from hash pos_to_count_words item { var _pos } to 1 + from hash pos_to_count_words item { var _pos }
        done
    done
    
    set from hash pos_to_count_words item { "v" } to from hash pos_to_count_words item { "v" } + from hash pos_to_count_words item { "vt" }
    set from hash pos_to_count_words item { "v" } to from hash pos_to_count_words item { "v" } + from hash pos_to_count_words item { "vi" }
    set from hash pos_to_count_words item { "v" } to from hash pos_to_count_words item { "v" } + from hash pos_to_count_words item { "v," }
    set from hash pos_to_count_words item { "v" } to from hash pos_to_count_words item { "v" } + from hash pos_to_count_words item { "ci" }
    set from hash pos_to_count_words item { "adj" } to from hash pos_to_count_words item { "adj" } + from hash pos_to_count_words item { "asj" }
    set from hash pos_to_count_words item { "adj" } to from hash pos_to_count_words item { "adj" } + from hash pos_to_count_words item { "afj" }
    set from hash pos_to_count_words item { "adj" } to from hash pos_to_count_words item { "adj" } + from hash pos_to_count_words item { "adv" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "n," }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "f" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "m" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "n,f" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "n,m" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "n,m,f" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "n,f,m" }
    set from hash pos_to_count_words item { "n" } to from hash pos_to_count_words item { "n" } + from hash pos_to_count_words item { "pron" }
    set from hash pos_to_rating item { "v" } to from hash pos_to_rating item { "v" } + from hash pos_to_rating item { "vt" }
    set from hash pos_to_rating item { "v" } to from hash pos_to_rating item { "v" } + from hash pos_to_rating item { "vi" }
    set from hash pos_to_rating item { "v" } to from hash pos_to_rating item { "v" } + from hash pos_to_rating item { "v," }
    set from hash pos_to_rating item { "v" } to from hash pos_to_rating item { "v" } + from hash pos_to_rating item { "ci" }
    set from hash pos_to_rating item { "adj" } to from hash pos_to_rating item { "adj" } + from hash pos_to_rating item { "asj" }
    set from hash pos_to_rating item { "adj" } to from hash pos_to_rating item { "adj" } + from hash pos_to_rating item { "afj" }
    set from hash pos_to_rating item { "adj" } to from hash pos_to_rating item { "adj" } + from hash pos_to_rating item { "adv" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "n," }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "f" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "m" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "n,f" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "n,m" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "n,m,f" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "n,f,m" }
    set from hash pos_to_rating item { "n" } to from hash pos_to_rating item { "n" } + from hash pos_to_rating item { "pron" }
    
    set new var best_pos to 'q'
    set new var best_score to 0
    
    set new array pos_to_rating_keys to an empty array
    set items of array pos_to_rating_keys to keys with items of hash pos_to_rating
    for each new var pos_key in array pos_to_rating_keys do
        if not var pos_key matches /^(n|v|adj)$/ do
            go to next
        done
        set new var score to from hash pos_to_rating item { var pos_key }
        if var score is 0 do
            go to next
        done
        set new var cnt to from hash pos_to_count_words item { var pos_key }
        set var score to var score * var score / var cnt
        set var score to int with var score * 100
        
        if var score > var best_score do
            set var best_score to var score
            set var best_pos to var pos_key
        done
        print "- score of '" concat var pos_key concat "': " concat var score concat new line
    done
    print "" concat new line
    print "'" concat var word concat "' => '" concat var best_pos concat "'" concat new line
    
    
    do return with var best_pos
done

define action join_items with array list do
    set new var txt to ''
    for each new var listitem in array list do
        set var txt to var txt concat " ("
        set var txt to var txt concat var listitem
        set var txt to var txt concat "), "
    done
    do return with var txt
done

define action entity_chose_add_current_word with var lang, array words, hash tags, var current_tag, var next_tag do
    set new flag add_current_word to 0

    if from hash sym_noun item { var current_tag } or from hash sym_noun item { var next_tag } do
        set flag add_current_word to 1
    done
    if from hash sym_entity item { var current_tag } and from hash sym_entity item { var next_tag } do
        set flag add_current_word to 1
    done
    if from hash sym_verb item { var current_tag } do
        set flag add_current_word to 0
    done

    do return with flag add_current_word
done

define action entity_chose_end_of_entity with var lang, array words, hash tags, var current_tag, var next_tag, var current_word, var next_word, flag found_subject do
    set new flag end_of_entity to 0

    if flag found_subject do
        do return with flag end_of_entity
    done

    if from global hash builtin_entity_ends item { lc(var current_word) } do
        set flag found_subject to 1
        set flag end_of_entity to 1
    done
    
    set new var current_is_male_name to 0
    set new array male_names to global array builtin_male_names
    for each new var name in array male_names do
        if lc(var name) matches lc(var current_word) do
            set var current_is_male_name to 1
        done
    done
    if from hash sym_noun item { from array current_tag first item } and from hash sym_noun item { from array next_tag first item } and ( var current_is_male_name is false or var current_word matches /_/ ) do
        set flag found_subject to 1
        set flag end_of_entity to 1
    done
    
    set new array pairs to global array builtin_entity_ends_pair
    for each new array pair in array pairs do
        
        if lc(var current_word) matches from array pair first item or not from array pair first item do
            if lc(var next_word) matches from array pair second item or not from array pair second item do
                set flag found_subject to 1
                set flag end_of_entity to 1
            done
        done
    done


    do return with flag end_of_entity
done

##((from hash sym_linking item { from array current_tag first item } or from hash sym_entity item { from array next_tag first item }) or ((from hash sym_noun item { from array current_tag first item } or from hash sym_linking item { from array current_tag first item }) and (from hash sym_noun item { from array next_tag first item } or from hash sym_linking item { from array next_tag first item } or not from array next_tag first item )))

# TEXT
# ~~~~~ PARSER CODE ~~~~~
#
# This function returns the next few words from "array words" which are either nouns, acticles, or adjectives.
# CODE

define action parse_using_entity with var lang, array words, hash tags, flag found_subject, var what do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_entity."
    print new line

    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array

    # TEXT
    # Decide whether this entity is a subject or an object
    # CODE
    set new var entity_key_name to "subjects"
    if flag found_subject do
        set var entity_key_name to "objects"
    done

    # TEXT
    # Here the current word and the following word are assigned to variables.
    # CODE
    set new var current_word to from array words first item
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words second item
    set new array next_tag to from hash tags item { var next_word }

    print var ident
    print "#    "
    print 'var entity_key_name: ' concat var entity_key_name concat ' ( ' concat var current_word concat ' -> ' concat var next_word concat ' )'
    print new line


    set new flag add_current_word to entity_chose_add_current_word with var lang, array words, hash tags, from array current_tag first item, from array next_tag first item


    set new flag count to 20
    while flag add_current_word do
    
        set flag count to flag count - 1
        if flag count <= 0 do
            go to last
        done

        print "now:   " concat from array current_tag first item concat " - " concat var current_word
        print new line
        print "next:  " concat from array next_tag first item concat " - " concat var next_word
        print new line
        set new var _words to join_items with array words
        print "array: " concat var _words
        print new line

        if from hash full_entity item { var entity_key_name } is false do
            set from hash full_entity item { var entity_key_name } to an empty array
        done
        push into that array: ( from hash full_entity item { var entity_key_name } ) end-items-of, [ var current_word ]
        shift from array words

        if from global hash builtin_entity_ends item { lc(var current_word) } do
            set flag found_subject to 1
            set var entity_key_name to "subjects"
            if flag found_subject do
                set var entity_key_name to "objects"
            done
        done

        set var current_word to from array words first item
        set array current_tag to from hash tags item { var current_word }
        set var next_word to from array words second item
        set array next_tag to from hash tags item { var next_word }

        set flag add_current_word to entity_chose_add_current_word with var lang, array words, hash tags, from array current_tag first item, from array next_tag first item

        if flag found_subject is 0 do
            set flag found_subject to entity_chose_end_of_entity with var lang, array words, hash tags, from array current_tag first item, from array next_tag first item, var current_word, var next_word, flag found_subject

            set var entity_key_name to "subjects"
            if flag found_subject do
                set var entity_key_name to "objects"
            done

            if flag found_subject do
                set flag add_current_word to 0
            done
        done
    done

    print "end of loop."
    print new line
    print "now:   " concat from array current_tag first item concat " - " concat var current_word
    print new line
    print "next:  " concat from array next_tag first item concat " - " concat var next_word
    print new line
    set new var _words to join_items with array words
    print "array: " concat var _words
    print new line

    if from global hash builtin_entity_ends item { lc(var current_word) } do
        set flag found_subject to 1
        set var entity_key_name to "subjects"
        if flag found_subject do
            set var entity_key_name to "objects"
        done
    done

    set new array pairs to global array builtin_entity_ends_pair
    for each new array pair in array pairs do
        
        if lc(var current_word) matches from array pair first item or not from array pair first item do
            if lc(var next_word) matches from array pair second item or not from array pair second item do
                set flag found_subject to 1
                set var entity_key_name to "subjects"
                if flag found_subject do
                    set var entity_key_name to "objects"
                done
            done
        done
    done

    # TEXT
    # The subject ends when there is a noun which is followed by an adjective or an adverb or a verb or nothing.
    # CODE
    if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
    #    if from hash sym_verb item { from array next_tag item [ const TYPE ] } do
    #        if (not items of that array: from hash full_entity item { var entity_key_name } end-items-of) or (not from hash full_entity item { var entity_key_name } item [ items of that array: from hash full_entity item { var entity_key_name } end-items-of - 1 ] first item matches var current_word) do
    #            push into that array: ( from hash full_entity item { var entity_key_name } ) end-items-of, [ var current_word ]
    #            shift from array words
    #        done
    #    done
    done
    if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
        if from hash sym_adj item { from array next_tag item [ const TYPE ] } || from hash sym_art item { from array next_tag item [ const TYPE ] } || from hash sym_verb item { from array next_tag item [ const TYPE ] } || from hash sym_prep item { from array next_tag item [ const TYPE ] } do
            set flag found_subject to 1
        done
    done
    
    # TEXT
    # The subject ends when the current word is an article and the next one is a verb
    # CODE
    if from hash sym_art item { from array current_tag item [ const TYPE ] } do
        if from hash sym_verb item { from array next_tag item [ const TYPE ] } do
            set flag found_subject to 1
        done
    done
    
    # TEXT
    # The subject ends when the current word is an adjective/adverb and the next one is a verb
    # CODE
    if from hash sym_adj item { from array current_tag item [ const TYPE ] } do
        if from hash sym_verb item { from array next_tag item [ const TYPE ] } do
            set flag found_subject to 1
        done
    done
    
    if not var what matches "nothing" do

        # TEXT
        # In "hash parsed" there will be the next word, if it's also either a noun, an adjective or an article.
        # Otherwise it will be empty
        # CODE
        set new hash parsed to parse_what with var lang, array words, hash tags, var what, flag found_subject
        if defined hash parsed and is an empty hash parsed do
            # TEXT
            # It's empty. The "1", which is returned as the second array element,
            # means that there's another following part of speech, probably a verb
            # CODE

            print var ident
            print "#    "
            print "End do parse_using_entity."
            print new line
            set var ident to var ident concat "\b\b"
            do return using [ hash full_entity, 1 ]
        done
        else if defined hash parsed do
            # TEXT
            # It's not empty. The "0" means that we are at the end of the sentence.
            # In "hash parsed", there is the last word, either a noun, an adjective or an article.
            # CODE
            
            set new array keys to [ keys of hash parsed ]
            for each new var key in array keys do
                set new array new_value to from hash full_entity item { var key }
                push into array new_value, items of that array: from hash parsed item { var key } end items of
                set from hash full_entity item { var key } to array new_value
            done
        done
    done
        
    print var ident
    print "#    "
    print "End do parse_using_entity."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_using_verb with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_verb."
    print new line
    
    set new array full_entity to an empty array
    
    set new var current_word to from array words first item
    push into array full_entity, [ var current_word ]
    shift from array words
    
    print var ident
    print "#    "
    print "End do parse_using_verb."
    print new line
    set var ident to var ident concat "\b\b"
    do return using array full_entity
done

define action parse_using_preposition with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_preposition."
    print new line
    
    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array

    # TEXT
    # Participle constructions, prepositions and adverbs are the same in FreeHAL english and FreeHAL german.
    # CODE
    set new var entity_key_name to "adverbs"

    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So push it into "hash full_entity"
    # CODE
    set new var current_word to from array words first item
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words second item
    set new array next_tag to from hash tags item { var next_word }

    set new var entity to var current_word
    shift from array words
    
    if from hash sym_adj item { from array current_tag item [ const TYPE ] } do
        # The word is an adverb. Do nothing.
    done
    if from hash sym_prep item { from array current_tag item [ const TYPE ] } do
    
        # The word is a preposition. Search an entitiy after this word.
        set new hash parsed to parse_what with var lang, array words, hash tags, "nothing", flag found_subject
        
        if defined hash parsed and that hash is not empty: hash parsed end check do
            # TEXT
            # It's not empty.
            # In "hash parsed", there is the last word, either a noun, an adjective or an article.
            # CODE
            
            if not from hash parsed item { "questionword" } do
                set from hash parsed item { "questionword" } to an empty array
            done
            if not that array is empty: from hash parsed item { "questionword" } end check do
                # TEXT
                # A question word was found! DO NOT add everything to the "adverbs" column.
                # Instead, add everything where it fits best.
                # CODE
                print "A question word was found! DO NOT add everything to the \"adverbs\" column."
                print new line
                print "Instead, add everything where it fits best."
                print new line
                
                set new array keys to [ keys of hash parsed ]
                for each new var key in array keys do
                    set new array new_value to from hash full_entity item { var key }
                    push into array new_value, items of that array: from hash parsed item { var key } end items of
                    set from hash full_entity item { var key } to array new_value
                done
            done
            else do
                # TEXT
                # No question word found...
                # Add everything to the \"adverbs\" column.
                # CODE
                print "No question word found..."
                print new line
                print "Add everything to the \"adverbs\" column."
                print new line
                
                set new array keys to [ 'adverbs', 'subjects', 'objects' ]
                for each new var key in array keys do
                    if from hash parsed item { var key } do
                        set new array new_value to from hash parsed item { var key }
                        for each new var value in array new_value is rw do
                            set var value to from array value first item
                            
                            print "Found a value: ", var value
                            print new line
                        done
                        # push into array new_value, items of that array: [ values items of hash parsed ] first item end items of
                        if is not an empty array new_value do
                            set var entity to var entity concat ' ' concat do join using " ", items of array new_value
                        done
                    done
                done
                
                # TEXT
                # Example for this feature: durch die 1905 _entwickelte_ Relativitaetstheorie
                # CODE
                if from hash sym_verb item { from hash tags item { from array words first item } first item } and from array words first item not matches "=" and not from hash sym_art item { from hash tags item { from array words second item } first item } do
                    print "Verb-inside feature activated."
                    print new line
                    print "Example for this feature: durch die 1905 _entwickelte_ Relativitaetstheorie."
                    print new line
                    if from hash sym_noun item { from hash tags item { from array words second item } first item } do
                        set var entity to var entity concat ' ' concat from array words first item
                        do shift with items of array words
                        set var entity to var entity concat ' ' concat from array words first item
                        do shift with items of array words
                    done
                done
                if from hash sym_linking item { from hash tags item { from array words first item } first item } do
                    set var entity to var entity concat ' ' concat from array words first item
                    do shift with items of array words
                done
                
            done
        done
    done

    set from hash full_entity item { var entity_key_name } to [ [ var entity ] ]

    print var ident
    print "#    "
    print "End do parse_using_preposition."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_using_questionword with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_questionword."
    print new line
    
    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array

    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So push it into "hash full_entity"
    # CODE
    set new var current_word to from array words first item
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words second item
    set new array next_tag to from hash tags item { var next_word }
    set new var nextnext_word to from array words item [ 2 ]
    set new array nextnext_tag to from hash tags item { var nextnext_word }

    shift from array words
    if from hash sym_adj item { from array next_tag item [ const TYPE ] } and not from hash sym_noun item { from array nextnext_tag item [ const TYPE ] } do
        # The word is an adverb. Fetch it.
        set from hash full_entity item { "extra" } to [ [ var next_word ] ]
        shift from array words
    done
    if from hash sym_noun item { from array next_tag item [ const TYPE ] } and not from hash val_omit item { lc(var next_word) } do
        if from hash sym_verb item { from array nextnext_tag item [ const TYPE ] } do
            # The word is a noun folowed by a verb. Fetch it.
            set from hash full_entity item { "extra" } to [ [ var next_word ] ]
            shift from array words
        done
    done
    
    set from hash full_entity item { "questionword" } to [ [ lc(var current_word) ] ]

    print var ident
    print "#    "
    print "End do parse_using_questionword."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_using_keyword with var lang, array words, hash tags, flag found_subject do
    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print "Begin do parse_using_keyword."
    print new line
    
    # TEXT
    # This will be returned.
    # CODE
    set new hash full_entity to an empty hash
    set from hash full_entity item { "subjects" } to an empty array
    set from hash full_entity item { "objects" } to an empty array
    set from hash full_entity item { "verbs" } to an empty array
    set from hash full_entity item { "adverbs" } to an empty array
    set from hash full_entity item { "extra" } to an empty array

    # TEXT
    # It is known that the next word WILL be either a noun, an adjective or an article.
    # So push it into "hash full_entity"
    # CODE
    shift from array words
    set new var current_word to from array words first item
    set new array current_tag to from hash tags item { var current_word }
    set new var next_word to from array words second item
    set new array next_tag to from hash tags item { var next_word }

        # Fetch all words.
    while var current_word do
        push into that array: from hash full_entity item { "extra" } end-items-of, [ var current_word ]
        shift from array words
        set var current_word to from array words first item
        set array current_tag to from hash tags item { var current_word }
        set var next_word to from array words second item
        set array next_tag to from hash tags item { var next_word }
        
        if from hash sym_prep item { from array current_tag first item } do
            go to last
        done
        if from hash sym_verb item { from array current_tag first item } do
            go to last
        done
    done
    
    print var ident
    print "#    "
    print "End do parse_using_keyword."
    print new line
    set var ident to var ident concat "\b\b"
    do return using [ hash full_entity, 0 ]
done

define action parse_what with var lang, array words, hash tags, var what, flag found_subject do
    do be_slow without arguments

    set var ident to var ident concat '  '
    print var ident
    print "#    "
    print 'Begin do parse_what: flag found_subject is ' concat flag found_subject concat ', var what is ' concat var what
    print new line


    set new hash parsed to an empty hash
    set from hash parsed item { "subjects" } to an empty array
    set from hash parsed item { "objects" } to an empty array
    set from hash parsed item { "verbs" } to an empty array
    set from hash parsed item { "adverbs" } to an empty array

    set new var go_on to 1
    while var go_on do
    
        do be_slow without arguments

        set new var current_word to from array words first item
        set new array current_tag to from hash tags item { var current_word }
        set new var next_word to from array words second item
        set new array next_tag to from hash tags item { var next_word }
        
        if not var current_word do
            print var ident
            print "#    "
            print "End do parse_what(->3)."
            print new line
            set var ident to var ident concat "\b\b"
            if is an empty hash parsed do
                do return using undef
            done
            else do
                do return using hash parsed
            done
        done

        print var ident
        print "#    "
        print "  :: current " concat var current_word concat " - " concat from array current_tag item [ const TYPE ]
        print new line

        if from hash sym_keyword item { var current_word } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_keyword using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
            
            if var current_word matches "ENUMALL" do
                do unshift using items of that array: from hash parsed item { "extra" } end-items-of, [ var current_word ]
            done
        done
        else if from global hash builtin_time_place_adverbs item { var current_word } or (from hash sym_adj item { from array current_tag item [ const TYPE ] } and builtin_has_time_place_adverbs_suffix(var current_word)) or var current_word matches /^in_/ or ( from hash sym_adj item { from array current_tag item [ const TYPE ] } and not from hash sym_entity item { from array next_tag item [ const TYPE ] } ) do
            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
            
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_preposition using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
        done
        else if from hash sym_entity item { from array current_tag item [ const TYPE ] } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_entity using var lang, array words, hash tags, flag found_subject, var what
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                if from hash add_parsed item { var key } and from hash add_parsed item { var key } first item do
                    print "adding to: ", var key, " data: ", from hash add_parsed item { var key } first item first item
                done
                print new line
                set from hash parsed item { var key } to array new_value
            done

            if var what matches "nothing" do
                if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
                    print var ident
                    print "#    "
                    print "End do parse_what(->6)."
                    print new line
                    set var ident to var ident concat "\b\b"
                    do return using hash parsed
                done
            done

            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->3)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
        done
        else if from hash sym_linking item { from array current_tag item [ const TYPE ] } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_entity using var lang, array words, hash tags, flag found_subject, var what
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done

            if var what matches "nothing" do
                if from hash sym_noun item { from array current_tag item [ const TYPE ] } do
                    print var ident
                    print "#    "
                    print "End do parse_what(->5)."
                    print new line
                    set var ident to var ident concat "\b\b"
                    do return using hash parsed
                done
            done

            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->3)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
        done
        else if from hash sym_questionword item { from array current_tag item [ const TYPE ] } do
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_questionword using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
        done
        else if from hash sym_prep item { from array current_tag item [ const TYPE ] } do
            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
            
            set ( new hash add_parsed, new var go_on ) to array-returning parse_using_preposition using var lang, array words, hash tags, flag found_subject
            set new array keys to [ keys of hash add_parsed ]
            for each new var key in array keys do
                set new array new_value to from hash parsed item { var key }
                push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                set from hash parsed item { var key } to array new_value
            done
            
            set new var preposition to var current_word
            set var current_word to from array words first item
            set array current_tag to from hash tags item { var current_word }
            set var next_word to from array words second item
            set array next_tag to from hash tags item { var next_word }
            while from hash sym_linking item { from array current_tag item [ const TYPE ] } do
                set from array words first item to var preposition concat " " concat from array words first item
                set ( new hash add_parsed, new var go_on ) to array-returning parse_using_preposition using var lang, array words, hash tags, flag found_subject
                set new array keys to [ keys of hash add_parsed ]
                for each new var key in array keys do
                    set new array new_value to from hash parsed item { var key }
                    push into array new_value, items of that array: from hash add_parsed item { var key } end items of
                    set from hash parsed item { var key } to array new_value
                done

                set var current_word to from array words first item
                set array current_tag to from hash tags item { var current_word }
                set var next_word to from array words second item
                set array next_tag to from hash tags item { var next_word }
            done
        done
        else if from hash sym_verb item { from array current_tag item [ const TYPE ] } do
            if var what matches "nothing" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done
            if var what matches "entity" do
                print var ident
                print "#    "
                print "End do parse_what(->2)."
                print new line
                set var ident to var ident concat "\b\b"
                do return using hash parsed
            done

            set new array add_parsed to parse_using_verb using var lang, array words, hash tags, flag found_subject

            if that array is not empty: from hash parsed item { "subjects" } end check do
                set flag found_subject to 1
            done

            if not from hash parsed item { "verbs" } do
                set from hash parsed item { "verbs" } to an empty array
            done
            push into that array: from hash parsed item { "verbs" } end-items-of, items of array add_parsed
        done
        else do
            print var ident
            print "#    "
            print "Unknown part of speech: " concat var current_word concat "(-> " concat from array current_tag item [ const TYPE ] concat ")"
            print new line
            shift from array words
        done
    end loop

    print var ident
    print "#    "
    print "End do parse_what(->1)."
    print new line
    set var ident to var ident concat "\b\b"

    do return using hash parsed
done

define action pre_parse with array list_of_words, hash tags, var lang, var path do
    set new array list_of_list_of_words to an empty array
    set new array list_of_questionwords to an empty array
    push into array list_of_list_of_words, an empty array
    push into array list_of_questionwords, an empty array
    set new var array_index to 0

    set new var i to 0
    for each new var word in array list_of_words is rw do
        if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_verb item { from hash tags item { from array list_of_words item [ var i - 1 ] } first item } and from hash sym_entity item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            do push into that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
        done
        else if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_verb item { from hash tags item { from array list_of_words item [ var i - 1 ] } first item } and from hash sym_prep item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            do push into that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
        done
        else if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_verb item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            do push into that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
        done
        else if from hash sym_linking item { from hash tags item { var word } first item } and from hash sym_entity item { from hash tags item { from array list_of_words item [ var i + 1 ] } first item } do
            # A is B and C and D and E and F
            set var array_index to var array_index + 1
            push into array list_of_list_of_words, an empty array
            if from array list_of_questionwords item [ var array_index - 1 ] do
                push into array list_of_questionwords, items of that array: from array list_of_questionwords item [ var array_index - 1 ] end-items-of
            done
            
            print "Template found: 'A is B and C and D and E and F'."
            print new line
            
            # set current part to last part
            do push into that array: from array list_of_list_of_words item [ var array_index ] end-items-of, items of that array: from array list_of_list_of_words item [ var array_index - 1 ] end-items-of,
            
            # current part (= last part) has an article near the end?
            set new var part_size to size of that array: from array list_of_list_of_words item [ var array_index ] end-items-of
            # "near the end" is defined as 4 words
            set new var near_end to var part_size - 4
            if var near_end < 0 do
                set var near_end to 0
            done
            
            set new var the_end to -1
            set new var d to var part_size - 1
            while var d >= var near_end do
                set new var word_d to from array list_of_list_of_words item [ var array_index ] item [ var d ]
                
                if from hash sym_art item { from hash tags item { var word_d } first item } do
                    set var the_end to var d
                done
                
                set var d to var d - 1
            done
            
            if not var the_end is -1 do
                print "found an article."
                print new line
            done
            
            # found an article? if not, search last adjective
            if var the_end is -1 do
                print "found no article."
                print new line
                
                set new var d to var part_size - 1
                while var d >= var near_end do
                    set new var word_d to from array list_of_list_of_words item [ var array_index ] item [ var d ]
                    
                    if from hash sym_adj item { from hash tags item { var word_d } first item } do
                        set var the_end to var d
                    done
                    
                    set var d to var d - 1
                done
            done

            if not var the_end is -1 do
                print "found an adjective."
                print new line
            done

            # found an adjective? if not, search last noun
            if var the_end is -1 do
                print "found no adjective."
                print new line
                
                set new var d to var part_size - 1
                while var d >= var near_end do
                    set new var word_d to from array list_of_list_of_words item [ var array_index ] item [ var d ]
                    
                    if from hash sym_noun item { from hash tags item { var word_d } first item } do
                        set var the_end to var d
                    done
                    if from hash sym_verb item { from hash tags item { var word_d } first item } do
                        go to last
                    done
                    
                    set var d to var d - 1
                done
            done
            
            if not var the_end is -1 do
                print "found a noun."
                print new line
            done
            else do
                print "found no noun."
                print new line
            done

            # found anything?
            if not var the_end is -1 do
                # then cut off the rest
                set new var diff to var part_size - var the_end
                for 1 .. var diff do
                    do pop using items of that array: from array list_of_list_of_words item [ var array_index ] end-items-of
                done
            done
        done
        else do
            do push into that array: from array list_of_list_of_words item [ var array_index ] end-items-of, var word
            
            if from hash sym_questionword item { from hash tags item { var word } first item } do
                do push into that array: from array list_of_questionwords item [ var array_index ] end-items-of, var word
            done
        done

        set var i to var i + 1
    done
    
    print new line
    print "Pre-Parser (index: var array_index size: "
    set new var temp_size to items of array list_of_list_of_words
    print var temp_size
    print ")"
    print new line
    print "-------------------------------------------------------"
    print new line
    for each new var subarray in array list_of_list_of_words do
        print "- "
        for each new var subitem in array subarray do
            print var subitem
            print ", "
        done
        print new line
    done
    print "-------------------------------------------------------"
    print new line
    print new line
    
    do return with array list_of_list_of_words
done

define action parse with var lang, array words, hash tags do
    set new hash parsed to an empty hash
    
    # TEXT
    # In German, there are many verbs which are sometimes written as
    # "$prefix$verb", but also as "$verb $prefix" (as two words).
    # Changing the second form into the first one is done by
    # first searching the prefixes and then prepending them to the verb.
    # <br /><br />
    # Search prefixes:
    # CODE
    
    set new var prefix to ''
    
    set new array words_correct to an empty array
    set new var i to 0
    for each new var word in array words is copy do
        if from global hash builtin_verb_prefixes item { lc(var word) } and from array words item [ var i + 1 ] matches "" do
            # TEXT
            # It is a prefix.
            # CODE
            
            if var word do
                set var prefix to var word
            done
        done
        else do
            # TEXT
            # It's another word. Add it to the new words array.
            # CODE
            
            push into array words_correct, var word
        done
        set var i to var i + 1
    done
    
    
    
    # TEXT
    # Add prefixes to the verb(s):
    # CODE
    if var prefix do
        set array words to [ items of array words_correct ]
        set array words_correct to an empty array
        for each new var word in array words is copy do
            if from hash sym_verb item { from hash tags item { var word } first item } do
                # TEXT
                # It is a verb.
                # CODE
                
                set from hash tags item { var prefix concat var word } to from hash tags item { var word }
                
                set var word to var prefix concat var word
            done

            push into array words_correct, var word
        done
    done
    
    set hash parsed to parse_what using var lang, array words_correct, hash tags, "full", 0
    DEBUG VAR: hash parsed STOP DEBUG
    do return using hash parsed
done

define action compute_context with hash parsed do
    set new array questionword_array to from hash parsed item { 'questionword' } first item
    set new array verb_array to from hash parsed item { 'verbs' }
    set new array extra_array to from hash parsed item { 'extra' }
    
    if from array questionword_array first item matches "wie" or from array questionword_array first item matches "how" do
        do return with "q_how"
    done
    if from array questionword_array first item matches /^welch/ do
        do return with "q_what_prep"
    done
    if from array questionword_array first item matches /^woher/ do
        do return with "q_from_where"
    done
    if from array questionword_array first item matches /^wo/ or from array questionword_array first item matches "where" do
        do return with "q_where"
    done
    if from array questionword_array first item matches /^wer/ or from array questionword_array first item matches "who" do
        do return with "q_who"
    done
    if lc(from array questionword_array first item) matches "was" or lc(from array questionword_array first item) matches "what" do
        if from array verb_array first item first item matches /^(bist|bi|bin)$/ do
            do return with "q_what_exactly"
        done
        else if from array extra_array first item first item do
            do return with "q_what_extra"
        done
        else do
            do return with "q_what_weakly"
        done
    done

    if lc(from array extra_array first item first item) matches "enumall" do
        do shift with items of that array: from array extra_array first item end-items-of
        set from hash parsed item { 'extra' } to array extra_array
        do return with "enum_all"
    done
    
    for each new var verb in array verb_array do
        if var verb first item matches /reasonof/ do
            do return with "reasonof"
        done
    done
    
    # TEXT
    # Look for something like "Das habe ich nicht gemeint"
    # CODE
    for each new var verb in array verb_array do
        if var verb first item matches /mein<[et]>/ do
            do return with "not_meant"
        done
    done


    do return with "default"
done

define action reasonof_construct_hash with array verbs, var lang, var path, hash parsed do
    for each new array verb in array verbs is rw do
        if from array verb first item matches /^(habe|hast|hab|haben|habt)$/ do
            set from array verb first item to "haben"
        done
        else if from array verb first item matches /^(ien|bi|<[=]>|is|bin|bist|ist|sind|seid|heisst|heisse|heissen|sei|war|wurde|wurden|werden|werde|wirst|wurdest|wurde|wuerdet|werdet)$/ do
            set from array verb first item to "sein"
        done
        else do
            if from array verb first item matches /st$/ do
                do regex using from array verb first item: /st$/, "en", :i
            done
            else if from array verb first item matches /e$/ do
                do regex using from array verb first item: /e$/, "en", :i
            done
            else if from array verb first item matches /ben$/ do
                # do nothing
            done
            else if items of array verbs is 1 do
                do regex using from array verb first item: /...$/, "*", :i
            done
            else do
                ##
            done
        done
    done

    set new hash parsed_1 to fake_hash_parsed without arguments
    set from hash parsed_1 item { 'verbs' } to an empty array
    set new array verb to an empty array
    push into array verb, "reasonof"
    push into that array: from hash parsed_1 item { 'verbs' } end items of, array verb
    set from hash parsed_1 item { 'subjects' } to an empty array
    # push into that array: from hash parsed_1 item { 'subjects' } end items of, items of array subjects
    push into that array: from hash parsed_1 item { 'subjects' } end items of, items of array verbs
    set from hash parsed_1 item { 'objects' } to an empty array
    set from hash parsed_1 item { 'clauses' } to an empty array
    set from hash parsed_1 item { 'adverbs' } to an empty array
    set from hash parsed_1 item { 'questionword' } to an empty array
    
    do return with hash parsed_1
done

define action reasonof with var input, var lang, var path, hash parsed do
    set new array hashes to an empty array
    set new array results to an empty array

    set new array verbs to an empty array
    set new array _verbs to from hash parsed item { 'verbs' }
    for each new array _verb in array _verbs do
        set new array verb to an empty array
        set items of array verb to items of array _verb
        push into array verbs, array verb
    done
    
    set new hash parsed_2 to reasonof_construct_hash with array verbs, var lang, var path, hash parsed
    set new array results_2 to logic with var input, var lang, var path, hash parsed_2
    if array results_2 matches "TOOMUCH" do
        do return with array results
    done
    set array results_2 to reasonof_logic_from_object with array results_2, array verbs, var lang, var path, hash parsed
    push into array results, items of array results_2
    
    do return with array results
done

define action reasonof_logic_from_subject with array results, array verbs, var lang, var path, hash parsed do
    do return with array results
done

define action reasonof_logic_from_object with array results, array verbs, var lang, var path, hash parsed do

    set new array request_subjects_array to from hash parsed item { 'subjects' }
    set new array request_subjects to an empty array
    for each new array subjects in array request_subjects_array is rw do
        push into array request_subjects, from array subjects first item
    done
    set new var subject to join using ' ', items of array request_subjects

    #from hash parsed item { 'subjects' }
    set new array constructed_results to an empty array
    
    set new array _results to an empty array
    set items of array _results to items of array results
    set array results to an empty array
    
    for each new array result in array _results do
    
        set new flag go_next to 0
        set new var num_must_haves to 0
        
        if from hash parsed item { 'adverbs' } do
            set new array must_haves to from hash parsed item { 'adverbs' } first item
            for each new var must_have in array must_haves do
                set var must_have to lc with var must_have

                set new array tags to an empty array
                if var must_have matches /\s/ do
                    set new var _must_have to var must_have
                    do regex using var _must_have: /\s.*/, "", :global
                    set array tags to compute_tags with var _must_have, var lang, var path
                    
                    if from hash sym_prep item { from array tags first item } do
                        set var _must_have to var must_have
                        do regex using var _must_have: /^.*?\s/, "", :i
                        do regex using var _must_have: /\s.*/, "", :global
                        set array tags to compute_tags with var _must_have, var lang, var path
                    done
                done
                else do
                    set array tags to compute_tags with var must_have, var lang, var path
                done
                set new flag is_builtin to builtin_has_time_place_adverbs_suffix with var must_have

                if var must_have and lc( from array result second item second item ) matches /var must_have/ or flag is_builtin do
                    print "[+] Has must-have (no 1) '" concat var must_have concat "': '" concat from array result second item second item concat "'"
                    print new line
                    if var must_have do
                        set var num_must_haves to var num_must_haves + 1
                    done
                done
                else if from hash sym_prep item { from array tags first item } do
                    print "[+] Has must-have (no 1) '" concat var must_have concat "': '" concat from array result second item second item concat "' (but does not need to have it: prep)"
                    print new line
                done
                else do
                    print "[-] Does not have must-have (no 1) '" concat var must_have concat "': '" concat from array result second item second item concat "'"
                    print new line
                    set flag go_next to 1
                done
            done
        done
        
        if from hash parsed item { 'objects' } do
            set new array must_haves to from hash parsed item { 'objects' } first item
            for each new var must_have in array must_haves do
                set var must_have to lc with var must_have
                if ( not var must_have ) or not lc( from array result second item second item ) matches /var must_have/ do
                    print "[-] Does not have must-have (no 2) '" concat var must_have concat "': '" concat from array result second item second item concat "'"
                    print new line
                    set flag go_next to 1
                done
                else do
                    print "[+] Has must-have (no 2) '" concat var must_have concat "': '" concat from array result second item second item concat "'"
                    print new line
                    if var must_have do
                        set var num_must_haves to var num_must_haves + 1
                    done
                done
            done
        done
        
        if 1 do
#  from array verbs first item matches /<[|]>/ do # items of array verbs is 1
            set new array _must_haves to from hash parsed item { 'verbs' }
            for each new array must_haves in array _must_haves do
                for each new var must_have in array must_haves do
                    set var must_have to lc with var must_have
                    do regex using var must_have: /...$/, "", :i
                    if length(var must_have) > 2 do
                        if not lc( from array result second item second item ) matches /var must_have/ do
                            print "[-] Does not have must-have (no 3) '" concat var must_have concat "': '" concat from array result second item second item concat "'"
                            print new line
                            set flag go_next to 1
                        done
                        else do
                            print "[+] Has must-have (no 3) '" concat var must_have concat "': '" concat from array result second item second item concat "'"
                            print new line
                            if var must_have do
                                set var num_must_haves to var num_must_haves + 1
                            done
                        done
                    done
                done
            done
        done
        
        if var num_must_haves and not flag go_next do
            push into array results, array result
        done
    done
    
    # A should do B
    for each new array result in array results do
        set new array main_clause to an empty array
        
        set new var expr to from array result second item third item
        set new array words to split with " ", var expr
        set new var verb to pop with items of array words
        set new var object to join using ' ', items of array words
        
        push into array main_clause, var verb concat "00001"
        push into array main_clause, var subject
        push into array main_clause, var object
        push into array main_clause, " (+++)"
        
        set new array constructed_result to an empty array
        push into array constructed_result, 0
        push into array constructed_result, array main_clause
        push into array constructed_results, array constructed_result
    done

    set new var already to adj_for_already without arguments
    set new var still to adj_for_still without arguments
    
    set new array adverbials to an empty array
    push into array adverbials, var already concat " ? "
    push into array adverbials, var still concat " ? "
    push into array adverbials, ""
    
    for each new var adverbial in array adverbials do
        # Has A already done B?
        for each new array result in array results do
            set new array main_clause to an empty array
            
            set new var expr to from array result second item 3rd item
            if not var expr do
                set var expr to from array result second item 4th item
            done
            print "expr: " concat var expr concat new line
            set new array words to split with " ", var expr
            set new var verb to pop with items of array words
            set new var verb_second to ""
            while from array words item [ items of array words - 1 ] matches /en$/ do
                set new var _verb to pop with items of array words
                
                if var verb_second do
                    set var verb_second to var _verb concat " " concat var verb_second
                done
                else do
                    set var verb_second to var _verb
                done
            done
            set new var object to join using ' ', items of array words
            
            print "verb: " concat var verb concat new line
            set new var prefix to to_verb_prefix with var verb, var lang, var path
            set new var root to to_verb_root with var verb, var lang, var path
            print "root: " concat var root concat new line
            set new array conj to to_verb_conjugation with var root, var prefix, var lang, var path
            set new var participle to make_participle with from array conj third item, var lang, var path
            
            set new var person to get_person with var subject
            set new var verb_modal to get_modal_verb_for_verb with var verb_second concat " " concat var participle, var lang, var path
            set var verb_modal to get_verb with var verb_modal, var person
            
            push into array main_clause, var verb_modal concat " " concat var verb_second concat " " concat var participle concat "00000"
            push into array main_clause, var subject
            push into array main_clause, var object
            push into array main_clause, var adverbial concat " (+++)"
            
            if var object matches /nothing/ and var adverbial matches /schon/ do
                go to next
            done
            if ( not var object matches /nothing/ ) and var adverbial matches /noch/ do
                go to next
            done
            
            set new array constructed_result to an empty array
            push into array constructed_result, 0
            push into array constructed_result, array main_clause
            push into array constructed_results, array constructed_result
        done
    done

    do return with array constructed_results
done

define action logic with var input, var lang, var path, hash parsed do
    set new array request_verb_array to an empty array
    if from hash parsed item { 'verbs' } do
        push into array request_verb_array, items of that array: from hash parsed item { 'verbs' } end-items-of
    done
    set new array override_verb_array to an empty array

    set new flag verb_flag_want   to 0
    set new flag verb_flag_must   to 0
    set new flag verb_flag_can    to 0
    set new flag verb_flag_may    to 0
    set new flag verb_flag_should to 0

    if array request_verb_array do
        set new var num_of_verbs to items of array request_verb_array
        if var num_of_verbs >= 1 do
            set new array new_verbs to an empty array
            set new flag do_removed to 0
            for each new array verb_array in array request_verb_array is rw do
                set new var verb to from array verb_array first item
                if not flag do_removed do
                    # TEXT
                    # Remove "do" and "does" in englishs entences
                    # CODE
                    if var verb matches /^(does|do)$/ do
                        set flag do_removed to 1
                        go to next
                    done
                    
                    # TEXT
                    # Turn verbs like "must" or "want" into flags
                    # CODE
                    set new var verb_category to verb_category with var verb
                    
                    if var verb_category do
                        set var verb to var verb concat "/" concat var verb_category
                        set from array verb_array first item to var verb
                        push into array override_verb_array, array verb_array
                    done
                    
                    if var verb_category matches 'want' do
                        set flag verb_flag_want to 1
                        go to next
                    done
                    if var verb_category matches 'must' do
                        set flag verb_flag_must to 1
                        go to next
                    done
                    if var verb_category matches 'can' do
                        set flag verb_flag_can to 1
                        go to next
                    done
                    if var verb_category matches 'may' do
                        set flag verb_flag_may to 1
                        go to next
                    done
                    if var verb_category matches 'should' do
                        set flag verb_flag_should to 1
                        go to next
                    done
                done
                push into array new_verbs, array verb_array
                push into array override_verb_array, array verb_array
            done
            set items of array request_verb_array to items of array new_verbs
            
            # if there is only one verb which is a modal verb
            #
            # then do nothing!
            #
            ##if is an empty array override_verb_array do
            ##    set new array verb_array to an empty array
            ##    push into array verb_array, "*"
            ##    push into array override_verb_array, array verb_array
            ##done
            ##if is an empty array request_verb_array do
            ##    set new array verb_array to an empty array
            ##    push into array verb_array, "*"
            ##    push into array request_verb_array, array verb_array
            ##done
        done
        else do
            if from hash parsed item { 'verbs' } do
                set items of array override_verb_array to items of that array: from hash parsed item { 'verbs' } end-items-of
            done
        done
    done
    set items of that array: from hash parsed item { 'verbs' } end-items-of to items of array override_verb_array

    set new array request_verb to an empty array
    for each new array verb in array request_verb_array is rw do
        set new var multiple_choices_verb to multiple_choices_verb with from array verb first item
        push into array request_verb, var multiple_choices_verb
    done

    set new array request_subjects_array to from hash parsed item { 'subjects' }
    set new array request_subjects to an empty array
    for each new array subjects in array request_subjects_array is rw do
        push into array request_subjects, from array subjects first item
    done

    set new array request_objects_array to from hash parsed item { 'objects' }
    set new array request_objects to an empty array
    for each new array objects in array request_objects_array is rw do
        if not from array objects first item matches /nothing/ do
            push into array request_objects, from array objects first item
        done
    done

    set new array request_adverbs_array to from hash parsed item { 'adverbs' }
    set new array request_adverbs to an empty array
    for each new array adverbs in array request_adverbs_array is rw do
        if not from array adverbs first item matches /nothing/ do
            push into array request_adverbs, from array adverbs first item
        done
    done

    set new var request_context_string to compute_context using hash parsed

    set new array request_extra_array to from hash parsed item { 'extra' }
    set new array request_extra to an empty array
    for each new array extra in array request_extra_array is rw do
        if not from array extra first item matches /nothing/ do
            push into array request_extra, from array extra first item
        done
    done
    
    set items of array request_verb to sort with items of array request_verb
    
    set new var request_verb_string to join using ' ', items of array request_verb
    set new var request_subjects_string to join using ' ', items of array request_subjects
    set new var request_objects_string to join using ' ', items of array request_objects
    set new var request_adverbs_string to join using ' ', items of array request_adverbs
    set new var request_extra_string to join using ' ', items of array request_extra

    if var request_context_string matches "enum_all" do
        set var request_extra_string to get_plural with var request_extra_string
    done

    if var request_verb_string or var request_subjects_string or var request_objects_string or var request_adverbs_string do
        set new var flowchart_log to handle for file name var path concat '/flowchart.log', append
        print into var flowchart_log data "begin box"
        print into var flowchart_log data new line
        print into var flowchart_log data "bckgrndcolr D0FFCF"
        print into var flowchart_log data new line
        print into var flowchart_log data "bordercolor D0FFCF"
        print into var flowchart_log data new line
        print into var flowchart_log data "linesoftext 7"
        print into var flowchart_log data new line
        print into var flowchart_log data "draw"
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Verbs:\t" concat var request_verb_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Subjects:\t" concat var request_subjects_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Objects:\t" concat var request_objects_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Adverbs:\t" concat var request_adverbs_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Other:\t" concat var request_extra_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Context:\t" concat var request_context_string
        print into var flowchart_log data new line
        print into var flowchart_log data "textcontent 000000 Modal verbs:\twant: " concat flag verb_flag_want concat "\tmust: " concat flag verb_flag_must concat "\tcan: " concat flag verb_flag_can concat "\tmay: " concat flag verb_flag_may concat "\tshould: " concat flag verb_flag_should
        print into var flowchart_log data new line
        print into var flowchart_log data "end box"
        print into var flowchart_log data new line
        do close with var flowchart_log
    done

    set array request_subjects to stem_nouns with [ var request_subjects_string ]
    set array request_objects to stem_nouns with [ var request_objects_string ]
    set array request_extra to stem_nouns with [ var request_extra_string ]
    set var request_subjects_string to from array request_subjects first item
    set var request_objects_string to from array request_objects first item
    set var request_extra_string to from array request_extra first item

    set new var request_primary_key to from hash parsed item { 'primary_key' }
    if not var request_primary_key do
        set var request_primary_key to "0"
    done

    set new var output_file_name to '_output__get_csv'
    set new var output to ''
    set var output to var output concat ( lc(var request_verb_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_subjects_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_objects_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_adverbs_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_extra_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_context_string) || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( lc(var request_primary_key) || '0' )
    
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_want   || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_must   || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_can    || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_may    || '0' )
    set var output to var output concat ( '^' )
    set var output to var output concat ( flag verb_flag_should || '0' )


    do unlink with '_input__get_csv'
    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data var output
    do close with var output_handle
    
    do wait 0.3 seconds

    while not exists: '_input__get_csv', end test do
        do wait 0.1 seconds
    done
    print "File exists now: _input__get_csv"
    print new line
    
    set new array results_true to an empty array
    set new array results_other_modal_verb_true to an empty array
    set new array results_false to an empty array
    set new array results_other_modal_verb_false to an empty array
    set new array results_maybe to an empty array
    set new array results_other_modal_verb_maybe to an empty array
    
    set new var input_file_name to '_input__get_csv'
    set new var input_handle to handle for file name var input_file_name, read

    for each new var line from var input_handle is rw do
        print var line
        print new line
        if var line matches /^<[\^]>/ do
            go to next
        done
        if length(var line) < 3 do
            go to next
        done
        
        if "/err:TOOMUCH" matches var line do
            do return using "TOOMUCH"
        done
        
        set new array result to an empty array
        set new array rawresult to split using /\^/, var line
        
        # TEXT
        # Shift Primary key
        # CODE
        set new var primary_key to shift with items of array rawresult
        
        if from array rawresult item [ 5 ] matches /film.pro/ do
            set from array rawresult item [ 3 ] to from array rawresult item [ 3 ] concat " (--)"
        done
        
        # TEXT
        # Divide main clause and sub clauses
        # CODE
        push into array result, an empty array
        set new var number_of_clause to 0
        set new var i to 0
        while var i < 6 do
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ var i ]
            set var i to var i + 1
        done
        
        # TEXT
        # Truth goes from 1.0 to 0.0.
        # CODE
        
        set new var truth to from array rawresult item [ var i ]
        do adjust_truth with array result, from array rawresult item [ var i ], var number_of_clause, 0
        set var i to var i + 1
        
        # TEXT
        # Now add the subclauses to the array.
        # CODE
        
        set new var offs to var i
        push into array result, an empty array
        set var number_of_clause to var number_of_clause + 1
        set var i to 0
        while var i < 10 do
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 0 ]
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 1 ]
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 2 ]
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 3 ]
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 4 ]
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 5 ]
            push into that array: from array result item [ var number_of_clause ] end items of, from array rawresult item [ (var i * 6) + var offs + 6 ]
            do adjust_truth with array result, from array rawresult item [ var offs - 1 + 6 ], var number_of_clause, var i
            set var i to var i + 1
            push into array result, an empty array
            set var number_of_clause to var number_of_clause + 1
        done
        
        # TEXT
        # Unshift Primary key
        # CODE
        do unshift with items of array result, var primary_key
        
        
        
        # TEXT
        # Be sure that the modal verbs are matched
        # CODE
        set new var modal_verb_template to var verb_flag_want concat var verb_flag_must concat var verb_flag_can concat var verb_flag_may concat var verb_flag_should
        if (not from array rawresult item [ 0 ] matches /var modal_verb_template/) and from array rawresult item [ 0 ] matches /([01])([01])([01])([01])([01])/ do
            print "Not matching to: " concat var modal_verb_template
            print new line
            
            if var truth > 0.75 do
                push into array results_other_modal_verb_true, array result
            done
            else if var truth < 0.25 do
                push into array results_other_modal_verb_false, array result
            done
            else do
                push into array results_other_modal_verb_maybe, array result
            done
        done
        else do
            if var truth > 0.75 do
                push into array results_true, array result
            done
            else if var truth < 0.25 do
                push into array results_false, array result
            done
            else do
                push into array results_maybe, array result
            done
        done
    done
    
    if is an empty array results_true and is an empty array results_maybe and not is an empty array results_false do
        set array results_other_modal_verb_maybe to an empty array
    done
    
    if is an empty array results_true do
        set array results_true to array results_other_modal_verb_true
    done
    if is an empty array results_false do
        set array results_false to array results_other_modal_verb_false
    done
    if is an empty array results_maybe do
        set array results_maybe to array results_other_modal_verb_maybe
    done
    
    print "Found " concat items of array results_true concat " true sentences" concat new line
    print "Found " concat items of array results_false concat " false sentences" concat new line
    print "Found " concat items of array results_maybe concat " maybe sentences" concat new line
    
    set new hash in_true to an empty hash
    set new hash in_false to an empty hash
    for each new array result in array results_true do
        set new var expr to from array result second item item [ 0 ] concat ' ' concat from array result second item item [ 1 ]
        if not from hash in_true item { var expr } do
            set from hash in_true item { var expr } to an empty array
        done
        push into that array: from hash in_true item { var expr } end items of, array result
        
        print "A true expression:  " concat var expr concat new line
    done
    for each new array result in array results_false do
        set new var expr to from array result second item item [ 0 ] concat ' ' concat from array result second item item [ 1 ]
        if not from hash in_false item { var expr } do
            set from hash in_false item { var expr } to an empty array
        done
        push into that array: from hash in_false item { var expr } end items of, array result
        
        print "A false expression: " concat var expr concat new line
    done
    
    set new array results to an empty array
    
    for each new array result in array results_maybe do
        set new var expr to from array result second item item [ 0 ] concat ' ' concat from array result second item item [ 1 ]
        
        print "A maybe expression: " concat var expr concat new line
        
        if from hash in_true item { var expr } do
            push into array results, items of that array: from hash in_true item { var expr } end items of
            set from hash in_true item { var expr } to an empty array
        done
        else if from hash in_false item { var expr } do
            push into array results, items of that array: from hash in_false item { var expr } end items of
            set from hash in_false item { var expr } to an empty array
        done
        else do
            push into array results, array result
        done
    done
    
    set new array true_arrays to an empty array
    set items of array true_arrays to values of hash in_true
    for each new array result_array in array true_arrays do
        push into array results, items of array result_array
    done
    set new array false_arrays to an empty array
    set items of array false_arrays to values of hash in_false
    for each new array result_array in array false_arrays do
        push into array results, items of array result_array
    done
    
    
    print "After t/m/f correction: found " concat items of array results concat " sentences"
    print new line

    # TEXT
    # Exception: If we are in the "enum_all" context, all subjects together are the object
    # CODE
    if var request_context_string matches "enum_all" and items of array results do
        set new hash subjects to an empty hash
    
        for each new array result in array results do
            print from array result second item first item concat new line
            print from array result second item second item concat new line
            print from array result second item item [ 2 ] concat new line
            print from array result second item item [ 3 ] concat new line
            print from array result second item item [ 4 ] concat new line
            print from array result second item item [ 5 ] concat new line
            print from array result second item item [ 6 ] concat new line
            print from array result second item item [ 7 ] concat new line
            print "---"
            print new line
            print new line
        
            set from hash subjects item { from array result second item second item } to 1
        done

        set new array overall_result to an empty array
        do unshift with items of array overall_result, 0
        push into array overall_result, an empty array
        set from array overall_result second item second item to join ', ', keys of hash subjects

        set array results to an empty array
        push into array results, array overall_result
    done
    
    do unlink with '_input__get_csv'

    do return using array results
done

define action phrase with var lang, var path, var mode, array results, hash parsed do
    set new array phrases to an empty array

    # TEXT
    # Iterate through all results.
    # CODE
    for each new array result in array results do
        set new var primary_key to shift with items of array result

        set new var final_sentence to ""
        
        for each new array clause in array result do
            set new array sentence to an empty array

            # TEXT
            # Tag and sort all verbs.
            # CODE
            set new array raw_verbs to [ split ' ', from array clause item [0] ]
            set new hash proper_verbs_hash to an empty hash
            set new hash auxiliary_verbs_hash to an empty hash
            
            for each new var verb in array raw_verbs do
                if var verb matches /=>/ do
                    # TEXT
                    # We have such a sentence:
                    # "Clause to match , => Clause to print"
                    # SO we have to remove the first one
                    # CODE
                    set var final_sentence to ""
                done
                
                if var verb matches /([01])([01])([01])([01])([01])$/ do
                    set new var person to get_person with from array clause item [1]
                    if var person matches "3s" do
                        set var person to get_person with hash parsed item { 'subjects' } first item
                    done
                    
                    set new var is_want to $0
                    set new var is_must to $1
                    set new var is_can to $2
                    set new var is_may to $3
                    set new var is_should to $4
                    
                    if var is_want do
                        set new var new_verb to get_verb with "want", var person
                        if var new_verb do
                            set from hash auxiliary_verbs_hash item { var new_verb } to 1
                        done
                    done
                    
                    if var is_must do
                        set new var new_verb to get_verb with "must", var person
                        if var new_verb do
                            set from hash auxiliary_verbs_hash item { var new_verb } to 1
                        done
                    done
                    
                    if var is_can do
                        set new var new_verb to get_verb with "can", var person
                        if var new_verb do
                            set from hash auxiliary_verbs_hash item { var new_verb } to 1
                        done
                    done
                    
                    if var is_may do
                        set new var new_verb to get_verb with "may", var person
                        if var new_verb do
                            set from hash auxiliary_verbs_hash item { var new_verb } to 1
                        done
                    done
                    
                    if var is_should do
                        set new var new_verb to get_verb with "should", var person
                        if var new_verb do
                            set from hash auxiliary_verbs_hash item { var new_verb } to 1
                        done
                    done
                    
                    do regex using var verb: /([01])([01])([01])([01])([01])$/, "", :global
                done
                
                if from global hash builtin_auxiliary_verbs item { var verb } do
                    set from hash auxiliary_verbs_hash item { var verb } to 1
                done
                else do
                    set from hash proper_verbs_hash item { var verb } to 1
                done
            done
            
            set new array auxiliary_verbs to an empty array
            set items of array auxiliary_verbs to keys with items of hash auxiliary_verbs_hash
            set new array proper_verbs to an empty array
            set items of array proper_verbs to keys with items of hash proper_verbs_hash
            set items of array proper_verbs to sort with items of array proper_verbs
            
            if from array clause item [3] matches /(^|\s)zu(\s|$)/ and length( from array clause item [3] ) < 5 do
                do unshift with items of array proper_verbs, "zu"
                do regex using from array clause item [3]: /(^|\s)zu(\s|$)/, "$0", :global
            done

            set from array clause item [1] to check_for_as_well_as with from array clause item [1], var lang, var path
            set from array clause item [2] to check_for_as_well_as with from array clause item [2], var lang, var path
            
            # TEXT
            # Build the final sentence.
            # CODE
            if from array proper_verbs first item and from array proper_verbs first item matches /^equal/ do
                set new var _no_user_ask to handle for file name "_no_user_ask", write
                do close with var _no_user_ask
                
                set new array subject_words to split with " ", from array clause item [1]
                set new array object_words to split with " ", from array clause item [2]
                set new var subject_last_word to from array subject_words item [ size of array subject_words - 1 ]
                set new var object_last_word to from array object_words item [ size of array object_words - 1 ]
                
                set new array subject_props to compute_tags with var subject_last_word, var lang, var path
                set new array object_props to compute_tags with var object_last_word, var lang, var path
                set new var subject_genus to from array subject_props second item
                set new var object_genus to from array  object_props second item
                set new var subject_person to get_person with from array clause item [1]
                
                set new var subject_article to ""
                set new var object_article to ""
                set new var is_male_name_subject to 0
                set new array male_names to global array builtin_male_names
                for each new var name in array male_names do
                    if lc(var name) matches lc(var subject_last_word) do
                        set var is_male_name_subject to 1
                    done
                done

                #if var verb matches /bi|is|bin|bist|ist|sind|seid|heisst|heisse|heissen|sei|war|wurde|wurden|werden|werde|wirst|wurdest|wurde|wuerdet|werdet/ do
                #done
                #else do
                #    set var subject_article to get_article with var subject_genus, "subject", "indefinite"
                #    set var object_article to get_article with var object_genus, "object", "indefinite"
                #done

                set var subject_article to get_article with var subject_genus, "subject", "indefinite"
                set var object_article to get_article with var object_genus, "subject", "indefinite"

                if from array proper_verbs first item matches /^equal_pl/ do
                    set var subject_person to "3p"
                done
                set new var verb to get_verb with "be", var subject_person
                
                if (not from array proper_verbs first item matches /^equal_pl/) and (not from array clause item [1] matches /\s|<[_]>|<[0-9]>/) and (not from array clause item [2] matches /ein/) and (not var is_male_name_subject) do
                    push into array sentence, var subject_article
                done
                push into array sentence, from array clause item [1]
                if not from array clause item [2] matches /ein|der|die|das|the|(a )/ do
                    if from array subject_props first item matches /^v/ do
                        set var verb to get_verb with "is-same-as", var subject_person
                        push into array sentence, var verb
                    done
                    else if from array clause item [2] matches /<[0-9]>/ do
                        set var verb to get_verb with "is-same-as", var subject_person
                        push into array sentence, var verb
                    done
                    else do
                        push into array sentence, var verb
                        push into array sentence, var object_article
                    done
                done
                else do
                    push into array sentence, var verb
                done
                push into array sentence, from array clause item [2]
                push into array sentence, from array clause item [3]
                
                if var final_sentence do
                    set var final_sentence to var final_sentence concat ', '
                done
                
                set var final_sentence to var final_sentence concat join ' ', items of array sentence
                
                do unlink with "_no_user_ask"
            done
            else if items of array auxiliary_verbs or items of array proper_verbs or from array clause item [1] do
                print "auxiliary verbs: "
                print items of array auxiliary_verbs
                print new line
                print "proper verbs: "
                print items of array proper_verbs
                print new line
                
                if not items of array auxiliary_verbs do
                    set items of array auxiliary_verbs to items of array proper_verbs
                    set array proper_verbs to an empty array
                done
                
                # TEXT
                # When there is a time period mentioned in the question, but not in the answer
                # CODE
                if from array clause item [3] not matches /time.(from|to)/ and from array clause item [2] not matches /time.(from|to)/ do
                    set new array input_adverbs to from hash parsed item { 'adverbs' }
                    for each new var _adverb in array input_adverbs do
                        set new var adverb to var _adverb
                        if lc(var adverb) matches /array/ do
                            set var adverb to from array adverb first item
                        done
                        
                        if lc(var adverb) matches /time_/ do
                            set array clause to add_undefined_time with array clause
                            
                            go to last
                        done
                    done
                done
                
                # TEXT
                # Replace *s
                # CODE
                if from array clause item [1] matches "*" do
                    if from array clause item [2] matches "*" do
                        if lc( hash parsed item { 'subjects' } first item ) matches /array/ do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item first item
                        done
                        else do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item
                        done
                    done
                    else do
                        if lc( hash parsed item { 'subjects' } first item ) matches /array/ do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item first item
                        done
                        else do
                            set from array clause item [1] to hash parsed item { 'subjects' } first item
                        done
                    done
                done
                if from array clause item [2] matches "*" do
                    if from array clause item [1] matches "*" do
                        if lc( hash parsed item { 'objects' } first item ) matches /array/ do
                            set from array clause item [2] to hash parsed item { 'objects' } first item first item
                        done
                        else do
                            set from array clause item [2] to hash parsed item { 'objects' } first item
                        done
                    done
                    else do
                        if lc( hash parsed item { 'subjects' } first item ) matches /array/ do
                            set from array clause item [2] to hash parsed item { 'subjects' } first item first item
                        done
                        else do
                            set from array clause item [2] to hash parsed item { 'subjects' } first item
                        done
                    done
                done
                
                if from array clause item [1] matches "_" do
                    set from array clause item [1] to noun_for_anonymous without arguments
                done
                
                if var final_sentence do
                    if from array clause item [4] do
                        if not from array clause item [4] matches /^da/ do
                            push into array sentence, from array clause item [4]
                        done
                    done
                done
                
                if from array clause item [3] matches /<[?]>/ do
                    if from array clause item [2] matches "NULL" or not from array clause item [2] do
                        if items of array proper_verbs do
                            push into array sentence, items of array auxiliary_verbs
                            push into array sentence, from array clause item [1]
                            push into array sentence, from array clause item [3]
                            push into array sentence, items of array proper_verbs
                        done
                        else do
                            if from array clause item [3] matches /.../ and from global hash builtin_time_place_adverbs item { from array clause item [3] } and not from array clause item [3] matches /\s/ do
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [3]
                                push into array sentence, from array clause item [1]
                            done
                            else do
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [1]
                                push into array sentence, from array clause item [3]
                            done
                        done
                    done
                    else if from array clause item [3] matches /von/ do
                        if items of array proper_verbs do
                            push into array sentence, items of array auxiliary_verbs
                            push into array sentence, from array clause item [1]
                            push into array sentence, from array clause item [2]
                            push into array sentence, from array clause item [3]
                            push into array sentence, items of array proper_verbs
                        done
                        else do
                            push into array sentence, items of array auxiliary_verbs
                            push into array sentence, from array clause item [1]
                            push into array sentence, from array clause item [2]
                            push into array sentence, from array clause item [3]
                        done
                    done
                    else do
                        if items of array proper_verbs do
                            if from global hash builtin_time_place_adverbs item { from array clause item [3] } do
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [1]
                                push into array sentence, from array clause item [3]
                                push into array sentence, from array clause item [2]
                                push into array sentence, items of array proper_verbs
                            done
                            else do
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [1]
                                push into array sentence, from array clause item [2]
                                push into array sentence, from array clause item [3]
                                push into array sentence, items of array proper_verbs
                            done
                        done
                        else do
                            if from array clause item [3] matches /zu / do
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [1]
                                push into array sentence, from array clause item [3]
                                push into array sentence, from array clause item [2]
                                push into array sentence, items of array proper_verbs
                            done
                            else do
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [1]
                                push into array sentence, from array clause item [2]
                                push into array sentence, from array clause item [3]
                                push into array sentence, items of array proper_verbs
                            done
                        done
                    done
                done
                else do
                    if from array clause item [2] matches "NULL" or not from array clause item [2] do
                        if items of array proper_verbs do
                            push into array sentence, from array clause item [1]
                            push into array sentence, items of array auxiliary_verbs
                            push into array sentence, from array clause item [3]
                            push into array sentence, items of array proper_verbs
                        done
                        else do
                            if from array clause item [3] matches /.../ and from global hash builtin_time_place_adverbs item { from array clause item [3] } and not from array clause item [3] matches /\s|(nicht)/ do
                                push into array sentence, from array clause item [3]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [1]
                            done
                            else do
                                push into array sentence, from array clause item [1]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [3]
                            done
                        done
                    done
                    else if from array clause item [3] matches /von/ do
                        if items of array proper_verbs do
                            push into array sentence, from array clause item [1]
                            push into array sentence, items of array auxiliary_verbs
                            push into array sentence, from array clause item [2]
                            push into array sentence, from array clause item [3]
                            push into array sentence, items of array proper_verbs
                        done
                        else do
                            push into array sentence, from array clause item [1]
                            push into array sentence, items of array auxiliary_verbs
                            push into array sentence, from array clause item [2]
                            push into array sentence, from array clause item [3]
                        done
                    done
                    else do
                        if items of array proper_verbs do
                            if from global hash builtin_time_place_adverbs item { from array clause item [3] } do
                                push into array sentence, from array clause item [1]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [3]
                                push into array sentence, from array clause item [2]
                                push into array sentence, items of array proper_verbs
                            done
                            else do
                                push into array sentence, from array clause item [1]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [2]
                                push into array sentence, from array clause item [3]
                                push into array sentence, items of array proper_verbs
                            done
                        done
                        else do
                            if from array clause item [3] matches /zu / do
                                push into array sentence, from array clause item [1]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [3]
                                push into array sentence, from array clause item [2]
                                push into array sentence, items of array proper_verbs
                            done
                            else if from global hash builtin_time_place_adverbs item { from array clause item [3] } do
                                push into array sentence, from array clause item [1]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [3]
                                push into array sentence, from array clause item [2]
                                push into array sentence, items of array proper_verbs
                            done
                            else do
                                push into array sentence, from array clause item [1]
                                push into array sentence, items of array auxiliary_verbs
                                push into array sentence, from array clause item [2]
                                push into array sentence, from array clause item [3]
                                push into array sentence, items of array proper_verbs
                            done
                        done
                    done
                done
                
                if ( join ' ', items of array sentence ) matches /50/ do
                    go to next
                done
                
                if var final_sentence do
                    if from array clause item [4] do
                        if from array clause item [4] matches /^da/ do
                            push into array sentence, from array clause item [4]
                        done
                    done
                done
                
                if var final_sentence do
                    set var final_sentence to var final_sentence concat ', '
                done
                
                set var final_sentence to var final_sentence concat join ' ', items of array sentence
            done
        done
        
        do regex using var final_sentence: /<[,]>\s*?$/, "", :global
        do regex using var final_sentence: /<[,]>$/, "", :global
        
        if not var final_sentence matches /time.(from|to)/ do
            set new array input_adverbs to from hash parsed item { 'adverbs' }
            for each new var _adverb in array input_adverbs do
                set new var adverb to var _adverb
                if lc(var adverb) matches /array/ do
                    set var adverb to from array adverb first item
                done
                
                if lc(var adverb) matches /time_/ do
                    set var final_sentence to var final_sentence concat " ~" concat var adverb
                done
            done
        done

        if var final_sentence matches / dacht/ and not var final_sentence matches /<[,]>/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches /<[,]> 50/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches /anyone/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches /reasonof/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches /[>][>][>]/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if lc(var final_sentence) matches / (ist|sind|sein|equal.?.?.?) (ein.?.?)? (name|eigenname)/ do
            # TEXT
            # A Sentence must not end with e.g. dachte
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches / <[=]>/ do
            # TEXT
            # A Sentence must not have the verb "="
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches / opposite / do
            # TEXT
            # A Sentence must not have the verb "="
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if var final_sentence matches /\(good|bad\)/ do
            # TEXT
            # A Sentence must not have the verb "="
            # CODE
            set var final_sentence to compute_output with var final_sentence
            print "Invalid sentence: "
            print var final_sentence
            print new line
            go to next
        done
        
        if ( var final_sentence matches /\s(bin|bist|kannst|darfst|musst)\s/ or var final_sentence matches /(iere|ierst) / ) and ( from hash parsed item { 'verbs' } first item matches "ist" or from hash parsed item { 'verbs' } first item first item matches "ist" ) do
            print "Cannot answer bin/bist when it has been asked for ist:"
            print new line
            print var final_sentence
            print new line
            
            go to next
        done
        
        set var final_sentence to compute_output with var final_sentence
        
        if var final_sentence matches /<[?]>/ do
            do regex using var final_sentence: /<[?]>/, "", :global
            set var final_sentence to var final_sentence concat "?"
        done
        
        do regex using var final_sentence: /<[,]>\s*?$/, "", :global
        do regex using var final_sentence: /<[,]>$/, "", :global
        
        push into array phrases, [ var primary_key, var final_sentence ]
    done
    
    do return using array phrases
done

define action filter_nothing with var text do
    if var text matches /nothing/ do
        do return with ""
    done
    do regex using var text: /\/.*?$/, "", :global:i
    do return with var text
done

define action to_array_from_pro_line with var line, var lang do
    set new array results to an empty array
    set new array result to an empty array
    push into array result, an empty array

    do regex using var line: / [<][>] /, "<>", :global
    set new array parts to split with /[<][>]/, var line
    do pop with items of array parts
    
    set new array clause to an empty array
    push into array clause, filter_nothing(from array parts first item)
    push into array clause, filter_nothing(from array parts second item)
    push into array clause, filter_nothing(from array parts item [ 2 ])
    push into array clause, filter_nothing(from array parts item [ 3 ])
    push into array result, array clause
    
    set new var i to 4
    while var i < 100 do
        set new array clause to an empty array
        push into array clause, filter_nothing(from array parts item [ var i + 0 ])
        push into array clause, filter_nothing(from array parts item [ var i + 1 ])
        push into array clause, filter_nothing(from array parts item [ var i + 2 ])
        push into array clause, filter_nothing(from array parts item [ var i + 3 ])
        push into array clause, filter_nothing(from array parts item [ var i + 4 ])
        
        set var i to var i + 5
        
        if from array clause first item matches 50 do
            go to next
        done
        if from array clause first item matches 100 do
            go to next
        done
        push into array result, array clause
    done
    
    push into array results, array result
    
    do return with array results
done

define action post_phrase with var lang, var path, var mode, hash parsed, array output do
    set new var primary_key to shift with items of array output
    
    set new var final_sentence to from array output first item

    # TEXT
    # Add linked sentences...
    # CODE
    if var primary_key do
        # TEXT
        # After the sentence.
        # CODE
        set new hash hash_link_order to an empty hash
        set from hash hash_link_order item { 'primary_key' } to var primary_key
        set new array results_link_order to logic with '', var lang, var path, hash hash_link_order
        if array results_link_order matches "TOOMUCH" do
            do return with var final_sentence
        done
        for each new array result_link_order in array results_link_order do
            set from array result_link_order first item to ''
        done
        set array results_link_order to phrase with var lang, var path, var mode, array results_link_order, hash parsed
        set new var i_random to rand with items of array results_link_order
        set new var result_link_order to from array results_link_order item [ var i_random ]
        if var result_link_order do
            set var final_sentence to var final_sentence concat ". " concat var result_link_order
        done

        # TEXT
        # Before the sentence.
        # CODE
        set new hash hash_link_order to an empty hash
        set from hash hash_link_order item { 'primary_key' } to 0 - var primary_key
        set new array results_link_order to logic with '', var lang, var path, hash hash_link_order
        if array results_link_order matches "TOOMUCH" do
            do return with var final_sentence
        done
        for each new array result_link_order in array results_link_order do
            set from array result_link_order first item to ''
        done
        set array results_link_order to phrase with var lang, var path, var mode, array results_link_order, hash parsed
        set new var i_random to rand with items of array results_link_order
        set new var result_link_order to from array results_link_order item [ var i_random ]
        if var result_link_order do
            set var final_sentence to var result_link_order concat ". " concat var final_sentence
        done
    done

    do return with var final_sentence
done

define action use_mode with var input is copy, array facts_to_save, hash tags, var lang, var path, var mode do
    set new var is_question to "no"
    if var input matches /<[?]>/ do
        set var is_question to "yes"
    done
    do regex using var input: /(<[.!?]>)/, "", :global
    
    set new var save_input to "no"
    if var mode matches "statement" do
        set var save_input to "yes"
    done
    if var mode matches "learn" do
        set var save_input to "yes"
    done
    if lc(var input) matches /^\/save / do
        do regex using var input: /^\/save /, "", :global:i
        set var save_input to "yes"
    done
    
    # TEXT
    # First we try some methods for finding out an answer without logic.
    # CODE
    set new flag is_a_greeting to check_for_greeting using var input
    if flag is_a_greeting do
        set new var greeting to greet with ''
        do return with [ var greeting ]
    done
    set new flag is_a_thanks to check_for_thanks using var input
    if flag is_a_thanks do
        set new var thanks to say_answer_thanks with ''
        do return with [ var thanks ]
    done
    set new flag is_math to check_for_math using var input
    if flag is_math do
        do return with [ flag is_math ]
    done
    set new var appname to check_invoke using var input
    if var appname do
        set new var answer to invoke with var appname
        do return with [ var answer ]
    done
    set new var place to check_sentence_for_weather with var input
    if var place do
        do check_for_weather with var place, var lang, var path
    done

    # TEXT
    # No unlogical answers? Make the komma's readable.
    # CODE
    set var input to make_parsable with var input
    do regex using var input: /<[,]>\s/, " KOMMA ", :global:i
    do regex using var input: /(\D)<[.]>/, "${1} DOT ", :global:i
    do regex using var input: /\s+/, " ", :global:i
    print "Parsable sentence(s): "
    print var input
    print new line
    
    set new hash genus_of to an empty hash

    set new array clauses_input to split with " KOMMA ", var input
    set new hash parsed to an empty hash
    for each new var clause in array clauses_input do
        # TEXT
        # Split the sentence.
        # CODE
        set new array list_of_words to split with " ", var clause
        
        # TEXT
        # Then compute the parts of speech etc.
        # CODE
        for each new var word in array list_of_words is rw do
            set from hash tags item { var word } to compute_tags with var word, var lang, var path
            set from hash genus_of item { lc(var word) } to from hash tags item { var word } first item
        end for
        
        set new array list_of_list_of_words to pre_parse with array list_of_words, hash tags, var lang, var path
        
        for each new array words in array list_of_list_of_words is rw do
            # TEXT
            # Then toggle the identities (user <-> machine).
            # CODE
            if is an empty hash parsed do
                set hash parsed to parse with var lang, array words, hash tags
                set new array entities to an empty array
                push into array entities, items of that array: from hash parsed item { 'subjects' } end items of
                push into array entities, items of that array: from hash parsed item { 'objects' } end items of
                set from hash parsed item { 'verbs' } to toggle_verbs using from hash parsed item { 'verbs' }, array entities
                set from hash parsed item { 'subjects' } to toggle_entities using from hash parsed item { 'subjects' }
                set from hash parsed item { 'objects' } to toggle_entities using from hash parsed item { 'objects' }
                set from hash parsed item { 'adverbs' } to toggle_entities using from hash parsed item { 'adverbs' }
                set from hash parsed item { 'extra' } to toggle_entities using from hash parsed item { 'extra' }
                set from hash parsed item { 'clauses' } to an empty array
            done
            else do
                set new hash parsed_clause to parse with var lang, array words, hash tags
                set new array entities to an empty array
                push into array entities, items of that array: from hash parsed_clause item { 'subjects' } end items of
                push into array entities, items of that array: from hash parsed_clause item { 'objects' } end items of
                set from hash parsed_clause item { 'verbs' } to toggle_verbs using from hash parsed_clause item { 'verbs' }, array entities
                set from hash parsed_clause item { 'subjects' } to toggle_entities using from hash parsed_clause item { 'subjects' }
                set from hash parsed_clause item { 'objects' } to toggle_entities using from hash parsed_clause item { 'objects' }
                set from hash parsed_clause item { 'adverbs' } to toggle_entities using from hash parsed_clause item { 'adverbs' }
                set from hash parsed_clause item { 'extra' } to toggle_entities using from hash parsed_clause item { 'extra' }
                set from hash parsed_clause item { 'clauses' } to an empty array
                push into that array: from hash parsed item { 'clauses' } end-items-of, hash parsed_clause
            done
        done
    done
    
    # TEXT
    # Save male and female substantives
    # CODE
    set new array copy_subjects to from hash parsed item { 'subjects' }
    set new var genus_subject to 'q'
    set new var subject to ''
    set new var male_names to global array builtin_male_names
    for each new array arr in array copy_subjects do
        if var subject do
            set var subject to var subject concat ' '
        done
        set var subject to var subject concat join " ", items of array arr
        
        if from hash genus_of item { lc(join " ", items of array arr) } matches /m|f/ do
            set var genus_subject to from hash genus_of item { lc(join " ", items of array arr) }
        done
        for each new var male_name in array male_names do
            if var male_name matches lc(join " ", items of array arr) do
                set var genus_subject to 'm'
            done
        done
    done

    set new array copy_objects to from hash parsed item { 'objects' }
    set new var genus_object to 'q'
    set new var object to ''
    for each new array arr in array copy_objects do
        if var object do
            set var object to var object concat ' '
        done
        set var object to var object concat join " ", items of array arr
        
        if from hash genus_of item { lc(join " ", items of array arr) } matches /m|f/ do
            set var genus_object to from hash genus_of item { lc(join " ", items of array arr) }
        done
        for each new var male_name in array male_names do
            if var male_name matches lc(join " ", items of array arr) do
                set var genus_subject to 'm'
            done
        done
    done
    
    print "genus of subject: ", var genus_subject, new line
    print "genus of object:  ", var genus_object,  new line
    
    if var subject matches /^(er|sie|es|ihn|ihm|ihr)$/ do
        set var subject to ''
    done
    if var object matches /^(er|sie|es|ihn|ihm|ihr)$/ do
        set var object to ''
    done
    
    set new var male_file to handle for file name var path concat '/lang_' concat var lang concat '/male.history', append
    if var genus_subject matches "m" and var subject do
        print into var male_file data var subject
        print into var male_file data new line
    done
    if var genus_object matches "m" and var object do
        print into var male_file data var object
        print into var male_file data new line
    done
    do close with var male_file
    
    set new var female_file to handle for file name var path concat '/lang_' concat var lang concat '/female.history', append
    if var genus_subject matches "f" and var subject do
        print into var female_file data var subject
        print into var female_file data new line
    done
    if var genus_object matches "f" and var object do
        print into var female_file data var object
        print into var female_file data new line
    done
    do close with var female_file

    # TEXT
    # Go on.
    # CODE
    set new array results to an empty array

    # TEXT
    # Then use logic.
    # CODE
    if var mode matches "question" do
        set array results to logic with var input, var lang, var path, hash parsed
        if array results matches "TOOMUCH" do
            set new array standard_phrases to phrases_error_toomuch without arguments
            do return with array standard_phrases
        done
        
        set new flag bug_feature to but_feature_is_useful with var input
        if flag bug_feature do
            set array results to use_bug_feature with array results, hash parsed
        done
        if not items of array results do
            set new array results_reasonof to reasonof with var input, var lang, var path, hash parsed
            if items of array results_reasonof do
                push into array results, items of array results_reasonof
            done
        done
    done
    if var mode matches "statement" do
        set array results to logic with var input, var lang, var path, hash parsed
        set new array results_reasonof to reasonof with var input, var lang, var path, hash parsed
        if items of array results_reasonof do
            push into array results, items of array results_reasonof
        done
        if array results matches "TOOMUCH" do
            set new array standard_phrases to phrases_error_toomuch without arguments
            do return with array standard_phrases
        done
    done
    if var save_input matches "yes" do
        push into array facts_to_save, hash parsed
        
        # TEXT
        # Grab the primary key of the fact
        # CODE
        ##set new var key_file to hndle for file name "_input_key", read
        ##set new var key to the next line from var key_file
        ##do close with var key_file
        
        ##push into array facts_to_link, var key
    done
    set array results to sort_out with array results, var mode, hash parsed
    set new array phrases to phrase with var lang, var path, var mode, array results, hash parsed
    
    do return with array phrases
done

define action sort_out with array results, var mode, hash parsed do
    set new array results_proper to an empty array
    set new array results_variable_answer to an empty array
    set new array results_important to an empty array

    for each new array result in array results do
        set new var primary_key to shift with items of array result
        
        for each new array clause in array result do
            if lc( from array clause item [1] ) matches /(00000)/ do
                go to next
            done
            if lc( from array clause item [2] ) matches /(00000)/ do
                go to next
            done
            if lc( from array clause item [1] ) matches /(50|0\.0|1\.0|100)/ and length( from array clause item [1] ) < 5 do
                go to next
            done
            if lc( from array clause item [2] ) matches /(50|0\.0|1\.0|100)/ and length( from array clause item [2] ) < 5 do
                go to next
            done
            if lc( from array clause item [3] ) matches /(50|0\.0|1\.0|100)/ and length( from array clause item [3] ) < 5 do
                go to next
            done
        done
    
        set new flag is_proper to 1
        set new flag is_important to 0
        for each new array clause in array result do
            set new array sentence to an empty array

            # TEXT
            # Look at the verbs. Do they contain "=>"? Verbs with "=>" would only be used if no other verbs are there.
            # CODE
            set new array raw_verbs to [ split ' ', from array clause item [0] ]
            set new var symbol to "=>"
            for each new var verb in array raw_verbs do
                if var verb matches /var symbol/ do
                    set flag is_proper to 0
                done
            done
            
            if lc( from array clause item [2] ) matches /freehal/ do
                if lc( from hash parsed item { 'questionword' } first item first item ) matches /wer|who/ do
                    set flag is_important to 1
                done
            done
        done
        
        do unshift with items of array result, var primary_key
        
        # TEXT
        # It is an important fact, for example "I am FreeHAL", because it contains "freehal"
        if flag is_important do
            push into array results_important, array result
        done
        
        # TEXT
        # Result is a proper result.
        # CODE
        if flag is_proper do
            push into array results_proper, array result
        done
        # TEXT
        # Result is no proper result.
        # CODE
        else do
            push into array results_variable_answer, array result
        done
    done
    
    set new array questionword_array to from hash parsed item { 'questionword' } first item
    # TEXT
    # First, prefer important answers
    # CODE
    if is not an empty array results_important do
        print "There are important sentences."
        print new line
        return array results_important
    done
    else do
        print "There are not any important sentences."
        print new line
    done
    # TEXT
    # If there is no questionword, prefer proper answers
    # CODE
    if not from array questionword_array first item do
        if is an empty array results_variable_answer or (items of array results_variable_answer)+50 < (items of array results_proper) do
            print "-> results_proper (1): " concat items of array results_proper concat " <-> " concat items of array results_variable_answer concat " = " concat items of array results
            print new line
            do return with array results_proper
        done
        else do
            print "-> results_variable_answer (2): " concat items of array results_variable_answer concat " <-> " concat items of array results_proper concat " = " concat items of array results
            print new line
            do return with array results_variable_answer
        done
    done
    else do
        if is an empty array results_proper do
            print "-> results_variable_answer (1): " concat items of array results_variable_answer concat " <-> " concat items of array results_proper concat " = " concat items of array results
            print new line
            do return with array results_variable_answer
        done
        else do
            print "-> results_proper (2): " concat items of array results_proper concat " <-> " concat items of array results_variable_answer concat " = " concat items of array results
            print new line
            do return with array results_proper
        done
    done
done

define action save_facts with array facts_parsed, hash tags, var pro_file_name, var prepend, flag no_reread, var lang, var path do

    if not var pro_file_name do
        set var pro_file_name to var path concat '/lang_' concat var lang concat '/facts.pro'
    done

    set new array line_array to an empty array

    for each new hash parsed in array facts_parsed do
        set new var line to ''
        set new var truth to "(maybe)"
        
        set new array verbs to from hash parsed item { 'verbs' }
        for each new array verb in array verbs do
            set var verb to from array verb first item
            
            set new var verb_category to verb_category with var verb
            if var verb_category do
                set var verb to var verb concat "/" concat var verb_category
            done
            
            if var verb matches /opposite/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/opposite.pro'
            done
            
            if var verb matches /reasonof/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/beziehungen.pro'
            done
        done
        set new array subjects to from hash parsed item { 'subjects' }
        for each new array subject in array subjects do
            set var subject to from array subject first item
        done
        set new array objects to from hash parsed item { 'objects' }
        set new array adverbs to from hash parsed item { 'adverbs' }
        set new flag clear_all_objects to 0
        for each new array object in array objects do
            if flag clear_all_objects do
                set var object to ''
                go to next
            done
            if from array object first item matches /^(nicht|not)$/ do
                set new array temp to an empty array
                push into array temp, from array object first item
                push into array adverbs, array temp
                set var object to ''
                go to next
            done
            
            if from array object first item matches /^.?\(true\).?$/ do
                set var truth to "(true)"
                set var object to ''
                go to next
            done
            if from array object first item matches /^.?\(maybe\).?$/ do
                set var truth to "(maybe)"
                set var object to ''
                go to next
            done
            if from array object first item matches /^.?\(false\).?$/ do
                set var truth to "(false)"
                set var object to ''
                go to next
            done
            
            if from array object first item matches /^.?\(bad\).?$/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/ps_dateien/ps-bad.pro'
            done
            if from array object first item matches /^.?\(good\).?$/ do
                set var pro_file_name to var path concat '/lang_' concat var lang concat '/ps_dateien/ps-good.pro'
            done
            
            set var object to from array object first item
            
            if from array verbs first item matches "~~~" do
                if from hash tags item { var object } and from hash sym_noun item { from hash tags item { var object } first item } do
                    set flag clear_all_objects to 1
                done
            done
        done
        for each new array adverb in array adverbs do
            if from array adverb first item matches /^.?\(true\).?$/ do
                set var truth to "(true)"
                set var adverb to ''
                go to next
            done
            if from array adverb first item matches /^.?\(maybe\).?$/ do
                set var truth to "(maybe)"
                set var adverb to ''
                go to next
            done
            if from array adverb first item matches /^.?\(false\).?$/ do
                set var truth to "(false)"
                set var adverb to ''
                go to next
            done
            
            if from array adverb first item matches /^.?\(logic\).?$/ do
                set var adverb to '(logic)'
                go to next
            done
            
            set var adverb to from array adverb first item
        done
        
        # TEXT
        # Replace ~~~ with =
        # CODE
        if from array verbs first item matches "~~~" do
            set from array verbs to an empty array
            set from array verbs first item to "="
            set from hash parsed item { 'verbs' } to array verbs
        done
        
        # TEXT
        # Delete all other verbs if there is a "="
        # CODE
        if from array verbs first item matches "=" do
            set from array verbs to an empty array
            set from array verbs first item to "="
            set from hash parsed item { 'verbs' } to array verbs
            
            set new var adverbs to join using ' ', items of that array: from hash parsed item { 'adverbs' } end-items-of
            if not var adverbs matches /^\s*?(in|von)\s+?...?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?$/ do
                set from hash parsed item { 'adverbs' } to an empty array
            done
        done

#        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'verbs' } end-items-of
        set var line to var line concat join using ' ', items of array verbs
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'subjects' } end-items-of
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'objects' } end-items-of
        set var line to var line concat ' <> '
        set var line to var line concat join using ' ', items of that array: from hash parsed item { 'adverbs' } end-items-of
        
        if not from hash parsed item { 'clauses' } do
            set from hash parsed item { 'clauses' } to an empty array
            set new hash empty_clause to an empty hash
            set from hash empty_clause item { 'verbs' } to an empty array
            set from hash empty_clause item { 'subjects' } to an empty array
            set from hash empty_clause item { 'objects' } to an empty array
            set from hash empty_clause item { 'adverbs' } to an empty array
            set from hash empty_clause item { 'questionword' } to an empty array
            do push items of that array: from hash parsed item { 'clauses' } end-items-of, hash empty_clause
        done
        
        if that array is empty: from hash parsed item { 'verbs' } end check and that array is empty: from hash parsed item { 'clauses' } end check do
            go to next
        done
        
        set new array clauses to from hash parsed item { 'clauses' }
        
        set new var number_of_clauses to 0
        for each new hash parsed in array clauses is rw do
            if var number_of_clauses do
                # TEXT
                # We can only add one ; per line because it's a keyword in hal2009 language
                # CODE
                set var line to var line concat ' ;'
                set var line to var line concat '; '
            done
            else do
                set var line to var line concat ' <> '
            done
        
            set new array verbs to from hash parsed item { 'verbs' }
            for each new array verb in array verbs do
                set var verb to from array verb first item
            done
            set new array subjects to from hash parsed item { 'subjects' }
            for each new array subject in array subjects do
                set var subject to from array subject first item
            done
            set new array objects to from hash parsed item { 'objects' }
            for each new array object in array objects do
                set var object to from array object first item
            done
            set new array adverbs to from hash parsed item { 'adverbs' }
            for each new array adverb in array adverbs do
                set var adverb to from array adverb first item
            done
            if not from hash parsed item { 'questionword' } do
                set from hash parsed item { 'questionword' } to an empty array
            done
            set new array questionwords to from hash parsed item { 'questionword' }
            for each new array questionword in array questionwords do
                set var questionword to from array questionword first item
            done
            
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'verbs' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'subjects' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'objects' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'adverbs' } end-items-of
            set var line to var line concat ' <> '
            set var line to var line concat join using ' ', items of that array: from hash parsed item { 'questionword' } end-items-of
            
            set var number_of_clauses to var number_of_clauses + 1
        done
        set var line to var line concat ' <> '
        set var line to var line concat var truth
        
        push into array line_array, var line
    done
    
    set new var divisor to ' ~ '
    set new var line to join with var divisor, items of array line_array
    
    do regex using var line: /<[_]>+/, "_", :global
    
    if var pro_file_name matches "-" do
        print "Do not write any facts."
        print new line
    done
    else do
        set new var pro_file to handle for file name var pro_file_name, append
        print "Write some facts into " concat var pro_file_name concat "."
        print new line

        if var line do
            print into var pro_file data var prepend
            print into var pro_file data lc(var line)
            print into var pro_file data new line
        done
        
        do close with var pro_file
        
        if not flag no_reread do
            do reread_pro_file with var pro_file_name, var lang
        done
    done
    
    do return with var line
done

define action update_list_of_pro_file with var file, var lang, var path do
    set new var input_pro to handle for file name var file, read
    set new var file_output to var file
    do regex using var file_output: /.pro/, ".list", :global
    set new var output_list to handle for file name var file_output, write
    do close with output_list
    
    for each new var line from var input_pro do
        set new array results to to_array_from_pro_line with var line, var lang
        set new hash parsed to fake_hash_parsed without arguments
        set new array output_array to phrase with var lang, var path, "default", array results, hash parsed
        
        for each new array output_line in array output_array do
            if from array output_line second item do
                set new var output_list to handle for file name var file_output, append
                
                set new hash tags to an empty hash
                
                set new var final_output to upper_case_correction with from array output_line second item, hash tags, var lang, var path
                print into var output_list data var final_output
                print into var output_list data new line
                
                do close with output_list
            done
        done
    done
done

define action reread_pro_file with var file, var lang do
    if exists: "SLOW", end test do
        print "Don't read a .pro file in SLOW mode."
        print new line
        do return with 1
    done
    # TEXT
    # Write the signal file for re-reading
    # CODE
    set new var output_handle to handle for file name "_output__add_pro_file", write
    print into var output_handle data var file
    do close with var output_handle
done

define action execute_exe with var appname do
    set var appname to lc with var appname
    
    do regex using var appname: /<[-,+!?=]>/, "", :global

    set new flag is_unix to system with "uname"
    if not flag is_unix do
        # TEXT
        # A Linux/Unix system
        # CODE
        
        
        if exists: var appname, end test do
            do system with var appname concat " &"
        done
        else do
            set new flag is_in_path to system with "which " concat var appname
            if not flag is_in_path do
                do system with "bash -c '" concat `which var appname ` concat " &'"
            done
        done
    done
    else do
        # TEXT
        # No Unix, probably Windows
        # CODE
        
        set new flag is_in_path to system with var appname
        
        if 1 do

            set new var disk to "C:/"
            do opendir with new var dir_handle, var disk
            set new array files to [ readdir(var dir_handle) ]
            # TEXT
            # Search for Windows programs
            # CODE
            for each new var file_name in array files is rw do
                print var file_name
                print new line
                if not lc(var file_name) matches /^pro/ do
                    go to next
                done
                do opendir with new var dir_handle, var disk concat "/" concat var file_name
                set new array files to [ readdir(var dir_handle) ]
                for each new var sub_file_name in array files is rw do
                    print var sub_file_name
                    print new line
                    if not lc(var sub_file_name) matches /var appname/ do
                        go to next
                    done
                    do opendir with new var dir_handle, var disk concat "/" concat var file_name concat "/" concat var sub_file_name
                    set new array files to [ readdir(var dir_handle) ]
                    for each new var sub_sub_file_name in array files is rw do
                        print var sub_sub_file_name
                        print new line
                        if not lc(var sub_sub_file_name) matches /exe$/ do
                            go to next
                        done
                        do system with var disk concat "/" concat var file_name concat "/" concat var sub_file_name concat "/" concat var sub_sub_file_name
                    done
                    do closedir with var dir_handle
                done
                do closedir with var dir_handle
            done
            do closedir with var dir_handle
        done
        
    done
    
    do return with var appname
done

define action invoke with var appname do
    set new var answer_success to var appname concat "..."
    
    set new var exe to execute_exe with var appname
    print var exe
    print new line
    if var @ do
        print var @
        print new line
    done
    
    do return with var answer_success
done

define action make_ascii with var text is rw do
    do return with var text
done

define action modify_input with var input, var current_language, var path do
    if length(var input) < 10 and var input matches /warum/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', read
        set new var last_output to ''
        for each new var line from var input_handle do
            set var last_output to var line
        done
        
        if var last_output do
            set var input to "warum " concat var last_output concat "?"
        done
    done
    if length(var input) < 15 and var input matches /warum das/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', read
        set new var last_output to ''
        for each new var line from var input_handle do
            set var last_output to var line
        done
        
        if var last_output do
            set var input to "warum " concat var last_output
        done
    done
    if lc(var input) matches /(^|\s)dessen(\s|$)/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', read
        set new var last_output to ''
        for each new var line from var input_handle do
            if var line matches /\s/ do
                if length(var line) >= 10 do
                    if not var line matches /<[,]>/ do
                        set var last_output to var line
                    done
                done
            done
        done
        
        if var last_output do
            do regex using var input: /(^|\s)dessen(\s|$)/, "$0$1", :global:i
            do regex using var input: /(<[?!.]>|$)/, ", dass var last_output$0", :i
        done
    done
    if var input matches /^weil/ do
        set new var input_handle to handle for file name var path concat '/lang_' concat var current_language concat '/input.history', read
        set new var last_input to ''
        for each new var line from var input_handle do
            set var last_input to var line
        done
        
        if var last_input do
            set var input to var last_input concat " " concat var input
        done
    done
    
    return var input
done

define action save_input with var input, var current_language, var path do
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/input.history', append
    print into var output_handle data var input concat new line
    do close with var output_handle
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/dialog.history', append
    print into var output_handle data "input: " concat var input concat new line
    do close with var output_handle
done

define action save_output with var input, var current_language, var path do
    do regex using var input: /\(.*/, "", :global
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/output.history', append
    set new array outputs to split with /([<]br[>].*?\s)/, var input
    for each new var output in array outputs do
        if not var output matches /[<]br[>]/ do
            print into var output_handle data var output concat new line
        done
    done
    do close with var output_handle
    set new var output_handle to handle for file name var path concat '/lang_' concat var current_language concat '/dialog.history', append
    print into var output_handle data "output: " concat var input concat new line
    do close with var output_handle
done

define action give_output with var input is rw, var only_learn, array facts_to_save, hash tags, var current_language, var path do
    # TEXT
    # We try to use the answer as a judgement
    # CODE
    set new array score to check_score using var input
    if from array score second item do
        if from array score first item do
            do set_score_for_num with from array score second item, from array score first item, var current_language, var path
        done
        else do
            do set_score_for_last with from array score second item, var current_language, var path
        done

        set new var answer to get_score_answer without arguments
        do return with [ var answer ]
    done
    
    set array score to check_score_command using var input, var current_language, var path
    if array score and from array score first item do
        do set_score with from array score second item, from array score third item, from array score first item, var current_language, var path

        set new var answer to get_score_answer without arguments
        do return with [ var answer ]
    done

    set (var input, new var no_change_pronouns) to compute_input with var input, var current_language, var path
    if not var input do
        do return with an empty array
    done

    print "Got input:          "
    print var input
    print new line
    set var input to modify_input with var input, var current_language, var path
    do save_input with var input, var current_language, var path
    print "Transformed (?) to: "
    print var input
    print new line
    
    print "Input is computed... Going on."
    print new line
    set new var mode to find_mode using var input, var only_learn, var current_language, var path
    set new array sentences to use_mode with var input, array facts_to_save, hash tags, var current_language, var path, var mode
    print "Output is..."
    print new line
    for each new array sentence in array sentences do
        if from array sentence second item do
            print "    - "
            print from array sentence second item
            print new line
        done
    done
    
    # TEXT
    # Flow chart log
    # CODE
    set new var num to items of array sentences
    set var num to var num + 1
    set new var flowchart_log to handle for file name var path concat '/flowchart.log', append
    print into var flowchart_log data "begin box"
    print into var flowchart_log data new line
    print into var flowchart_log data "bckgrndcolr FFD0BB"
    print into var flowchart_log data new line
    print into var flowchart_log data "bordercolor FFD0BB"
    print into var flowchart_log data new line
    print into var flowchart_log data "linesoftext " concat var num
    print into var flowchart_log data new line
    print into var flowchart_log data "draw"
    print into var flowchart_log data new line
    print into var flowchart_log data "textcontent 000000 Answers:"
    print into var flowchart_log data new line
    set new hash primary_keys to an empty hash
    for each new array sentence in array sentences do
        if from array sentence second item do
            if ( not from array sentence first item ) or ( not from hash primary_keys item { from array sentence first item } ) do
            
                print into var flowchart_log data "linkcontent 000000 \t - " concat from array sentence first item concat ": " concat from array sentence second item
                print into var flowchart_log data new line
                print into var flowchart_log data "property    pk     " concat from array sentence first item
                print into var flowchart_log data new line
                
                set from hash primary_keys item { from array sentence first item } to 1
                
            done
        done
        else do
            print into var flowchart_log data "textcontent 000000 \t - (invalid)"
            print into var flowchart_log data new line
        done
    done
    print into var flowchart_log data "end box"
    print into var flowchart_log data new line
    do close with var flowchart_log
    

    if is an empty array sentences do
        print "Well, no logic answer available."
        print new line
        set new array random to use_random with var input, var current_language, var path, var mode
        push into array sentences, items of array random
    done
    
    ##print "Primary keys are:"
    ##print new line
    ##for each new var key in array facts_to_link do
    ##    print "  - "
    ##    print var key
    ##    print new line
    ##done
    
    do return using array sentences
done

define action fake_hash_parsed without arguments do
    set new hash parsed to an empty hash
    set from hash parsed item { 'verbs' } to an empty array
    set from hash parsed item { 'subjects' } to an empty array
    set from hash parsed item { 'objects' } to an empty array
    set from hash parsed item { 'clauses' } to an empty array
    set from hash parsed item { 'adverbs' } to an empty array
    set from hash parsed item { 'questionword' } to an empty array
    do return with hash parsed
done

define action work_prot_line with var input, var file_name, var lang, var path do

    set new var classification to ''
    if var input matches /^(\S+?[:][:])/ do
        set var classification to $0
        do regex using var input: /^(\S+?)[:][:]/, "", :global
    done

    do be_slow without arguments
    do regex using var input: /(<[.!?]>)/, "", :global
    # TEXT
    # Make the komma's readable.
    # CODE
    set (var input, new var no_change_pronouns) to compute_input with var input, var lang, var path
    set var input to make_parsable with var input
    
    do regex using var input: /(\s|^)(wie|wer|was|wo|wann|warum|wieso|weshalb|who|how|where|when|if|what) /, "$0 _$1_ _no-question_ ", :global:i
    do regex using var input: /<[,]>\s/, " KOMMA ", :global:i
    do regex using var input: /(\D)<[.]>/, "${1} DOT ", :global:i
    do regex using var input: /\s+/, " ", :global:i
    set new array clauses_input to split with " KOMMA ", var input
    set new hash parsed to an empty hash
    set from hash parsed item { 'verbs' } to an empty array
    set from hash parsed item { 'subjects' } to an empty array
    set from hash parsed item { 'objects' } to an empty array
    set from hash parsed item { 'clauses' } to an empty array
    set from hash parsed item { 'adverbs' } to an empty array
    set from hash parsed item { 'questionword' } to an empty array
    set new flag number_of_clause to 0
    set new hash tags to an empty hash
    for each new var clause in array clauses_input do
        do be_slow without arguments

        # TEXT
        # Split the sentence.
        # CODE
        
        set new array words to split with " ", var clause
        
        # TEXT
        # Then compute the parts of speech etc.
        # CODE
        for each new var word in array words is rw do
            do be_slow without arguments
            set from hash tags item { var word } to compute_tags with var word, var lang, var path
        end for
        
        # TEXT
        # Then toggle the identities (user <-> machine).
        # CODE
        if flag number_of_clause is 0 do
            set hash parsed to parse with var lang, array words, hash tags
            set new array entities to an empty array
            push into array entities, items of that array: from hash parsed item { 'subjects' } end items of
            push into array entities, items of that array: from hash parsed item { 'objects' } end items of
            set from hash parsed item { 'verbs' } to toggle_verbs using from hash parsed item { 'verbs' }, array entities
            set from hash parsed item { 'subjects' } to toggle_entities using from hash parsed item { 'subjects' }
            set from hash parsed item { 'objects' } to toggle_entities using from hash parsed item { 'objects' }
            set from hash parsed item { 'adverbs' } to toggle_entities using from hash parsed item { 'adverbs' }
            set from hash parsed item { 'clauses' } to an empty array
            
            set flag number_of_clause to 1
        done
        else do
            set new hash parsed_clause to parse with var lang, array words, hash tags
            set new array entities to an empty array
            push into array entities, items of that array: from hash parsed_clause item { 'subjects' } end items of
            push into array entities, items of that array: from hash parsed_clause item { 'objects' } end items of
            set from hash parsed_clause item { 'verbs' } to toggle_verbs using from hash parsed_clause item { 'verbs' }, array entities
            set from hash parsed_clause item { 'subjects' } to toggle_entities using from hash parsed_clause item { 'subjects' }
            set from hash parsed_clause item { 'objects' } to toggle_entities using from hash parsed_clause item { 'objects' }
            set from hash parsed_clause item { 'adverbs' } to toggle_entities using from hash parsed_clause item { 'adverbs' }
            set from hash parsed_clause item { 'clauses' } to an empty array
            if not from hash parsed_clause item { 'questionword' } do
                set from hash parsed_clause item { 'questionword' } to an empty array
            done
            push into that array: from hash parsed item { 'clauses' } end-items-of, hash parsed_clause
        done
    done
    if not is an empty hash parsed do
        do save_facts with [ hash parsed ], hash tags, var file_name, var classification, 1, var lang, var path
    done
done

define action transform_psprot_line with var line, var main_word, var current_language, var path do
    do regex using var line: /^\s+/, "", :global
    do regex using var line: /\s+$/, "", :global
    do regex using var line: /\s+/, " ", :global
    set new array words to an empty array
    set array words to split with /<[",.;!?]>/, var line
    
    if var main_word matches /^.?bad.?$/ do
        set var main_word to "_(bad)_"
    done
    if var main_word matches /^.?good.?$/ do
        set var main_word to "_(good)_"
    done
    
    set new array lines to an empty array
    if not lc(var main_word) matches var main_word do
        for each new var word in array words do
            if var word do
                if not lc(var word) matches var word do
                    push into array lines, var word concat ' = ' concat var main_word
                done
                else do
                    push into array lines, '"' concat var word concat '" = ' concat var main_word
                done
            done
        done
    done
    else do
        for each new var word in array words do
            if var word do
                if not lc(var word) matches var word do
                    push into array lines, var word concat ' = "' concat var main_word concat '"'
                done
                else do
                    push into array lines, '"' concat var word concat '" = "' concat var main_word concat '"'
                done
            done
        done
    done
    
    do return with array lines
done

define action init_prot_files with var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    do mkdir with var path concat '/lang_' concat var current_language concat '/wiki'
    set new array sub_directories to [ '', '/thesaurus', '/..' ]   
    push into array sub_directories, '/namen'
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .prot files by parsing them
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name
        
            do be_slow without arguments
            if not var file matches /prot$/ do
                go to next
            done
            if var file matches /wiki\// do
                go to next
            done
            
            set new var pro_file to var file
            do regex using var pro_file: /t$/, "", :i
            
            #if (not var pro_file matches /data/) or exists: var pro_file, end test do
            #    go to next
            #done

            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done

            if not var i is var j do

                print "Read (prot) file "
                print var file
                print new line
                
                do be_slow without arguments
                
                set new var pro_handle to handle for file name var pro_file, write
                do close with var pro_handle
                do be_slow without arguments
                
                set new var translation_input_handle to handle for file name var file, read
                for each new var _line from var translation_input_handle is rw do
                    do be_slow without arguments
                    
                    print "in init_prot_files (1): "
                    print var _line
                    print new line
                    
                    if var _line matches /<[#]>/ do
                        print into var pro_file data var _line
                        print into var pro_file data new line
                        go to next
                    done
                
                    set new array lines to an empty array
                    if var file matches /ps-(.*?).prot/ do
                        set new var main_words_str to $0
                        set new array main_words to split with /<[-]>/, var main_words_str
                        for each new var main_word in array main_words do
                            set new array subarray to transform_psprot_line with var _line, var main_word, var current_language, var path
                            push into array lines, items of array subarray
                        done
                    done
                    else do
                        push into array lines, var _line
                    done
                    
                    for each new var line in array lines do
                        print "in init_prot_files (2): "
                        print var line
                        print new line
                        do work_prot_line with var line, var pro_file, var current_language, var path
                    done
                done
                do close using var translation_input_handle
                
                do reread_pro_file with var pro_file, var current_language

                do be_slow without arguments
                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

            done
        done
    done
done

define action init with var current_language, var path do
    do init_prot_files with var current_language, var path
    do init_pro_files with var current_language, var path
done

define action update_list_of_pro_files with var pattern, var current_language, var path do
    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set new array sub_directories to [ '', '/thesaurus' ]
    push into array sub_directories, '/namen'   
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .pro files by sending a signal to the C thread
        # CODE
        for each new var file_name in array files is rw do
            set new var file to var language_directory concat '/' concat var file_name

            if not var file matches /\.pro$/ do
                go to next
            done
            if not var file matches /$pattern/ do
                go to next
            done
            do update_list_of_pro_file with var file, var current_language, var path

        done
    done
done

define action correct_human_edit_typos with var file, var current_language, var path do
    set new var input_1 to handle for file name var file, read
    set new var output_1 to handle for file name var file concat ".tmp", write
    for each new var line from var input_1 is rw do
        set new var _copy to var line
        
        set new array parts to split using /<[<]><[>]>/, var line
        set new var j to 1
        for each new var part in array parts do
            if var part matches /_/ or var part matches /time/ do
                set var part to " " concat var part concat " "
                if var part not matches /\s<[a-z0-9]>\s/ and var j is not 4 and (var j - 4) % 4 is not 0 do
                    do regex using var part: /\s/, "_", :global
                    do regex using var part: /<[_]>+/, "_", :global
                    set var part to " " concat var part concat " "
                done
                do regex using var part: /_time_from/, " time_from", :global
                do regex using var part: /_time_to/, " time_to", :global
                if var part matches / time_(to|from)/ do
                    do regex using var part: /(<[a-z0-9]>)_/, "$0 ", :global
                    do regex using var part: /_/, " ", :global
                done
                do regex using var part: / time from/, " time_from", :global
                do regex using var part: / time to/, " time_to", :global
                do regex using var part: /(<[a-z)(]>)<[;]>(<[a-z)(]>)/, "$0 $1", :global

                do regex using var part: /(<[(\[]>)_/, "$0", :global
                do regex using var part: /_(<[)\]]>)/, "$0", :global
                do regex using var part: /^\s+/, " ", :global
                do regex using var part: /\s+$/, " ", :global
            done
            set var j to var j + 1
        done
        set var line to join using "<>", items of array parts
        
        if var _copy not matches var line do
            print "Corrected typo:    " concat var _copy concat new line
            print "                => " concat var line concat new line
        done
    
        print into var output_1 data var line
        print into var output_1 data new line
    done
    do close with var input_1
    do close with var output_1
    
    set new var input_2 to handle for file name var file concat ".tmp", read
    set new var output_2 to handle for file name var file, write
    for each new var line from var input_2 is rw do
        print into var output_2 data var line
        print into var output_2 data new line
    done
    do close with var input_2
    do close with var output_2
    
    do unlink with var file concat ".tmp"
    
    do return without arguments
done

define action clear_empty_lines with var file, var current_language, var path do
    set new var _input to handle for file name var file, read
    for each new var line from var _input is rw do
        if length(var line) < 3 do
            do close with var _input
            
            set new var input_1 to handle for file name var file, read
            set new var output_1 to handle for file name var file concat ".tmp", write
            for each new var line from var input_1 is rw do
                if length(var line) >= 3 do
                    print into var output_1 data var line
                    print into var output_1 data new line
                done
            done
            do close with var input_1
            do close with var output_1
            
            set new var input_2 to handle for file name var file concat ".tmp", read
            set new var output_2 to handle for file name var file, write
            for each new var line from var input_2 is rw do
                print into var output_2 data var line
                print into var output_2 data new line
            done
            do close with var input_2
            do close with var output_2
            
            do unlink with var file concat ".tmp"
            
            do return without arguments
        done
    done
done

define action init_pro_files with var current_language, var path do
    if exists: "SLOW", end test do
        print "Don't read the .pro files in SLOW mode."
        print new line
        do return with 1
    done

    set new var save_path to var path concat '/saved/'
    do mkdir with var save_path
    set new array sub_directories to [ '', '/thesaurus' ]
    push into array sub_directories, '/namen'   
    push into array sub_directories, '/berufe'
    push into array sub_directories, '/ps_dateien'
    push into array sub_directories, '/wiki'
    push into array sub_directories, '/fakten'
    
    for each new var sub_dir in array sub_directories is copy do
        set new var language_directory to var path concat '/lang_' concat var current_language concat var sub_dir

        do opendir with new var dir_handle, var language_directory
        set new array files to [ readdir(var dir_handle) ]
        # TEXT
        # Read all .pro files by sending a signal to the C thread
        # CODE
        for each new var file_name in array files is rw do
            #print var file_name concat "..."
            #print new line
            
            do be_slow without arguments
            set new var file to var language_directory concat '/' concat var file_name

            if not var file matches /\.pro$/ do
                go to next
            done

            do unlink with '_output__add_pro_file'
            do unlink with '_input__add_pro_file'
            
            do clear_empty_lines with var file, var current_language, var path

            set new var check_input_handle_one to handle for file name var file, read
            set new var check_input_handle_two to handle for file name var save_path concat var file_name, read
            set new var i to 1
            for each new var line from var check_input_handle_one is rw do
                set var i to var i + 1 + length(var line)
            done
            set new var j to 1
            for each new var line from var check_input_handle_two is rw do
                set var j to var j + 1 + length(var line)
            done
            
            if not var i is var j do
            
                do correct_human_edit_typos with var file, var current_language, var path

                print "Read file "
                print var file
                print new line

                # TEXT
                # Write the signal file
                # CODE
                do unlink with '_input__add_pro_file'
                set new var output_handle to handle for file name "_output__add_pro_file", write
                print into var output_handle data var file
                do close with var output_handle
                #do wait 1 seconds

                # TEXT
                # Wait...
                # CODE
                while not exists: '_input__add_pro_file', end test do
                    do wait 0.1 seconds
                done

                set new var copy_input_handle to handle for file name var file, read
                set new var copy_output_handle to handle for file name var save_path concat var file_name, write
                for each new var line from var copy_input_handle is rw do
                    print into var copy_output_handle data var line
                    print into var copy_output_handle data new line
                done
                do close using var copy_output_handle
                do close using var copy_input_handle

            done
            else do
                print "No changes have been made in file "
                print var file
                print "."
                print new line

            done
        done
    done
    print "Done..."
    print new line
done

define action decide with array output, var input, flag all_output_phrases, var lang, var path do
    set new hash parsed to fake_hash_parsed without arguments
    set new var mode to "statement"

    if flag all_output_phrases do
        set new var output_str to ''
        set new var i to items of array output
        for each new array _item in array output do
            set new var item_str to post_phrase with var lang, var path, var mode, hash parsed, array _item
            set var output_str to var output_str concat var i concat ".) " concat var item_str concat '<br>'
            set var i to var i - 1
        done
        return var output_str
    done
    else do
        
        if 2 <= size of array output do
            set new var input_handle to handle for file name var path concat '/lang_' concat var lang concat '/output.history', read
            set new var last_output to ''
            for each new var line from var input_handle do
                set var last_output to var line
            done
            
            print "previous output: " concat var last_output concat new line
            
            for each new var _output in array output do
                set new var output to from array _output second item
                
                do regex using var output: /\(.*/, "", :global
                do regex using var output: /\((<[+]>+?)\)\s/, "", :global
                do regex using var output: /\((<[-]>+?)\)\s/, "", :global
                do regex using var output: /\((<[+]>+?)\)/, "", :global
                do regex using var output: /\((<[-]>+?)\)/, "", :global
                
                print "maybe current output: " concat var output concat new line
                
                if lc(var last_output) matches lc(var output) do
                    set from array _output second item to ''
                    go to last
                done
            done
            
            set new array replacement_for_output to an empty array
            for each new var _output in array output do
                if from array _output second item do
                    push into array replacement_for_output, var _output
                done
            done
            set array output to array replacement_for_output
        done
        
        set new array words to split with " ", lc(var input)
        set new array rel_output to an empty array
        for each new array _item in array output do
            print "Score of " concat from array _item second item concat " is "
            set new var score to get_score with array words, from array _item second item, var lang, var path
            print var score
            print new line
            set new var k to 0
            while var k < var score + 1 do
                push into array rel_output, array _item
                set var k to var k + 1
            done
        done
        
        # TEXT
        # If all scores are negative...
        # CODE
        if is an empty array rel_output do
            set array rel_output to array output
        done
        
        # TEXT
        # Choose an answer
        # CODE
        set new var random_number to rand using items of array rel_output
        set new array final_output to from array rel_output item [ var random_number ]
        set new var final_output_str to post_phrase with var lang, var path, var mode, hash parsed, array final_output
        do return var final_output_str
    done
done

define action link_facts with var type, var f1, var f2 do
    print "Linking " concat var f1 concat " and " concat var f2 concat " as " concat var type
    print new line
    set new var output_handle to handle for file name "_output__link", write
        print into var output_handle data var type
        print into var output_handle data new line
        print into var output_handle data var f1
        print into var output_handle data new line
        print into var output_handle data var f2
        print into var output_handle data new line
    do close with var output_handle
done

define action escape_html with var text do
    do regex using var text: /<[<]>/, "&lt;", :global
    do regex using var text: /<[>]>/, "&gt;", :global
    
    do return with var text
done

define action shell with var current_language, var path do
    set new var input_file_name to '_input'
    set new var input_handle to handle for file name var input_file_name, read
    
    set new var time_first to time without arguments
    set new var do_learn to 1
    set new var do_talk  to 1

    for each new var sentences_as_line_2 from var input_handle is rw do
        if var sentences_as_line_2 matches /^do_learn_do_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 1
            set var do_talk  to 1
        done
        if var sentences_as_line_2 matches /^do_learn_no_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 1
            set var do_talk  to 0
        done
        if var sentences_as_line_2 matches /^no_learn_do_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 0
            set var do_talk  to 1
        done
        if var sentences_as_line_2 matches /^no_learn_no_talk: (.*?)$/ do
            set var sentences_as_line_2 to $0
            set var do_learn to 0
            set var do_talk  to 0
        done
        
        print "Do learn: " concat var do_learn concat new line
        print "Do talk:  " concat var do_talk  concat new line
    
        do regex using var sentences_as_line_2: /[?]+/, "?", :global
        do regex using var sentences_as_line_2: /([?])/, "$0.", :global
        do regex using var sentences_as_line_2: /[.!~]\s*?[.!~]/, "~", :global
        do regex using var sentences_as_line_2: /[.!~]\s*?[.!~]/, "~", :global
        do regex using var sentences_as_line_2: /<[.]>(\s|$)/, " STOP ", :global
        do regex using var sentences_as_line_2: /(\d) STOP /, "$0. ", :global
        do regex using var sentences_as_line_2: / STOP \((.*)\)/, " ($0) STOP . ", :global
        
        set var sentences_as_line_2 to divide_input with var sentences_as_line_2, var current_language, var path
        
        set new array sentences_as_line_array to split with /\sSTOP\s/, var sentences_as_line_2
        for each new var sentences_as_line in array sentences_as_line_array do
            
            set new array facts_to_save to an empty array
            set new hash tags to an empty hash
            
            set new array sentences to split with /[!~]/, var sentences_as_line

            for each new var line in array sentences do
            
                do regex using var line: /^\s+/, "", :global
                do regex using var line: /\s+$/, "", :global
                do regex using var line: /\.$/, "", :global
                do regex using var line: /^\./, "", :global
                if not var line do
                    go to next
                done

                set new flag all_output_phrases to 0
                if lc(var line) matches /^\/all / do
                    do regex using var line: /^\/all /, "", :global:i
                    set flag all_output_phrases to 1
                done
                if lc(var line) matches /^\/gen list/ do
                    do regex using var line: /^\/gen list /, "", :global:i
                    do regex using var line: /^\/gen list/, "", :global:i
                    do regex using var line: /.pro/, "", :global:i
                    if not var line do
                        set var line to ""
                    done
                    do update_list_of_pro_files with var line, var current_language, var path
                    go to next
                done
                
                do unlink with '_output'
                set new array output to give_output with var line, (not var do_talk), array facts_to_save, hash tags, var current_language, var path
                do unlink with '_output'

                set new var final_output to decide using array output, var line, flag all_output_phrases, var current_language, var path
                
                set var final_output to upper_case_correction with var final_output, hash tags, var current_language, var path
                do regex using var final_output: /\((<[+]>+?)\)\s/, "", :global
                do regex using var final_output: /\((<[-]>+?)\)\s/, "", :global
                do regex using var final_output: /\((<[+]>+?)\)/, "", :global
                do regex using var final_output: /\((<[-]>+?)\)/, "", :global
        
                set new var time_second to time without arguments
                set var final_output to var final_output concat " (" concat (var time_second - var time_first) concat " sec)"

                do unlink with '_output'
                do save_output with var final_output, var current_language, var path
                if var do_talk do
                    set new var output_file_name to '_output'
                    set new var output_handle to handle for file name var output_file_name, write
                    print into var output_handle data var final_output
                    do close with var output_handle
                done

                print "Final output is..."
                print new line
                print "      "
                print var final_output
                print new line
            done
            
            set new var saved_data to ''
            if var do_learn do
                set var saved_data to save_facts with array facts_to_save, hash tags, '',  '', 0, var current_language, var path
                set var saved_data to escape_html using var saved_data
            done
            else do
                set var saved_data to save_facts with array facts_to_save, hash tags, '-', '', 0, var current_language, var path
                set var saved_data to escape_html using var saved_data
            done
            
            if not var do_talk do
                if var saved_data and length(var saved_data) > 5 do
                    set new var output_file_name to '_output'
                    set new var output_handle to handle for file name var output_file_name, write
                    print into var output_handle data var saved_data
                    do close with var output_handle
                done
            done
            
            print "Do learn: " concat var do_learn concat new line
            print "Do talk:  " concat var do_talk  concat new line
        done
    done
    
    do memory_limit with "word_types.memory", var current_language, var path
    do memory_limit with "word_types.self-taggered", var current_language, var path
    
    #set new var f1 to shift with items of array facts_to_link
    #set new var f2 to shift with items of array facts_to_link
    #if var f1 and var f2 do
    #    do link_facts with "order", var f1, var f2
    #
    #    set var f1 to var f2
    #    set var f2 to shift with items of array facts_to_link
    #done
    
    set new var exit_file_name to '_exit'
    set new var exit_handle to handle for file name var exit_file_name, write
    do close with var exit_handle
    do exit with 0
done

if 0 do
    set new var output_file_name to '_output__get_csv'
    set new var output_handle to handle for file name var output_file_name, write
    print into var output_handle data "ist^"
    do close with var output_handle

    do wait 1000000 seconds
done
