#
# This file is part of FreeHAL 2010.
#
# Copyright(c) 2006, 2007, 2008, 2009, 2010 Tobias Schulz and contributors.
# http://freehal.org
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

set multi-line new global array collective_nouns to [
];

set multi-line new global array custom_names to [
];

set multi-line new global array builtin_female_names to [

];

set multi-line new global array builtin_male_names to [
          "aaron",
          "abraham",
          "achaz",
          "achim",
          "adalbert",
          "adam",
          "adelbert",
          "adelfried",
          "adelhard",
          "adi",
          "adolf",
          "adolph",
          "adrian",
          "aegidius",
          "agilbert",
          "agilmar",
          "alban",
          "albert",
          "albin",
          "albrecht",
          "alex",
          "alexander",
          "alf",
          "alfhard",
          "alfinus",
          "alfons",
          "alfred",
          "alfried",
          "alhard",
          "allmar",
          "alois",
          "aloisius",
          "aloys",
          "aloysius",
          "alphonsus",
          "alrik",
          "altfried",
          "alwin",
          "amadeus",
          "ambros",
          "ambrosius",
          "andreas",
          "andree",
          "andy",
          "annik",
          "anrich",
          "ansbert",
          "anselm",
          "ansgar",
          "anton",
          "antonius",
          "arend",
          "aribert",
          "arist",
          "arkadius",
          "armin",
          "arnbert",
          "arnd",
          "arndt",
          "arne",
          "arnfred",
          "arnfried",
          "arnhart",
          "arnim",
          "arno",
          "arnold",
          "arnolf",
          "arnt",
          "arnulf",
          "aron",
          "arthur",
          "artur",
          "arved",
          "arwed",
          "arwid",
          "arwin",
          "ascan",
          "august",
          "augustin",
          "augustinus",
          "augustus",
          "axel",
          "baldur",
          "balthasar",
          "baptist",
          "bardo",
          "barnabas",
          "bartho",
          "barthold",
          "bartholomaeus",
          "bartold",
          "bartosch",
          "bastian",
          "beat",
          "benedict",
          "benedikt",
          "benediktus",
          "benjamin",
          "benno",
          "bernd",
          "berndt",
          "bernfried",
          "bernhard",
          "bernhardin",
          "bernhardt",
          "bernhart",
          "berni",
          "berno",
          "bernold",
          "bernulf",
          "bernward",
          "bert",
          "berthold",
          "berti",
          "bertin",
          "bertl",
          "bertold",
          "bertolt",
          "bertram",
          "bertwald",
          "bertwin",
          "birk",
          "bjoern",
          "blasius",
          "bodmar",
          "bodo",
          "bodomar",
          "bolko",
          "bonifaz",
          "boris",
          "boerries",
          "borromaeus",
          "borwin",
          "botho",
          "boto",
          "brandolf",
          "bringfried",
          "bruno",
          "burchard",
          "burckhard",
          "burckhardt",
          "burgfried",
          "burghard",
          "burghardt",
          "burghart",
          "burkard",
          "burkardt",
          "burkhard",
          "burkhardt",
          "burkhart",
          "cai",
          "carl",
          "carlheinz",
          "carsten",
          "caspar",
          "cay",
          "cersten",
          "chris",
          "christfried",
          "christhard",
          "christhardt",
          "christhart",
          "christhelm",
          "christian",
          "christmut",
          "christof",
          "christoph",
          "christopher",
          "christopherus",
          "christophorus",
          "christward",
          "claudius",
          "claus",
          "clemens",
          "conrad",
          "constantin",
          "corbinian",
          "cord",
          "cordian",
          "cordt",
          "cornelius",
          "cornell",
          "cuno",
          "curd",
          "curt",
          "cyrill",
          "dagobert",
          "dagomar",
          "damian",
          "daniel",
          "dankfried",
          "dankhard",
          "dankmar",
          "dankward",
          "dankwart",
          "danny",
          "darius",
          "david",
          "degenhard",
          "degenhardt",
          "degenhart",
          "delf",
          "denis",
          "dennis",
          "denny",
          "desiderius",
          "dethard",
          "detlef",
          "detlev",
          "detmar",
          "detrich",
          "didi",
          "diemo",
          "dierk",
          "dietbald",
          "dietbert",
          "dieter",
          "dieterich",
          "dietfried",
          "dietgar",
          "dietger",
          "diethard",
          "diethardt",
          "diethart",
          "diethelm",
          "diether",
          "diethmar",
          "dietmar",
          "dietmund",
          "dietolf",
          "dietram",
          "dietrich",
          "dietwald",
          "dietwalt",
          "dietwolf",
          "dietwulf",
          "dietz",
          "dimitri",
          "dionys",
          "dirk",
          "ditmar",
          "dittmar",
          "dominic",
          "dominik",
          "dominikus",
          "donat",
          "donatus",
          "eberhard",
          "eberhardt",
          "eberhart",
          "eckard",
          "eckardt",
          "eckart",
          "eckbert",
          "eckehard",
          "eckehardt",
          "eckehart",
          "eckert",
          "eckfried",
          "eckhard",
          "eckhardt",
          "eckhart",
          "eckhold",
          "eddi",
          "edelbert",
          "edelfried",
          "edelhard",
          "edelmut",
          "edelwald",
          "edgar",
          "edmar",
          "edmund",
          "eduard",
          "eduardt",
          "edwin",
          "egbert",
          "egidius",
          "eginald",
          "eginhard",
          "eginhardt",
          "egmont",
          "egomar",
          "egon",
          "ehrenfried",
          "ehrenreich",
          "ehrhard",
          "ehrhardt",
          "ehrmut",
          "eik",
          "eike",
          "einhard",
          "einhardt",
          "eitelbert",
          "eitelfritz",
          "ekhard",
          "ekhardt",
          "ekkard",
          "ekkardt",
          "ekkart",
          "ekkehard",
          "ekkehardt",
          "ekkehart",
          "elbert",
          "elkmar",
          "elmar",
          "emanuel",
          "emeram",
          "emerich",
          "emil",
          "emmeram",
          "emmeran",
          "emmerich",
          "engelbert",
          "engelbrecht",
          "engelhard",
          "engelhardt",
          "engelmar",
          "englbert",
          "enrico",
          "erdfried",
          "erdmann",
          "erdwin",
          "erfried",
          "erhard",
          "erhardt",
          "erhart",
          "eric",
          "erich",
          "erik",
          "erk",
          "erkmar",
          "erlfried",
          "ermenfried",
          "erni",
          "erno",
          "ernst",
          "ernstfried",
          "erwin",
          "eugen",
          "eustachius",
          "ewald",
          "eyck",
          "fabian",
          "falk",
          "falkhard",
          "falkmar",
          "falko",
          "felix",
          "ferdi",
          "ferdinand",
          "ferdinandus",
          "ferfried",
          "ferhard",
          "ferhart",
          "fidelius",
          "firma",
          "florentin",
          "florentius",
          "florenz",
          "florian",
          "folker",
          "folkhard",
          "folkhardt",
          "folkhart",
          "folko",
          "follrich",
          "frank",
          "frankmut",
          "franz",
          "franziskus",
          "franzl",
          "franzpeter",
          "fred",
          "freddy",
          "freimund",
          "freimut",
          "freimuth",
          "freiwald",
          "fridolin",
          "fridulf",
          "fried",
          "friedbald",
          "friedberg",
          "friedbert",
          "friedebert",
          "friedeborn",
          "friedel",
          "friedemann",
          "friedemar",
          "frieder",
          "friedewald",
          "friedhard",
          "friedhardt",
          "friedhart",
          "friedhelm",
          "friedhold",
          "friedjoerg",
          "friedl",
          "friedlieb",
          "friedmar",
          "friedmut",
          "friedmuth",
          "friedolf",
          "friedolin",
          "friedrich",
          "friedwald",
          "friedwin",
          "frithjof",
          "fritz",
          "frohmund",
          "frohmut",
          "frohwald",
          "frowin",
          "gabriel",
          "gangolf",
          "gebhard",
          "gebhart",
          "gelbert",
          "georg",
          "gerald",
          "gerd",
          "gerdfried",
          "gerdt",
          "gereon",
          "gerfried",
          "gerhard",
          "gerhardt",
          "gerhart",
          "gerlach",
          "german",
          "germar",
          "germo",
          "germut",
          "gernfried",
          "gernod",
          "gernot",
          "gernulf",
          "gero",
          "gerold",
          "gerolf",
          "gerrit",
          "gert",
          "gerthold",
          "gertmund",
          "gertwin",
          "gerwald",
          "gerwin",
          "giesbert",
          "gisbert",
          "giselbert",
          "giselher",
          "gismar",
          "godo",
          "golo",
          "gordian",
          "goswin",
          "gottfried",
          "gotthard",
          "gotthardt",
          "gotthart",
          "gotthelf",
          "gotthilf",
          "gotthold",
          "gottlieb",
          "gottlob",
          "gottreich",
          "gottwald",
          "gottwaldt",
          "gottwalt",
          "goetz",
          "gregor",
          "grimbert",
          "guido",
          "gundhard",
          "gundhart",
          "gundmar",
          "gundolf",
          "gunfried",
          "gunhard",
          "gunnar",
          "gunter",
          "guenter",
          "gunthard",
          "gunther",
          "guenther",
          "guntmar",
          "guntram",
          "gustav",
          "gustel",
          "gustl",
          "hadubert",
          "hagen",
          "haimo",
          "hanfried",
          "hannes",
          "hanno",
          "hanns",
          "hannsgeorg",
          "hannsjoerg",
          "hannsjuergen",
          "hannspeter",
          "hans",
          "hansdieter",
          "hansfried",
          "hansfriedrich",
          "hansgeorg",
          "hansgerd",
          "hansguenter",
          "hansguenther",
          "hansheinz",
          "hanshelmut",
          "hanshermann",
          "hansi",
          "hansjakob",
          "hansjoachim",
          "hansjochen",
          "hansjoerg",
          "hansjoern",
          "hansjuergen",
          "hanskarl",
          "hansl",
          "hansludwig",
          "hansmartin",
          "hansotto",
          "hanspeter",
          "hanswalter",
          "hanswerner",
          "hanswilhelm",
          "hanswolf",
          "harald",
          "hardi",
          "hardo",
          "hardy",
          "hariolf",
          "harri",
          "harribert",
          "harro",
          "harry",
          "hartfried",
          "hartger",
          "hartlieb",
          "hartmann",
          "hartmund",
          "hartmut",
          "hartmuth",
          "hartwald",
          "hartwig",
          "hartwin",
          "hasko",
          "hasso",
          "hatto",
          "haug",
          "haymo",
          "heidebert",
          "heiderich",
          "heidfried",
          "heiko",
          "heilmuth",
          "heilwig",
          "heimar",
          "heimbert",
          "heimfrid",
          "heimhart",
          "heimo",
          "heimwald",
          "heiner",
          "heinfried",
          "heini",
          "heino",
          "heinolf",
          "heinrich",
          "heintje",
          "heinz",
          "heinzdieter",
          "heinzfried",
          "heinzhermann",
          "heinzjoerg",
          "heinzjuergen",
          "heinzkarl",
          "heinzpeter",
          "heinzwerner",
          "helbert",
          "helfred",
          "helfrid",
          "helfried",
          "helge",
          "helgert",
          "helgomar",
          "hellfried",
          "hellmut",
          "hellmuth",
          "helm",
          "helmar",
          "helmbrecht",
          "helmfried",
          "helmo",
          "helmrich",
          "helmut",
          "helmuth",
          "helmward",
          "helwart",
          "helwig",
          "helwin",
          "hendrik",
          "henning",
          "henrik",
          "henry",
          "herald",
          "herbert",
          "herfried",
          "herger",
          "heribert",
          "herko",
          "hermann",
          "hermfried",
          "herold",
          "herrmann",
          "herwald",
          "herward",
          "herwart",
          "herwarth",
          "herwig",
          "heyko",
          "heyo",
          "hieronimus",
          "hieronymus",
          "hilar",
          "hilarius",
          "hildebert",
          "hildebrand",
          "hildemar",
          "hildmar",
          "hilfried",
          "hilmar",
          "hippolytus",
          "hoimar",
          "holger",
          "holk",
          "holm",
          "holmer",
          "horst",
          "horstfried",
          "horstmar",
          "hubert",
          "hubertus",
          "hugo",
          "humbert",
          "ignatz",
          "ignaz",
          "ilrich",
          "immanuel",
          "ingbert",
          "ingfried",
          "inghard",
          "ingmar",
          "ingo",
          "ingobert",
          "ingolf",
          "ingomar",
          "ingowart",
          "ingram",
          "inkmar",
          "innozenz",
          "irenaeus",
          "ireneus",
          "irmfried",
          "irmin",
          "irminfried",
          "irmo",
          "isbert",
          "isfried",
          "isidor",
          "iven",
          "ivo",
          "jacob",
          "jakob",
          "jan",
          "janfried",
          "jannick",
          "jean",
          "jens",
          "jo",
          "joachim",
          "jobst",
          "jochen",
          "joel",
          "johann",
          "johannes",
          "jonas",
          "jonathan",
          "jonny",
          "jons",
          "joerg",
          "joergfried",
          "joern",
          "joscha",
          "joschka",
          "josef",
          "joseph",
          "jost",
          "josua",
          "julian",
          "julius",
          "jupp",
          "juergen",
          "just",
          "justus",
          "kai",
          "kajetan",
          "karl",
          "karlernst",
          "karleugen",
          "karlfried",
          "karlfrieder",
          "karlfriedrich",
          "karlgeorg",
          "karlguenter",
          "karlhans",
          "karlheiner",
          "karlheinrich",
          "karlheinz",
          "karlhorst",
          "karli",
          "karlmann",
          "karlotto",
          "karlpeter",
          "karsten",
          "kasimir",
          "kaspar",
          "kay",
          "kersten",
          "kevin",
          "kilian",
          "klaudius",
          "klaus",
          "klausdieter",
          "klausjuergen",
          "klauspeter",
          "klemens",
          "knut",
          "knuth",
          "konrad",
          "konradin",
          "konstantin",
          "korbinian",
          "kord",
          "kornelius",
          "kristian",
          "kruno",
          "kunibert",
          "kuno",
          "kurd",
          "kurt",
          "kurth",
          "lambert",
          "landolf",
          "lars",
          "laurentius",
          "laurenz",
          "leander",
          "leberecht",
          "lebrecht",
          "lenard",
          "lenz",
          "leo",
          "leon",
          "leonhard",
          "leonhardt",
          "leopold",
          "leuthold",
          "lewin",
          "liborius",
          "liebhard",
          "liebhardt",
          "lienard",
          "lienhard",
          "lienhardt",
          "lindmar",
          "linhart",
          "lois",
          "loisl",
          "lorenz",
          "lothar",
          "louis",
          "lucas",
          "ludger",
          "ludolf",
          "ludwig",
          "luitpold",
          "luitwin",
          "lukas",
          "lutz",
          "maic",
          "maik",
          "malte",
          "manfred",
          "manfried",
          "manhard",
          "manhardt",
          "manhold",
          "manuel",
          "marbod",
          "marc",
          "marcel",
          "marcellus",
          "marco",
          "marcus",
          "marfried",
          "margolf",
          "marian",
          "mario",
          "marius",
          "mark",
          "marko",
          "markolf",
          "markus",
          "markward",
          "markwart",
          "marold",
          "martin",
          "marzel",
          "marzellus",
          "mathias",
          "mathis",
          "matthaeus",
          "matthias",
          "maurus",
          "max",
          "maximilian",
          "maximillian",
          "maxl",
          "mayk",
          "medard",
          "medardus",
          "meik",
          "meikel",
          "meinard",
          "meinfried",
          "meinhard",
          "meinhart",
          "meinold",
          "meinolf",
          "meinrad",
          "meinulf",
          "melchior",
          "merten",
          "micha",
          "michael",
          "michel",
          "michl",
          "mike",
          "mirco",
          "mirko",
          "mischel",
          "moritz",
          "nathanael",
          "neidhard",
          "neidhardt",
          "neithard",
          "neithart",
          "nepomuk",
          "nick",
          "nicki",
          "nicky",
          "nico",
          "nicolas",
          "nicolaus",
          "niels",
          "niklas",
          "niklaus",
          "niko",
          "nikodem",
          "nikodemus",
          "nikolas",
          "nikolaus",
          "nils",
          "norbert",
          "nordfried",
          "norfried",
          "norman",
          "norwin",
          "notfried",
          "notker",
          "nunzius",
          "odilo",
          "olaf",
          "olf",
          "oliver",
          "olli",
          "ornulf",
          "ortfried",
          "ortmund",
          "ortwin",
          "oskar",
          "osmund",
          "oswald",
          "oswin",
          "otbert",
          "otfried",
          "otger",
          "otheinrich",
          "othmar",
          "otmar",
          "ottfried",
          "otthard",
          "otthart",
          "otthein",
          "ottheinrich",
          "ottheinz",
          "otthold",
          "ottkar",
          "ottmar",
          "otto",
          "ottobert",
          "ottokar",
          "ottomar",
          "ottwin",
          "otwald",
          "otwin",
          "pankratius",
          "pankraz",
          "pascal",
          "patrick",
          "paul",
          "paulfried",
          "paulinus",
          "paulus",
          "peter",
          "philip",
          "philipp",
          "phillip",
          "phillipp",
          "phillippus",
          "pierre",
          "pirmin",
          "pius",
          "quintus",
          "quirin",
          "raik",
          "raimar",
          "raimer",
          "raimond",
          "raimund",
          "rainald",
          "rainer",
          "rainhard",
          "rainhardt",
          "rainmund",
          "ralf",
          "ralph",
          "randolf",
          "randolph",
          "raphael",
          "rasso",
          "raymund",
          "reginbert",
          "reginhardt",
          "reimo",
          "reimund",
          "reinald",
          "reinar",
          "reinbert",
          "reiner",
          "reinfried",
          "reinhard",
          "reinhardt",
          "reinhart",
          "reinhold",
          "reinholdt",
          "reinmar",
          "reino",
          "reinold",
          "reinulf",
          "reinwald",
          "rembert",
          "remigius",
          "renald",
          "renatus",
          "renold",
          "rezzo",
          "richard",
          "rico",
          "rigbert",
          "rigo",
          "rigobert",
          "rimbert",
          "ringo",
          "robby",
          "robert",
          "roberto",
          "rochus",
          "roderich",
          "roger",
          "roland",
          "rolf",
          "roman",
          "romanus",
          "ronald",
          "ronny",
          "roselius",
          "rotger",
          "rothmund",
          "rouven",
          "ruben",
          "rudenz",
          "rudger",
          "rudi",
          "ruediger",
          "rudolf",
          "rudolph",
          "runald",
          "runfried",
          "rupert",
          "rupertus",
          "ruppert",
          "rupprecht",
          "ruprecht",
          "rutger",
          "ruetger",
          "ruthard",
          "samuel",
          "sascha",
          "schorsch",
          "sebald",
          "sebastian",
          "seibold",
          "sepp",
          "seppl",
          "sergius",
          "severin",
          "sibrand",
          "sidonius",
          "siegbert",
          "siegenot",
          "siegert",
          "siegfrid",
          "siegfried",
          "sieghard",
          "sieghardt",
          "sieghart",
          "sieghelm",
          "siegmar",
          "siegmund",
          "siegulf",
          "siegwald",
          "siegward",
          "siegwart",
          "sigbert",
          "sigenot",
          "sigfrid",
          "sigfried",
          "siggi",
          "sighard",
          "sighart",
          "sighelm",
          "sigi",
          "sigisbert",
          "sigishelm",
          "sigismund",
          "sigmar",
          "sigmund",
          "sigmut",
          "sigolf",
          "sigurd",
          "sigward",
          "sigwart",
          "silvester",
          "silvio",
          "simon",
          "simpert",
          "sixtus",
          "soenke",
          "sonnfried",
          "sonnhard",
          "sonnhardt",
          "soeren",
          "stanislaus",
          "stefan",
          "steff",
          "steffan",
          "steffen",
          "steph",
          "stephan",
          "stephanus",
          "steve",
          "steven",
          "sturmhard",
          "sturmius",
          "sven",
          "swen",
          "sylvester",
          "sylvio",
          "sylvius",
          "tankred",
          "tassilo",
          "tell",
          "thaddaeus",
          "thankmar",
          "thassilo",
          "theo",
          "theobald",
          "theobert",
          "theodor",
          "theofried",
          "theohold",
          "theophil",
          "theophilus",
          "thielo",
          "thiemo",
          "thilo",
          "thomas",
          "thoralf",
          "thorsten",
          "tiberius",
          "tiburtius",
          "tiemo",
          "til",
          "till",
          "tillmann",
          "tilman",
          "tilmann",
          "tilo",
          "tim",
          "timmo",
          "timo",
          "timon",
          "timotheus",
          "tino",
          "titus",
          "tobias",
          "tom",
          "tommy",
          "toni",
          "toens",
          "tony",
          "toralf",
          "torben",
          "torge",
          "torsten",
          "traugott",
          "trauhard",
          "treufried",
          "treuhard",
          "treuhart",
          "tristan",
          "trudbert",
          "trutz",
          "udo",
          "ulf",
          "ulfried",
          "uli",
          "ulli",
          "ullrich",
          "ulrich",
          "ulvi",
          "ulwin",
          "uranius",
          "urban",
          "ursus",
          "utho",
          "uto",
          "utto",
          "utz",
          "uve",
          "uwe",
          "valentin",
          "valerian",
          "veit",
          "veith",
          "velten",
          "viktor",
          "vincenz",
          "vinzent",
          "vinzenz",
          "vitalis",
          "vitus",
          "volkard",
          "volkart",
          "volkbert",
          "volker",
          "volkhard",
          "volkhardt",
          "volkhart",
          "volkher",
          "volkmar",
          "volkrad",
          "volkward",
          "volkwart",
          "vollrath",
          "volrad",
          "walbert",
          "waldemar",
          "waldfried",
          "walfried",
          "walter",
          "walther",
          "walti",
          "warnfried",
          "wastl",
          "wedig",
          "wedigo",
          "weikhard",
          "welf",
          "welfhard",
          "wendel",
          "wendelin",
          "wendelinus",
          "wendemar",
          "wennemar",
          "wenzel",
          "werner",
          "wernfried",
          "wernhard",
          "wernher",
          "wichard",
          "wido",
          "wiegand",
          "wiegbert",
          "wieghart",
          "wieland",
          "wiethold",
          "wigand",
          "wigbert",
          "wiglaf",
          "wilbert",
          "wilbrand",
          "wilbrandt",
          "wilderich",
          "wilfrid",
          "wilfried",
          "wilhard",
          "wilhardt",
          "wilhelm",
          "willehad",
          "willhart",
          "willi",
          "willibald",
          "willibert",
          "willmar",
          "willrich",
          "willy",
          "wilmar",
          "wilmhard",
          "wilmut",
          "winand",
          "winfrid",
          "winfried",
          "wingolf",
          "winnimar",
          "winrich",
          "withold",
          "witmar",
          "wittmar",
          "wladislaus",
          "woldemar",
          "wolf",
          "wolfbert",
          "wolfdieter",
          "wolfdietrich",
          "wolfeckart",
          "wolff",
          "wolfgang",
          "wolfguenter",
          "wolfhard",
          "wolfhardt",
          "wolfhart",
          "wolfhelm",
          "wolfhermann",
          "wolfmar",
          "wolfram",
          "wolfrid",
          "wolfried",
          "wolrad",
          "wulf",
          "wulfhard",
          "wulfhardt",
          "wunibald",
          "wunnibald",
          "xaver",
          "xaverius",
          "york",
          "zacharias",
          "zeno",
];

set multi-line new global array builtin_entity_ends_pair to [
          [ 'das', 'ein' ],
          [ 'das', 'eine' ],
          [ 0, 'geburtstag' ],
          [ 'dies', 0 ],
];

define action builtin_entity_does_not_end with var word do
    if var word matches /cial$/ do
        do return with 1
    done
    do return with 0
done

set multi-line new global hash builtin_entity_does_not_end to {
          'mac' => 1,
          
};

set multi-line new global hash builtin_entity_ends to {
          'i' => 1,
          'h' => 1,
          'g' => 1,
          'f' => 1,
          'e' => 1,
          'd' => 1,
          'c' => 1,
          'b' => 1,
          'a' => 1,
          'er' => 1,
          'sie' => 1,
          'es' => 1,
          'ihm' => 1,
          'ihr' => 1,
          'ihn' => 1,
          'mir' => 1,
          'dir' => 1,
          'mich' => 1,
          'dich' => 1,
          'ich' => 1,
          'du' => 1,
};

set multi-line new global hash builtin_time_place_adverbs to {
          '_wie_' => 1,
          '_wer_' => 1,
          '_was_' => 1,
          '_wo_' => 1,
          '_wann_' => 1,
          '_warum_' => 1,
          '_wieso_' => 1,
          '_weshalb_' => 1,
          'nicht' => 1,
          '_(true)_' => 1,
          '_(maybe)_' => 1,
          '_(false)_' => 1,
          '_(logic)_' => 1,
          '_q_' => 1,
          'kenne' => 1,
          'vorhin' => 1,
          'nachher' => 1,
          'vorher' => 1,
          'spaeter' => 1,
          'eben' => 1,
          'nun' => 1,
          'schon' => 1,
          'auch' => 1,
          'noch' => 1,
          'etwa' => 1,
          'ungefaehr' => 1,
          'keinesfalls' => 1,
          'ca' => 1,
          'mal' => 1,
          'bestimmte' => 1,
          'bestimmt' => 1,
          'bestimmtes' => 1,
          'bestimmter' => 1,
          'bestimmten' => 1,
          'bestimmtem' => 1,
          '_jeden_tag_' => 1,
          'sicher' => 1,
          'denn' => 1,
          'dann' => 1,
          'gerne' => 1,
          'spaet' => 1,
          'staendig' => 1,
          'frueh' => 1,
          'frueher' => 1,
          'spaeter' => 1,
          'fast' => 1,
          'eben' => 1,
          'endlich' => 1,
          'information' => 1,
          'informationen' => 1,
          'anfangs' => 1,
          'bald' => 1,
          'damals' => 1,
          'dann' => 1,
          'eher' => 1,
          'heutzutage' => 1,
          'mittlerweile' => 1,
          'neulich' => 1,
          'nun' => 1,
          'seitdem' => 1,
          'zugleich' => 1,
          'zuletzt' => 1,
          'schliesslich' => 1,
          'seither' => 1,
          'heute' => 1,
          'morgen' => 1,
          'gestern' => 1,
          'inzwischen' => 1,
          'jetzt' => 1,
          'uebermorgen' => 1,
          'vorerst' => 1,
          'vorhin' => 1,
          'abends' => 1,
          'danach' => 1,
          'frueher' => 1,
          'beizeiten' => 1,
          'haeufig' => 1,
          'oft' => 1,
          'oftmals' => 1,
          'manchmal' => 1,
          'gelegentlich' => 1,
          'bisweilen' => 1,
          'zuweilen' => 1,
          'mitunter' => 1,
          'selten' => 1,
          'einmal' => 1,
          'zweimal' => 1,
          'dreimal' => 1,
          'mehrmals' => 1,
          'abends' => 1,
          'normalerweise' => 1,
          'nachts' => 1,
          'dienstags' => 1,
          'lange' => 1,
          'immer' => 1,
          'noch' => 1,
          'zeitlebens' => 1,
          'stets' => 1,
          'always' => 1,
          'schon' => 1,
          'bisher' => 1,
          'weitgehend' => 1,
          'erstmals' => 1,
          'nahe' => 1,
          'lately' => 1,
          'never' => 1,
          'often' => 1,
          'rarely' => 1,
          'woanders' => 1,
          'kuenftig' => 1,
          'recently' => 1,
          'sometimes' => 1,
          'soon' => 1,
          'today' => 1,
          'tomorrow' => 1,
          'usually' => 1,
          'yesterday' => 1,
          'entfernt' => 1,
};

define action builtin_has_time_place_adverbs_suffix with var word do
    if var word matches /haft$/ do
        do return with 1
    done
    if var word matches /time_/ do
        do return with 1
    done
    if var word matches /^am_/ do
        do return with 1
    done
    do return with 0
done

set multi-line new global hash builtin_verb_prefixes to {
          'hinter' => 1,
          'auf' => 1,
          'hin' => 1,
          'hinzu' => 1,
          'dazu' => 1,
          'rauf' => 1,
          'herauf' => 1,
          'hinab' => 1,
          'hinunter' => 1,
          'hin' => 1,
          'her' => 1,
          'an' => 1,
          'ab' => 1,
          'zusammen' => 1,
          'vor' => 1,
          'nach' => 1,
          'zurueck' => 1,
          'weg' => 1,
          'zer' => 1,
          'her' => 1,
          'unter' => 1,
          'neben' => 1,
          'herunter' => 1,
          'mit' => 1,
          'zwischen' => 1,
          'um' => 1,
          'durch' => 1,
          'aus' => 1,
          'fest' => 1,
};

set multi-line new global hash builtin_verb_prefixes_no_split to {
#          'auf' => 1,
          'hin' => 1,
          'aus' => 1,
          'an' => 1,
          'unter' => 1,
};

set multi-line new global hash builtin_verb_prefixes_with_auxiliary_verbs to {
          'an' => 1, # anhaben
};

set multi-line new global hash builtin_auxiliary_verbs to {
          'bin' => 1,
          'bist' => 1,
          'ist' => 1,
          'sind' => 1,
          'seid' => 1,
          
          'habe' => 1,
          'hab' => 1,
          'hast' => 1,
          'hat' => 1,
          'haben' => 1,
          'habt' => 1,
          
          'werde' => 1,
          'werd' => 1,
          'wirst' => 1,
          'wird' => 1,
          'werden' => 1,
          'werdet' => 1,
          
          'kann' => 1,
          'kannst' => 1,
          'kann' => 1,
          'koennen' => 1,
          'koennt' => 1,
          
          'will' => 1,
          'willst' => 1,
          'will' => 1,
          'wollen' => 1,
          'wollt' => 1,

          'moechte' => 1,
          'moechtest' => 1,
          'moechten' => 1,
          'moechtet' => 1,
          
          'muss' => 1,
          'musst' => 1,
          'muss' => 1,
          'muessen' => 1,
          'muesst' => 1,
          
          'bin/be' => 1,
          'bist/be' => 1,
          'ist/be' => 1,
          'sind/be' => 1,
          'seid/be' => 1,
          
          'habe/have' => 1,
          'hab/have' => 1,
          'hast/have' => 1,
          'hat/have' => 1,
          'haben/have' => 1,
          'habt/have' => 1,
          
          'werde' => 1,
          'werd' => 1,
          'wirst' => 1,
          'wird' => 1,
          'werden' => 1,
          'werdet' => 1,
          
          'wurde' => 1,
          'wurdest' => 1,
          'wurden' => 1,
          'wurdet' => 1,
          
          'kann/can' => 1,
          'kannst/can' => 1,
          'kann/can' => 1,
          'koennen/can' => 1,
          'koennt/can' => 1,
          
          'will/want' => 1,
          'willst/want' => 1,
          'will/want' => 1,
          'wollen/want' => 1,
          'wollt/want' => 1,
          
          'muss/must' => 1,
          'musst/must' => 1,
          'muss/must' => 1,
          'muessen/must' => 1,
          'muesst/must' => 1,
};

set multi-line new global hash builtin_part_of_speech to {
          'abends' => "adj",
          'aber' => "adj",
          'about' => "prep",
          'ab' => "prep",
          'ab' => "prep",
          'acht' => "adj",
          'achte' => "adj",
          'achtzehn' => "adj",
          'achtzehnte' => "adj",
          'achzig' => "adj",
          'aerobe' => "n",
          'against' => "prep",
          'ah' => "n",
          'alle' => "adj",
          'allerdings' => "adj",
          'allerliebst' => "adj",
          'alles' => "n",
          'allgemein' => "adj",
          'allgemeine' => "adj",
          'allgemeinem' => "adj",
          'allgemeinen' => "adj",
          'allgemeiner' => "adj",
          'allgemeines' => "adj",
          'als' => "prep",
          'alt' => "adj",
          'alt' => "adj",
          'always' => "adj",
          'am' => "prep",
          'a' => "n",
          '(a)' => "art",
          'anbrennen' => "v",
          'andere' => "adj",
          'anderen' => "adj",
          'andererseits' => "adj",
          'anders' => "adj",
          'and' => "linking",
          'anfangs' => "adj",
          'angst' => "n",
          'anhaben' => "v",
          'anhaeltst' => "v",
          'anhalten' => "v",
          'anhalte' => "v",
          'an' => "prep",
          'an' => "prep",
          'anstatt' => "questionword",
          '$$anyone$$' => "n",
          'arbeiten' => "v",
          'arbeite' => "v",
          'arena' => "n",
          'are' => "v",
          'arg' => "adj",
          'arm' => "adj",
          'Arm' => "n",
          '$$aswellas$$' => "adj",
          'atomar' => "adj",
          'atomaren' => "adj",
          'auch' => "adj",
          'auch' => "adj",
          'auf' => "prep",
          'auf' => "prep",
          'ausdruecke' => "n",
          'aus' => "prep",
          'aus' => "prep",
          'aussagen' => "n",
          'Aussagen' => "n",
          'Aussehen' => "n",
          'aussehen' => "v",
          'aussen' => "adj",
          'baeren' => "n",
          'baer' => "n",
          'bald' => "adj",
          'bar' => "adj",
          'barocke' => "adj",
          'barock' => "n",
          'barsch' => "adj",
          'baut' => "v",
          'because' => "questionword",
          'bedeuten' => "v",
          'bedeutet' => "v",
          'beeinflussend' => "adj",
          'beeinflussen' => "v",
          'beeinflusse' => "v",
          'beeinflusst' => "v",
          'beendet' => "v",
          'beiden' => "adj",
          'beiderseits' => "adj",
          'bei' => "prep",
          'beispielsweise' => "adj",
          'beizeiten' => "adj",
          'bekannt' => "adj",
          'beleidigt' => "adj",
          'benachbart' => "adj",
          'benachbarte' => "adj",
          'bereit' => "adj",
          'bereits' => "adj",
          'berg' => "n",
          'Berichten' => "n",
          'berichten' => "v",
          'bern' => "n",
          'beruehmt' => "adj",
          'beruehmte' => "adj",
          'beruehmtest' => "adj",
          'berufe' => "n",
          'berufen' => "v",
          'berufe' => "v",
          'beruf' => "n",
          'beruf' => "n",
          'berufst' => "v",
          'beruhen' => "v",
          'beruht' => "v",
          'beschaedigt' => "adj",
          'beschaeftigt' => "adj",
          'bescheiden' => "adj",
          'beschlagnahmt' => "adj",
          'beschlossen' => "v",
          'besetzt' => "adj",
          'besondere' => "adj",
          'besonderem' => "adj",
          'besonderen' => "adj",
          'besonderer' => "adj",
          'besonderes' => "adj",
          'besonders' => "adj",
          'best' => "adj",
          'beste' => "adj",
          'bestehende' => "adj",
          'bestehendem' => "adj",
          'bestehenden' => "adj",
          'bestehender' => "adj",
          'bestehendes' => "adj",
          'bestehen' => "v",
          'besteht' => "v",
          'bett' => "n",
          'between' => "prep",
          'be' => "v",
          'bewahren' => "v",
          'bewusst' => "adj",
          'bezeichnen' => "v",
          'bezeichnet' => "v",
          'biblisch' => "adj",
          'biblische' => "adj",
          'biblischem' => "adj",
          'biblischen' => "adj",
          'biblischer' => "adj",
          'biblisches' => "adj",
          'bieder' => "adj",
          'bilden' => "v",
          'bildet' => "v",
          'bilde' => "v",
          'bin' => "v",
          'bisauf' => "prep",
          'bisher' => "adj",
          'bisin' => "prep",
          'bis' => "prep",
          'bist' => "v",
          'bisweilen' => "adj",
          'biszu' => "prep",
          'bitter' => "adj",
          'blank' => "adj",
          'blass' => "adj",
          'blau' => "adj",
          'bleib' => "v",
          'blind' => "adj",
          'blo?' => "adj",
          'bloed' => "adj",
          'bloss' => "adj",
          'b' => "n",
          'bockwurst' => "n",
          'boes' => "adj",
          'braucht' => "v",
          'brav' => "adj",
          'breit' => "adj",
          'bringen' => "v",
          'bringst' => "v",
          'bringt' => "v",
          'bring' => "v",
          'bruder' => "n",
          'brueder' => "n",
          'brunkhorst' => "n",
          'buergerprotest' => "n",
          'by' => "prep",
          'by' => "prep",
          'ca' => "adj",
          'cdu' => "n",
          'china' => "n",
          'c' => "n",
          'cooles' => "adj",
          'da' => "adj",
          'dafuer' => "questionword",
          'damals' => "adj",
          'damit' => "questionword",
          'danach' => "adj",
          'dann' => "adj",
          'darfst' => "v",
          'darf' => "v",
          'das' => "art",
          'dass' => "questionword",
          'dazu' => "prep",
          'dein' => "art",
          'deine' => "art",
          'deinem' => "art",
          'deinen' => "art",
          'deiner' => "art",
          'deins' => "n",
          'den' => "art",
          'dengleichen' => "adj",
          'denken' => "v",
          'denn' => "adj",
          'denselben' => "adj",
          'der' => "art",
          'derb' => "adj",
          'dere' => "adj",
          'deren' => "adj",
          'dererseits' => "adj",
          'ders' => "adj",
          'des' => "art",
          'deutsch' => "adj",
          'deutsche' => "adj",
          'dich' => "n",
          'dicht' => "adj",
          'dick' => "adj",
          'did' => "v",
          'die' => "art",
          'dienstags' => "adj",
          'dies' => "art",
          'diese' => "art",
          'diesem' => "art",
          'diesen' => "art",
          'dieser' => "art",
          'dieses' => "art",
          'dinge' => "n",
          'dingen' => "n",
          'dir' => "n",
          'd' => "n",
          'doch' => "inter",
          'done' => "adj",
          'doof' => "adj",
          'doppelt' => "adj",
          'dort' => "adj",
          'do' => "v",
          'drei' => "adj",
          'dreimal' => "adj",
          'dreissig' => "adj",
          'dreist' => "adj",
          'dreizehn' => "adj",
          'dreizehnte' => "adj",
          'dritte' => "adj",
          'drittem' => "adj",
          'dritten' => "adj",
          'dritter' => "adj",
          'drittes' => "adj",
          'droide' => "n",
          'droiden' => "n",
          'droid' => "n",
          'druesenendstueck' => "n",
          'duenn' => "adj",
          'duerfen' => "v",
          'duerfte' => "v",
          'duerr' => "adj",
          'duester' => "adj",
          'dumm' => "adj",
          'dumpf' => "adj",
          'du' => "n",
          'dunkel' => "adj",
          'durch' => "prep",
          'durch' => "prep",
          'durst' => "prep",
          'eben' => "adj",
          'ebenfalls' => "adj",
          'echt' => "adj",
          'edel' => "adj",
          'eher' => "adj",
          'eigen' => "adj",
          'ein' => "art",
          'ein'  => "art",
          'eine' => "art",
          'eine'  => "art",
          'einem' => "art",
          'einem'  => "art",
          'einem'  => "art",
          'einen' => "art",
          'einer' => "art",
          'einer'  => "art",
          'einerseits' => "adj",
          'eines' => "art",
          'eines'  => "art",
          'eingenommen' => "v",
          'eingestellt' => "adj",
          'einkaufen' => "v",
          'einmal' => "adj",
          'eins' => "adj",
          'einstein' => "n",
          'elend' => "adj",
          'elend' => "adj",
          'Elend' => "n",
          'elf' => "adj",
          'elfte' => "adj",
          'elter' => "n",
          'eltern' => "n",
          'e' => "n",
          'enden' => "v",
          'enden' => "v",
          'endeten' => "v",
          'endete' => "v",
          'endet' => "v",
          'endlich' => "adj",
          'ends' => "adj",
          'eng' => "adj",
          'en' => "n",
          'entfernt' => "adj",
          'ent' => "prep",
          'enumall' => "v",
          'equal' => "v",
          'erbaut' => "v",
          'erfand' => "v",
          'erfunden' => "adj",
          'erfunden' => "v",
          'erklaeren' => "v",
          'er' => "n",
          'ernst' => "adj",
          'er' => "prep",
          'erst' => "adj",
          'erste' => "adj",
          'erstem' => "adj",
          'ersten' => "adj",
          'erster' => "adj",
          'erstes' => "adj",
          'erstmals' => "adj",
          'erweitern' => "v",
          'erzaehlen' => "v",
          'es' => "n",
          'essen' => "v",
          'etwa' => "adj",
          'euch' => "n",
          'euer' => "art",
          'eueren' => "art",
          'eueres' => "art",
          'euers' => "art",
          'eurem' => "art",
          'euren' => "art",
          'eures' => "art",
          'everest' => "n",
          'ewig' => "adj",
          'existiert' => "v",
          'fade' => "adj",
          'faehrst' => "v",
          'fahl' => "adj",
          'fahren' => "v",
          'fahre' => "v",
          'fair' => "adj",
          'falls' => "questionword",
          'falsch' => "adj",
          'falsche' => "adj",
          '_false_' => "adj",
          '_(false)_' => "adj",
          'fangs' => "adj",
          'farbe' => "n",
          'fast' => "adj",
          'faul' => "adj",
          'faust' => "n",
          'fehler' => "n",
          'feig' => "adj",
          'fein' => "adj",
          'fern' => "adj",
          'Fernsehen' => "n",
          'fernsehen' => "v",
          'fesch' => "adj",
          'fest' => "adj",
          'fest' => "prep",
          'fett' => "adj",
          'feucht' => "adj",
          'fidel' => "adj",
          'fies' => "adj",
          'film' => "n",
          'financial' => "adj",
          'finden'  => "v",
          'findest' => "v",
          'findet' => "v",
          'finster' => "adj",
          'fix' => "adj",
          'flach' => "adj",
          'flau' => "adj",
          'fliegen' => "v",
          'flink' => "adj",
          'fluchen' => "v",
          'flughafen' => "n",
          'f' => "n",
          'folgende' => "adj",
          'for' => "prep",
          'forsch' => "adj",
          'Fragen' => "n",
          'fragen' => "v",
          'frankreich' => "n",
          'frech' => "adj",
          'freehal' => "n",
          'frei' => "adj",
          'frei' => "prep",
          'fremd' => "adj",
          'freuen' => "v",
          'freue' => "v",
          'freust' => "v",
          'freut' => "v",
          'froh' => "adj",
          'fromm' => "adj",
          'frost' => "n",
          'frueh' => "adj",
          'frueher' => "adj",
          'fuehlen' => 'vi',
          'fuehle' => "v",
          'fuehlst' => "v",
          'fuenf' => "adj",
          'fuenfte' => "adj",
          'fuenfzehn' => "adj",
          'fuenfzehnte' => "adj",
          'fuenfzig' => "adj",
          'fuer' => "prep",
          'fuerchte' => "v",
          'fuerchten' => "v",
          'fuerchtest' => "v",
          'fuerst' => "n",
          'funden' => "adj",
          'f=>' => "v",
          'gab' => "v",
          'ganz' => "adj",
          'gebaeren' => "v",
          'geben' => "v",
          'geboren' => "v",
          'geborgenheit' => "n",
          'geduld' => "n",
          'gegen' => "prep",
          'gegenueber' => "prep",
          'gehen' => "v",
          'gehe' => "v",
          'gehirn' => "n",
          'gehoeren' => "v",
          'gehoert' => "v",
          'gehst' => "v",
          'geht' => "v",
          'geh' => "v",
          'geil' => "adj",
          'gelb' => "adj",
          'gelegentlich' => "adj",
          'gelten' => "v",
          'gemein' => "adj",
          'genau' => "adj",
          'genauso' => "adj",
          'german' => "adj",
          'gern' => "adj",
          'gerne' => "adj",
          'gesamt' => "adj",
          'gespielt' => "v",
          'gestern' => "adj",
          'gestorben' => "v",
          'gesund' => "adj",
          'gewaschen' => "v",
          'gewesen' => "v",
          'gilt' => "v",
          'gilt'   => "v",
          'glatt' => "adj",
          'gleich' => "adj",
          'gottesdienst' => "n",
          'gratis' => "adj",
          'gro?' => "adj",
          'grob' => "adj",
          'gross' => "adj",
          'grosses' => "adj",
          'gruen' => "adj",
          'grundlegend' => "adj",
          'gst' => "n",
          'gut' => "adj",
          'gut' => "adj",
          'gute' => "adj",
          'gutem' => "adj",
          'guten' => "adj",
          'guter' => "adj",
          'gutes' => "adj",
          'haben' => "v",
          'habe' => "v",
          'hacker' => "n",
          'hackt' => "v",
          'haeltst' => "v",
          'haelt' => "v",
          'haetten' => "v",
          'haettest' => "v",
          'haette' => "v",
          'hager' => "adj",
          'halb' => "adj",
          'halben' => "adj",
          'halten' => "v",
          'halte' => "v",
          'hand' => "n",
          'harsch' => "adj",
          'hart' => "adj",
          'hase' => "n",
          'hast' => "v",
          'has' => "v",
          'hattest' => "v",
          'hatte' => "v",
          'hat' => "v",
          'haeufig' => "adj",
          'haupt' => "adj",
          'hauptstadt' => "n",
          'hautfarbe' => "n",
          'hautfarben' => "n",
          'have' => "v",
          'hehr' => "adj",
          'hei?' => "adj",
          'heikel' => "adj",
          'heil' => "adj",
          'heiser' => "adj",
          'heise' => "v",
          'heissen' => "v",
          'heisser' => "adj",
          'heisse' => "v",
          'heisst' => "v",
          'heiter' => "adj",
          'hell' => "adj",
          'her' => "adj",
          'herauf' => "prep",
          'herb' => "adj",
          'her' => "prep",
          'herunter' => "prep",
          'herz' => "n",
          'hessen' => "n",
          'heute' => "adj",
          'heutzutage' => "adj",
          'hier' => "adj",
          'hinab' => "prep",
          'hin' => "adj",
          'hin' => "prep",
          'hinunter' => "prep",
          'hinzu' => "prep",
          'hirn' => "n",
          'h' => "n",
          'hoch' => "adj",
          'hoechst' => "adj",
          'hoechste' => "adj",
          'hoechster' => "adj",
          'hoeren' => "v",
          '(hoh)' => "adj",
          'hohl' => "adj",
          'hold' => "adj",
          'how' => "questionword",
          'huebsch' => "adj",
          'hundert' => "adj",
          'hunderte' => "adj",
          'hunderttausend' => "adj",
          'ich' => "n",
          'if' => "questionword",
          'ihr' => "art",
          'ihre' => "art",
          'ihrem' => "art",
          'ihren' => "art",
          'ihrer' => "art",
          'ihres' => "n",
          'immer' => "adj",
          'im' => "prep",
          'inka' => "n",
          'inkas' => "n",
          'innen' => "adj",
          'in' => "prep",
          'in' => "prep",
          'insoweit' => "adj",
          'intakt' => "adj",
          'intelligent' => "adj",
          'interessieren' => "v",
          'interessiere' => "v",
          'interessiere' => "v",
          'interessierst' => "v",
          'internet' => "n",
          'inzwischen' => "adj",
          'io' => "n",
          'ist-mit' => "v",
          'ist' => "v",
          'isunknown' => "v",
          'is' => "v",
          'jaeh' => "adj",
          'jahre' => "n",
          'jeck' => "adj",
          'jede' => "adj",
          'jedem' => "adj",
          'jeden' => "adj",
          '_jeden_tag_' => "adj",
          'jeder' => "adj",
          'jedes' => "adj",
          'jedoch'  => "adj",
          'jedoch' => "questionword",
          'jetzt' => "adj",
          'jeweils' => "adj",
          'j' => "n",
          'jung' => "adj",
          'jungem' => "adj",
          'jungen' => "adj",
          'junger' => "adj",
          'junges' => "adj",
          'kahl' => "adj",
          'kalt' => "adj",
          'kalte' => "adj",
          'kannst' => "v",
          'kann' => "v",
          'kann' => "v",
          'kaputt' => "adj",
          'karg' => "adj",
          'kein' => "adj",
          'keine' => "adj",
          'keinem' => "adj",
          'keinen' => "adj",
          'keiner' => "adj",
          'keines' => "adj",
          'keinesfalls' => "adj",
          'keineswegs' => "adj",
          'kenne' => "v",
          'kennst' => "v",
          'kenn' => "v",
          'kess' => "adj",
          'keusch' => "adj",
          'kinder' => "n",
          'kindern' => "n",
          'klamm' => "adj",
          'klar' => "adj",
          'klein' => "adj",
          'kleinste' => "adj",
          'klug' => "adj",
          'knapp' => "adj",
          'komma' => 10,
          'kompliziert' => "adj",
          'konservativ' => "adj",
          'konservativen' => "adj",
          'krank' => "adj",
          'krass' => "adj",
          'kraus' => "adj",
          'krude' => "adj",
          'krumm' => "adj",
          'kuehl' => "adj",
          'kuehn' => "adj",
          'kuenftig' => "adj",
          'kunst' => "n",
          'kurfuerst' => "n",
          'kurz' => "adj",
          'lahm' => "adj",
          'lang' => "adj",
          'lange' => "adj",
          'lasch' => "adj",
          'lassen' => "v",
          'lately' => "adj",
          'lau' => "adj",
          'laut' => "adj",
          'lauter' => "adj",
          '_laut_' => "prep",
          'lax' => "adj",
          'Leben' => "n",
          'leben' => "v",
          'lebe' => "v",
          'lebewesen' => "n",
          'leck' => "adj",
          'leer' => "adj",
          'leicht' => "adj",
          'leichte' => "adj",
          'leichtem' => "adj",
          'leichten' => "adj",
          'leichter' => "adj",
          'leichtes' => "adj",
          'leise' => "adj",
          'lernen' => "v",
          'letzt' => "adj",
          'licht' => "adj",
          'licht' => "n",
          'lieb' => "adj",
          'Liebe' => "n",
          'lieben' => "v",
          'liebe' => "v",
          'lieblingsessen' => "n",
          'liegen' => "v",
          'liege' => "v",
          'liegst' => "v",
          'liegt' => "v",
          'lind' => "adj",
          'link' => "adj",
          'linke' => "adj",
          'linkem' => "adj",
          'linken' => "adj",
          'linker' => "adj",
          'linkes' => "adj",
          '/' => "linking",
          '&' => "linking",
          'links' => "adj",
          'locker' => "adj",
          'loesung' => "n",
          'logic' => "adj",
          '_logic_' => "adj",
          '_(logic)_' => "adj",
          'Luege' => "n",
          'Luegen' => "n",
          'luegen' => "v",
          'luege' => "v",
          'lust' => "n",
          'machen' => "v",
          'mache' => "v",
          'Macht' => "n",
          'macht' => "v",
          'macht' => "v",
          'mager' => "adj",
          'magst' => "v",
          'mag' => "v",
          'mal' => "adj",
          'manchmal' => "adj",
          'man' => "n",
          '_maybe_' => "adj",
          '_(maybe)_' => "adj",
          'mehr' => "adj",
          'mehrals' => "prep",
          'mehrmals' => "adj",
          'mein' => "art",
          'meine' => "art",
          'meinem' => "art",
          'meinen' => "art",
          'meiner' => "art",
          'meins' => "n",
          'meintest' => "v",
          'meinte' => "v",
          'meint' => "v",
          'meinung' => "n",
          'meiste' => "adj",
          'meisten' => "adj",
          'merken' => "v",
          'mich' => "n",
          'mies' => "adj",
          'mild' => "adj",
          'milliarde' => "adj",
          'milliarden' => "adj",
          'million' => "adj",
          'millionen' => "adj",
          'mir' => "n",
          'mit' => "prep",
          'mit' => "prep",
          'mittels' => "prep",
          'mitten' => "prep",
          'mittlerweile' => "adj",
          'mitunter' => "adj",
          'mochten' => "v",
          'mochtest' => "v",
          'mochte' => "v",
          'moechten' => "v",
          'moechtest' => "v",
          'moechte' => "v",
          'moegen' => "v",
          'mond' => "n",
          'monoton' => "adj",
          'monotone' => "adj",
          'monotonem' => "adj",
          'monotonen' => "adj",
          'monotoner' => "adj",
          'monotones' => "adj",
          'morgen' => "adj",
          'morsch' => "adj",
          'm' => "questionword",
          'muede' => "adj",
          'muedem' => "adj",
          'mueden' => "adj",
          'mueder' => "adj",
          'muedes' => "adj",
          'muerbe' => "adj",
          'muessen' => "v",
          'muessten' => "v",
          'mund' => "n",
          'munter' => "adj",
          'musst' => "v",
          'muss' => "v",
          'must' => "v",
          'my' => "art",
          'nachdem' => "questionword",
          'nachher' => "adj",
          'nachnamen' => "n",
          'nach' => "prep",
          'nach' => "prep",
          '_nach_' => "prep",
          'nachts' => "adj",
          'nackt' => "adj",
          'nah' => "adj",
          'nahe' => "adj",
          'nahm' => "v",
          'name' => "n",
          'namen' => "n",
          'nass' => "adj",
          'natural' => "adj",
          'neben' => "prep",
          'neben' => "prep",
          'nehme' => "v",
          'nein' => "n",
          'Nein' => "n",
          'nen' => "adj",
          'nett' => "adj",
          'netzen' => "n",
          'neu' => "adj",
          'neue' => "adj",
          'neuem' => "adj",
          'neuen' => "adj",
          'neuer' => "adj",
          'neues' => "adj",
          'neulich' => "adj",
          'neun' => "adj",
          'neunte' => "adj",
          'neunzehn' => "adj",
          'neunzehnte' => "adj",
          'neunzig' => "adj",
          'never' => "adj",
          'nicht' => "adj",
          'nieder' => "adj",
          'niemand' => "n",
          'nil' => "n",
          'noch' => "adj",
          'no-question' => "qq",
          '_no-question_' => "qq",
          'normalerweise' => "adj",
          'not' => "adj",
          '$$notaswellas$$' => "adj",
          'nothing' => "n",
          'now' => "adj",
          'nst' => "adj",
          'nudeln' => "n",
          'nun' => "adj",
          'nur' => "adj",
          'nutte' => "n",
          'ob' => "questionword",
          'obschon' => "questionword",
          'oder' => "linking",
          'oede' => "adj",
          'offen' => "adj",
          'offenbar' => "adj",
          'offiziell' => "adj",
          'offline' => "adj",
          'of' => "prep",
          'oft' => "adj",
          'often' => "adj",
          'oftmals' => "adj",
          'ohne' => "prep",
          'online' => "adj",
          'on' => "prep",
          'opposite' => "v",
          'ordinaer' => "adj",
          'ordinaerer' => "adj",
          'or' => "linking",
          'our' => "art",
          'out' => "prep",
          'page' => "n",
          'pages' => "n",
          'papst' => "n",
          'Papst' => "n",
          'per' => "prep",
          'plump' => "adj",
          'Pokern' => "n",
          'pokern' => "v",
          'prall' => "adj",
          'programmfehler' => "n",
          'protest' => "n",
          'pulls' => "v",
          'pur' => "adj",
          '_q_' => "adj",
          'q=>' => "v",
          'rank' => "adj",
          'rar' => "adj",
          'rarely' => "adj",
          'rasch' => "adj",
          'rau' => "adj",
          'rauf' => "prep",
          'rauh' => "adj",
          'reasonof' => "v",
          'recently' => "adj",
          'rechnen' => "v",
          'recht' => "adj",
          'rechte' => "adj",
          'rechtem' => "adj",
          'rechten' => "adj",
          'rechter' => "adj",
          'rechtes' => "adj",
          'rechts' => "adj",
          'reden' => "v",
          'rege' => "adj",
          'regen' => "n",
          'reich' => "adj",
          'rein' => "adj",
          'reizen' => "v",
          'roh' => "adj",
          'rot' => "adj",
          'r' => "questionword",
          'rueckwaerts' => "adj",
          'rund' => "adj",
          'sacht' => "adj",
          'saeugetier' => "n",
          'sagen' => "v",
          'sage' => "v",
          'sagst' => "v",
          'sanft' => "adj",
          'satt' => "adj",
          'sauber' => "adj",
          'sauer' => "adj",
          'scharf' => "adj",
          'schauen' => "v",
          'schaue' => "v",
          'schaust' => "v",
          'scheel' => "adj",
          'schenke' => "v",
          'schenkte' => "v",
          'schick' => "adj",
          'schief' => "adj",
          'schier' => "adj",
          'schimpfwort' => "n",
          'schlaff' => "adj",
          'schlank' => "adj",
          'schlapp' => "adj",
          'schlau' => "adj",
          'schlecht' => "adj",
          'schlimm' => "adj",
          'schmal' => "adj",
          'schmerzen' => "n",
          'schmuck' => "adj",
          'schnecke' => "n",
          'schnecken' => "n",
          'schneiden' => "v",
          'schneidet' => "v",
          'schnell' => "adj",
          'schneller' => "adj",
          'schnoede' => "adj",
          'schoen' => "adj",
          'schon' => "adj",
          'schraeg' => "adj",
          'schreiben' => "v",
          'schrill' => "adj",
          'schroff' => "adj",
          'schuechtern' => "adj",
          'schuetter' => "adj",
          'schwach' => "adj",
          'schwanger' => "adj",
          'schwarz' => "adj",
          'schwer' => "adj",
          'schwuel' => "adj",
          'schwul' => "adj",
          'sechs' => "adj",
          'sechste' => "adj",
          'sechzehn' => "adj",
          'sechzehnte' => "adj",
          'sechzig' => "adj",
          'sehen' => "v",
          'sehe' => "v",
          'sehr' => "adj",
          'seh' => "v",
          'seine' => "art",
          'seinem' => "art",
          'seinen' => "art",
          'seiner' => "art",
          'seins' => "n",
          'sein' => "v",
          'seitdem' => "adj",
          'seither' => "adj",
          'seit' => "prep",
          'selbe' => "adj",
          'selten' => "adj",
          'sen' => "adj",
          'setzen' => "v",
          'sicher' => "adj",
          'sich' => "n",
          'sieben' => "adj",
          'siebte' => "adj",
          'siebzehn' => "adj",
          'siebzehnte' => "adj",
          'siebzig' => "adj",
          'siehst' => "v",
          'sie' => "n",
          'simpel' => "adj",
          'simple' => "adj",
          'sind' => "v",
          'sobald' => "questionword",
          'sollen' => "v",
          'solle' => "v",
          'sollten' => "v",
          'sollte' => "v",
          'sollt' => "v",
          'soll' => "v",
          'sometimes' => "adj",
          'sondern' => "prep",
          'soon' => "adj",
          'soviel' => "adj",
          'soweit' => "adj",
          'sowie' => "prep",
          'sowohl' => "prep",
          'spaet' => "adj",
          'spaeter' => "adj",
          'spd' => "n",
          'Speisen' => "n",
          'speisen' => "v",
          'spielen' => "v",
          'spielst' => "v",
          'spielt' => "v",
          'spitz' => "adj",
          'sprechen' => "v",
          'spreche' => "v",
          'spricht' => "v",
          'sproede' => "adj",
          'stand' => "v",
          'stark' => "adj",
          'starr' => "adj",
          'statt' => "prep",
          'ste' => "adj",
          'stehen' => "v",
          'stehst' => "v",
          'steht' => "v",
          'steif' => "adj",
          'steil' => "adj",
          'stem' => "adj",
          'sten' => "adj",
          'ster' => "adj",
          'sterben' => "v",
          'sterbe' => "v",
          'stes' => "adj",
          'stet' => "adj",
          'stets' => "adj",
          'stifte' => "n",
          'stiften' => "n",
          'stiftet' => "v",
          'stift' => "n",
          'still' => "adj",
          'stirbt' => "v",
          'stmals' => "adj",
          'stolz' => "adj",
          'streng' => "adj",
          'studiert' => "v",
          'stumm' => "adj",
          'stumpf' => "adj",
          'stur' => "adj",
          'suche' => "v",
          'suchst' => "v",
          'sue?' => "adj",
          'tag' => "n",
          'takt' => "adj",
          'tal' => "n",
          'tapfer' => "adj",
          'taub' => "adj",
          'tauchen' => "v",
          'tauche' => "v",
          'tauchst' => "v",
          'taucht' => "v",
          'tausend' => "adj",
          'tausende' => "adj",
          'teils' => "prep",
          'telligent' => "adj",
          'ten' => "prep",
          'teressieren' => "v",
          'teressiere' => "v",
          'teressierst' => "v",
          'testen' => "v",
          'test' => "n",
          'teuer' => "adj",
          'that' => "art",
          'the' => "art",
          'their' => "art",
          'this' => "art",
          'tief' => "adj",
          'tiere' => "n",
          'tlerweile' => "adj",
          'today' => "adj",
          'tod' => "n",
          'toll' => "adj",
          'tomorrow' => "adj",
          'to' => "prep",
          '_to_' => "questionword",
          'tot' => "adj",
          'traege' => "adj",
          'trage' => "v",
          'tree' => "n",
          'trees' => "n",
          'treu' => "adj",
          'trinken' => "v",
          'trocken' => "adj",
          '_true_' => "adj",
          '_(true)_' => "adj",
          'trueb' => "adj",
          'ts' => "adj",
          'tumb' => "adj",
          'tun' => "v",
          'uebermorgen' => "adj",
          'uebel' => "adj",
          'ueben' => "v",
          'ueberhaupt' => "adj",
          'uebernahm' => "v",
          'ueber' => "prep",
          'ueber' => "prep",
          'uebe' => "v",
          'uebst' => "v",
          'uebt' => "v",
          'uhr' => "n",
          'um' => "prep",
          'um' => "prep",
          'und' => "linking",
          'unerlaubt' => "adj",
          'unerlaubte' => "adj",
          'unerlaubtem' => "adj",
          'unerlaubten' => "adj",
          'unerlaubter' => "adj",
          'unerlaubtes' => "adj",
          'ungefaehr' => "adj",
          'universitaet' => "n",
          'unreif' => "adj",
          'unreife' => "adj",
          'unreifem' => "adj",
          'unreifen' => "adj",
          'unreifer' => "adj",
          'unreifes' => "adj",
          'unsere' => "art",
          'unserem' => "art",
          'unseren' => "art",
          'unseres' => "art",
          'uns' => "n",
          'unterhalten' => "v",
          'unter' => "prep",
          'unter' => "prep",
          'untertauchen' => "v",
          'untertauche' => "v",
          'untertauchst' => "v",
          'untertaucht' => "v",
          'unterwegs' => "adj",
          'unterwelt' => "n",
          'us-amerikanisch' => "adj",
          'us-amerikanische' => "adj",
          'us-amerikanischem' => "adj",
          'us-amerikanischen' => "adj",
          'us-amerikanischer' => "adj",
          'us-amerikanisches' => "adj",
          'usually' => "adj",
          '~~~' => "v",
          '==' => "v",
          '=>' => "v",
          '=' => "v",
          'is-a' => "v",
          'is-part' => "v",
          'is-own' => "v",
          '=' => "v",
          '>>>' => "v",
          '->' => "v",
          '!=>' => "v",
          '?=>' => "v",
          'vereinigten' => "adj",
          'verfuegbar' => "adj",
          'verliebt' => "v",
          'verwendet' => "v",
          'verwirrt' => "adj",
          'viel' => "adj",
          'viele' => "adj",
          'vielen' => "adj",
          'vieler' => "adj",
          'vieles' => "adj",
          'vielleicht' => "adj",
          'vier' => "adj",
          'vierte' => "adj",
          'vierzehn' => "adj",
          'vierzehnte' => "adj",
          'vierzig' => "adj",
          'voll' => "adj",
          'volle' => "adj",
          'von' => "prep",
          'vorerst' => "adj",
          'vorher' => "adj",
          'vorhin' => "adj",
          'vornamen' => "n",
          'vor' => "prep",
          'vor' => "prep",
          'vorwaerts' => "adj",
          'wach' => "adj",
          'wacker' => "adj",
          'waehrend' => "questionword",
          'waerest' => "v",
          'waere' => "v",
          'waerst' => "v",
          'waerts' => "adj",
          'wahr' => "adj",
          'wann' => "questionword",
          'waren' => "v",
          'warm' => "adj",
          'warum' => "questionword",
          'war' => "v",
          'waschen' => "v",
          'was' => "questionword",
          'weder' => "prep",
          'wegen' => "prep",
          'weg' => "prep",
          'wegs' => "adj",
          'weh' => "adj",
          'weich' => "adj",
          'weilen' => "adj",
          'weil' => "questionword",
          'weise' => "adj",
          'Weiss' => "n",
          'weiss' => "adj",
          'weisswurst' => "n",
          'weit' => "adj",
          'weitgehend' => "adj",
          'welchem' => "questionword",
          'welchen' => "questionword",
          'welche' => "questionword",
          'welcher' => "questionword",
          'welches' => "questionword",
          'welch' => "questionword",
          'welk' => "adj",
          'welsch' => "adj",
          'welt' => "n",
          'weltweit' => "adj",
          'wem' => "questionword",
          'wenig' => "adj",
          'wenigerals' => "prep",
          'wenn' => "questionword",
          'wen' => "questionword",
          'werden' => "v",
          'werde' => "v",
          'wer' => "questionword",
          'wert' => "adj",
          'wesen' => "n",
          'weshalb' => "questionword",
          'west' => "adj",
          'what' => "questionword",
          'when' => "questionword",
          'where' => "questionword",
          'whether' => "questionword",
          'which' => "questionword",
          'who' => "questionword",
          'why' => "questionword",
          'wichtig' => "adj",
          'wichtige' => "adj",
          'wichtigem' => "adj",
          'wichtigen' => "adj",
          'wichtiger' => "adj",
          'wichtiges' => "adj",
          'wien' => "n",
          'wie' => "questionword",
          'wieso' => "questionword",
          'wild' => "adj",
          'willst' => "v",
          'will' => "v",
          'wird' => "v",
          'wir' => "n",
          'wirr' => "adj",
          'wirst' => "v",
          'Wissen' => "n",
          'wissen' => "v",
          'woanders' => "adj",
          'woher' => "questionword",
          'wohingegen' => "questionword",
          'wohin' => "questionword",
          'wohl' => "adj",
          'wohne' => "v",
          'wohnst' => "v",
          'wohnt' => "v",
          'wolltest' => "v",
          'wollte' => "v",
          'wo' => "questionword",
          'woran' => "questionword",
          'worauf' => "questionword",
          'wort' => "n",
          'worum' => "questionword",
          'Wuerde' => "n",
          'wuerden' => "v",
          'wuerdest' => "v",
          'wuerde' => "v",
          'wuest' => "adj",
          'wund' => "adj",
          'wurden' => "v",
          'wurdest' => "v",
          'wurde' => "v",
          'xxtoxx' => "questionword",
          'XXtoXX' => "questionword",
          'yesterday' => "adj",
          'your' => "art",
          'zaeh' => "adj",
          'zahm' => "adj",
          'zart' => "adj",
          'zehn' => "adj",
          'zehntausend' => "adj",
          'zehnte' => "adj",
          'zeichen' => "n",
          'zeitlebens' => "adj",
          'zer' => "prep",
          'zier' => "n",
          'zone' => "n",
          'zonen' => "n",
          'zufrieden' => "adj",
          'zugleich' => "adj",
          'zuletzt' => "adj",
          'zum' => "adj",
          'zum' => "questionword",
          'zunaechst' => "adj",
          'zu' => "prep",
          'zur' => "questionword",
          'zurueck' => "prep",
          'zusammen' => "adj",
          'zusammen' => "prep",
          'zuweilen' => "adj",
          'zwanzig' => "adj",
          'zwanzigste' => "adj",
          'zwei' => "adj",
          'zweimal' => "adj",
          'zweite' => "adj",
          'zweitem' => "adj",
          'zweiten' => "adj",
          'zweiter' => "adj",
          'zweites' => "adj",
          'zwischen' => "prep",
          'zwischen' => "prep",
          'zwoelf' => "adj",
          'zwoelfte' => "adj",
};

set multi-line new global hash builtin_time_relations to {
        "heute" =>                  [ 24*60*60,      0      ],
        "gestern" =>                [ 24*60*60,      -1     ],
        "vorgestern" =>             [ 24*60*60,      -2     ],
        "vorvorgestern" =>          [ 24*60*60,      -3     ],
        "morgen" =>                 [ 24*60*60,      +1     ],
        "uebermorgen" =>            [ 24*60*60,      +2     ],
        "ueberuebermorgen" =>       [ 24*60*60,      +3     ],
        "in-tagen" =>               [ 24*60*60,      +1     ],
        "vor-tagen" =>              [ 24*60*60,      -1     ],
        
        "diese woche" =>            [ 7*24*60*60,    0      ],
        "letzte woche" =>           [ 7*24*60*60,    -1     ],
        "vorletzte woche" =>        [ 7*24*60*60,    -2     ],
        "naechste woche" =>         [ 7*24*60*60,    +1     ],
        "uebernaechste woche" =>    [ 7*24*60*60,    +2     ],
        "in-wochen" =>              [ 7*24*60*60,    +1     ],
        "vor-wochen" =>             [ 7*24*60*60,    -1     ],
        
        "in viertelstunde" =>       [ 15*60,         +1     ],
        "vor viertelstunde" =>      [ 15*60,         -1     ],
        "in halbe stunde" =>        [ 30*60,         +1     ],
        "vor halbe stunde" =>       [ 30*60,         -1     ],
        "in dreiviertelstunde" =>   [ 45*60,         +1     ],
        "vor dreiviertelstunde" =>  [ 45*60,         -1     ],
        "in stunde" =>              [ 60*60,         +1     ],
        "vor stunde" =>             [ 60*60,         -1     ],
        "in-stunden" =>             [ 60*60,         +1     ],
        "vor-stunden" =>            [ 60*60,         -1     ],
        
};

set new global array builtin_time_relations_names to an empty array
set items of global array builtin_time_relations_names to keys with items of hash builtin_time_relations

define action time_pre_transformations with var sentence, var lang, var path do
    do regex using var sentence: /(in|vor)\s*?einer\s*?(<[a-zA-Z]>*?stund<[a-zA-Z]>*?)(\s|$)/, "$0 $1$2", :global:i
    do regex using var sentence: /(in|vor)\s*?(<[0-9]>+?)\s*?(stunden|wochen|tagen)/, "$1* $0-$2", :global:i
    do regex using var sentence: /(te|se)<[rnmt]>?\s*?(stunde|woche|tage)/, "$0 $1", :global:i
    do regex using var sentence: /Anfang (letzter|dieser|naechster)/, "$0", :global:i
    do regex using var sentence: /(^|\s)an dem (\d+?\.\d+?\.\d+?)(\s|$)/, " am-$1 ", :global:i
    do regex using var sentence: /(^|\s)am (\d+?\.\d+?\.\d+?)(\s|$)/, " am-$1 ", :global:i
    do regex using var sentence: /(^|\s)(?:von|seit|ab) dem (\d+?\.\d+?\.\d+?)(\s|$)/, " vom-$1 ", :global:i
    do regex using var sentence: /(^|\s)(?:von|seit|ab) (\d+?\.\d+?\.\d+?)(\s|$)/, " vom-$1 ", :global:i
    do regex using var sentence: /(^|\s)vom (\d+?\.\d+?\.\d+?)(\s|$)/, " vom-$1 ", :global:i
    do regex using var sentence: /(^|\s)bis zu dem (\d+?\.\d+?\.\d+?)(\s|$)/, " bis-$1 ", :global:i
    do regex using var sentence: /(^|\s)bis zum (\d+?\.\d+?\.\d+?)(\s|$)/, " bis-$1 ", :global:i
    do regex using var sentence: /(^|\s)bis (\d+?\.\d+?\.\d+?)(\s|$)/, " bis-$1 ", :global:i
    do regex using var sentence: /(^|\s)zum (\d+?\.\d+?\.\d+?)(\s|$)/, " bis-$1 ", :global:i
    
    do return with var sentence
done

define action add_undefined_time with array clause do
    set new var adverbs to from array clause item [3]
    if var adverbs do
        set var adverbs to var adverbs concat " "
    done
    set var adverbs to var adverbs concat "zu dieser Zeit"
    set from array clause item [3] to var adverbs
    
    do return with array clause
done

define action phrases_error_toomuch without arguments do
    set new array phrases to an empty array
    push into array phrases, [ 0, "Tut mir leid, diese Eingabe kann ich aufgrund zu vieler Daten nicht beantworten." ]
    do return with array phrases
done

#define action guess_part_of_speech with var word do
#    set new var guessed to ''
#    if lc(var word) matches var word and var word matches /iv$/ do
#        set var guessed to 'adj'
#    done
#    #if var word matches lc(var word) and var word matches /an$/ do
#    #    set var guessed to 'adj'
#    #done
#    if lc(var word) matches var word and var word matches /em$/ do
#        set var guessed to 'adj'
#    done
#    if var word matches /ste$/ do
#        set var guessed to 'adj'
#    done
#    if var word matches /ier[te][n]?$/ do
#        set var guessed to 'v'
#    done
#    if lc(var word) matches var word and var word matches /en$/ do
#        set var guessed to 'v'
#    done
#    if var word matches /...ist((en)|(in))$/ do
#        set var guessed to 'n'
#    done
#    if var word matches /est$/ do
#        set var guessed to 'n'
#    done
#    if var word matches /ierte..?.?$/ do
#        set var guessed to 'adj'
#    done
#    if var word matches /<[A-Z]>/ do
#        set var guessed to 'n'
#    done
#    
#    do return using var guessed
#done

define action get_article with var genus, var part_of_sentence, var def do
    if var def matches /indef/ do
        # object
        if var part_of_sentence matches "object" do
            if var genus matches /m/ do
                do return with "einen"
            done
            else if var genus matches /f/ do
                do return with "eine"
            done
            else do
                do return with "ein"
            done
        done
        # subject
        else do
            if var genus matches /m/ do
                do return with "ein"
            done
            else if var genus matches /f/ do
                do return with "eine"
            done
            else do
                do return with "ein"
            done
        done
    done
    else do
        # object
        if var part_of_sentence matches "object" do
            if var genus matches /m/ do
                do return with "den"
            done
            else if var genus matches /f/ do
                do return with "die"
            done
            else do
                do return with "das"
            done
        done
        # subject
        else do
            if var genus matches /m/ do
                do return with "der"
            done
            else if var genus matches /f/ do
                do return with "die"
            done
            else do
                do return with "das"
            done
        done
    done
    
    do return with ""
done

define action get_person with var _noun do
    set new var noun to lc with var _noun
    
    if var noun matches "ich" do
        do return with "1s"
    done
    if var noun matches "du" do
        do return with "2s"
    done
    if var noun matches /^(er|sie|es)$/ do
        do return with "3s"
    done
    if var noun matches "wir" do
        do return with "1p"
    done
    if var noun matches "ihr" do
        do return with "2p"
    done
    if var noun matches "sie" do
        do return with "3p"
    done
    
    do return with "3s"
done

define action get_plural with var str do
    if var str matches /e$/ do
        do regex using var str: /e$/, "", :i
    done
    do return with var str
done

define action get_verb with var verb, var person do

    if var verb matches "be" do
        if var person matches "1s" do
            do return with "bin"
        done
        if var person matches "2s" do
            do return with "bist"
        done
        if var person matches "3s" do
            do return with "ist"
        done
        if var person matches "1p" do
            do return with "sind"
        done
        if var person matches "2p" do
            do return with "seid"
        done
        if var person matches "3p" do
            do return with "sind"
        done
    done
    
    if var verb matches "have" do
        if var person matches "1s" do
            do return with "habe"
        done
        if var person matches "2s" do
            do return with "hast"
        done
        if var person matches "3s" do
            do return with "hat"
        done
        if var person matches "1p" do
            do return with "haben"
        done
        if var person matches "2p" do
            do return with "habt"
        done
        if var person matches "3p" do
            do return with "haben"
        done
    done
    
    if var verb matches "want" do
        if var person matches "1s" do
            do return with "will"
        done
        if var person matches "2s" do
            do return with "willst"
        done
        if var person matches "3s" do
            do return with "will"
        done
        if var person matches "1p" do
            do return with "wollen"
        done
        if var person matches "2p" do
            do return with "wollt"
        done
        if var person matches "3p" do
            do return with "wollen"
        done
    done
    
    if var verb matches "must" do
        if var person matches "1s" do
            do return with "muss"
        done
        if var person matches "2s" do
            do return with "musst"
        done
        if var person matches "3s" do
            do return with "muss"
        done
        if var person matches "1p" do
            do return with "muessen"
        done
        if var person matches "2p" do
            do return with "muesst"
        done
        if var person matches "3p" do
            do return with "muessen"
        done
    done
    
    if var verb matches "can" do
        if var person matches "1s" do
            do return with "kann"
        done
        if var person matches "2s" do
            do return with "kannst"
        done
        if var person matches "3s" do
            do return with "kann"
        done
        if var person matches "1p" do
            do return with "koennen"
        done
        if var person matches "2p" do
            do return with "koennt"
        done
        if var person matches "3p" do
            do return with "koennen"
        done
    done
    
    if var verb matches "may" do
        if var person matches "1s" do
            do return with "darf"
        done
        if var person matches "2s" do
            do return with "darfst"
        done
        if var person matches "3s" do
            do return with "darf"
        done
        if var person matches "1p" do
            do return with "duerfen"
        done
        if var person matches "2p" do
            do return with "duerft"
        done
        if var person matches "3p" do
            do return with "duerfen"
        done
    done
    
    if var verb matches "should" do
        if var person matches "1s" do
            do return with "sollte"
        done
        if var person matches "2s" do
            do return with "solltest"
        done
        if var person matches "3s" do
            do return with "sollte"
        done
        if var person matches "1p" do
            do return with "sollten"
        done
        if var person matches "2p" do
            do return with "solltet"
        done
        if var person matches "3p" do
            do return with "sollten"
        done
    done

    if var verb matches "is-same-as" do
        if var person matches "1s" do
            do return with "entspricht"
        done
        if var person matches "2s" do
            do return with "entsprichst"
        done
        if var person matches "3s" do
            do return with "entspricht"
        done
        if var person matches "1p" do
            do return with "entsprechen"
        done
        if var person matches "2p" do
            do return with "entsprecht"
        done
        if var person matches "3p" do
            do return with "entsprechen"
        done
    done

    if var verb matches "is-part-0" do
        if var person matches "1s" do
            do return with "gehoere zu"
        done
        if var person matches "2s" do
            do return with "gehoerst zu"
        done
        if var person matches "3s" do
            do return with "gehoert zu"
        done
        if var person matches "1p" do
            do return with "gehoeren zu"
        done
        if var person matches "2p" do
            do return with "gehoert zu"
        done
        if var person matches "3p" do
            do return with "gehoeren zu"
        done
    done

    if var verb matches "is-part-1" do
        if var person matches "1s" do
            do return with "bin ein Teil von"
        done
        if var person matches "2s" do
            do return with "bist ein Teil von"
        done
        if var person matches "3s" do
            do return with "ist ein Teil von"
        done
        if var person matches "1p" do
            do return with "sind ein Teil von"
        done
        if var person matches "2p" do
            do return with "seid ein Teil von"
        done
        if var person matches "3p" do
            do return with "sind ein Teil von"
        done
    done

    if var verb matches /is-own-/ do
        if var person matches "1s" do
            do return with "gehoere"
        done
        if var person matches "2s" do
            do return with "gehoerst"
        done
        if var person matches "3s" do
            do return with "gehoert"
        done
        if var person matches "1p" do
            do return with "gehoeren"
        done
        if var person matches "2p" do
            do return with "gehoert"
        done
        if var person matches "3p" do
            do return with "gehoeren"
        done
    done

    do return with ""
done

define action replace_general_reflexive_pronoun with var text, var person do
    set new var general_pronoun to "sich"
    set new var better_pronoun to "sich"
    
    if var person matches "1s" do
        set var better_pronoun to "mich"
    done
    if var person matches "2s" do
        set var better_pronoun to "dich"
    done
    if var person matches "3s" do
        set var better_pronoun to "sich"
    done
    if var person matches "1p" do
        set var better_pronoun to "uns"
    done
    if var person matches "2p" do
        set var better_pronoun to "euch"
    done
    if var person matches "3p" do
        set var better_pronoun to "sich"
    done

    do regex using var text: /\svar general_pronoun$/, " var better_pronoun", :global:i
    do regex using var text: /^var general_pronoun\s/, "var better_pronoun ", :global:i
    do regex using var text: /^var general_pronoun$/, "var better_pronoun", :global:i

    do return with var text
done

define action compute_output with var output do
    if not var output do
        do return with var output
    done

    do regex using var output: /in dem/, "im", :global:i
    do regex using var output: /an dem/, "am", :global:i
    
    do regex using var output: /^(.*?) _(wie|wer|was|wo|wann|warum|wieso|weshalb)_(.*?)$/, "$1 $0 $2", :global:i

    do regex using var output: / [&] /, " und ", :global:i

    do regex using var output: /f=>/, "", :global:i
    do regex using var output: /!=>/, "", :global:i
    if var output matches /q=>/ do
        do regex using var output: /q=>/, "", :global:i
        set var output to var output concat "?"
    done
    do regex using var output: /=>/, "", :global:i
    
    if var output matches /\$\$username\$\$/ do
        print new line
        print "Searching for the user's name"
        print new line
        print new line
        set new var username to ''

        set new var output_file_name to '_output__get_csv'
        set new var csv_output to 'bi|is|bin|bist|ist|sind|seid|heisst|heisse|heissen|sei|war|wurde|wurden|werden|werde|wirst|wurdest|wurde|wuerdet|werdet^du^0^0^0^default^0^0^0^0^0^0'

        do unlink with '_input__get_csv'

        set new var output_handle to handle for file name var output_file_name, write
        print into var output_handle data var csv_output
        do close with var output_handle

        while not exists: '_input__get_csv', end test do
            do wait 0.5 seconds
        done
        
        set new array usernames to an empty array
        set new var input_file_name to '_input__get_csv'
        set new var input_handle to handle for file name var input_file_name, read

        for each new var line from var input_handle is rw do
            set new array result to an empty array
            set new array rawresult to split using /\^/, var line
            if var line do
                push into array usernames, from array rawresult item [ 3 ]
            done
        done

        set new var random_number to rand using items of array usernames
        set var username to from array usernames item [ var random_number ]

        print var username
        print new line

        if var username do
            do regex using var output: /\$\$username\$\$/, "var username", :global:i
        done
    done

    if var output matches /\$\$unknownproperty\$\$/ do
        print new line
        print "Searching for the user's name"
        print new line
        print new line
        set new var username to ''

        # First, look for general properties
        set new var output_file_name to '_output__get_csv'
        set new var csv_output to 'haenen|haen|hast|hat|han|hae|ha^0^0^0^0^default^0^0^0^0^0^0'

        do unlink with '_input__get_csv'

        set new var output_handle to handle for file name var output_file_name, write
        print into var output_handle data var csv_output
        do close with var output_handle

        while not exists: '_input__get_csv', end test do
            do wait 0.5 seconds
        done
        
        set new array usernames to an empty array
        set new var input_file_name to '_input__get_csv'
        set new var input_handle to handle for file name var input_file_name, read

        for each new var line from var input_handle is rw do
            set new array result to an empty array
            set new array rawresult to split using /\^/, var line
            if var line and from array rawresult item [ 3 ] do
                push into array usernames, from array rawresult item [ 3 ]
            done
        done
        
        # Then, look what is already given
        set new var output_file_name to '_output__get_csv'
        set new var csv_output to 'haenen|haen|hast|hat|han|hae|ha^du^0^0^0^default^0^0^0^0^0^0'

        do unlink with '_input__get_csv'

        set new var output_handle to handle for file name var output_file_name, write
        print into var output_handle data var csv_output
        do close with var output_handle

        while not exists: '_input__get_csv', end test do
            do wait 0.5 seconds
        done
        
        set new var input_file_name to '_input__get_csv'
        set new var input_handle to handle for file name var input_file_name, read

        for each new var line from var input_handle is rw do
            set new array result to an empty array
            set new array rawresult to split using /\^/, var line
            if var line do
                set new var i to 0
                for each new var property in array usernames do
                    if var property matches from array rawresult item [ 3 ] do
                        do delete with from array usernames item [ var i ]
                        go to last
                    done
                    set var i to var i + 1
                done
            done
        done

        # Replace the variable
        set new var random_number to rand using items of array usernames
        set var username to from array usernames item [ var random_number ]

        print var username
        print new line

        if var username do
            do regex using var output: /\$\$unknownproperty\$\$/, "var username", :global:i
        done
        else do
            do regex using var output: /\$\$unknownproperty\$\$/, "etwas", :global:i
        done
    done

    set new var random_number to rand using items of array builtin_male_names
    set new var name to from array builtin_male_names item [ var random_number ]

    do regex using var output: /\$\$randomname\$\$/, "var name", :global:i
    if not var output matches /......./ do
        do regex using var output: /<[*]>/, "var name", :global:i
    done
    do regex using var output: /<[*]>/, "", :global:i

    do regex using var output: / von den /, " der ", :global:i
    do regex using var output: / von dem /, " des ", :global:i
    
    do regex using var output: /\/must/, "", :global:i
    do regex using var output: /\/may/, "", :global:i
    do regex using var output: /\/can/, "", :global:i
    do regex using var output: /\/want/, "", :global:i
    do regex using var output: /\/should/, "", :global:i
    
    do regex using var output: / nicht noch /, " noch nicht ", :global:i
    do regex using var output: /(etwas|nichts) (schon|noch)/, "$1 $0", :global:i

    do regex using var output: /<[{]><[{]><[{]>.*?<[}]><[}]><[}]>/, "", :global:i

    do regex using var output: / in jahre_/, " im Jahre ", :global:i
    do regex using var output: / in_jahre_/, " im Jahre ", :global:i

    set new array _clauses to split using /<[,]>/, var output
    for each new var _clause in array _clauses is rw do
        # var _clause matches /\sein/ and 
        if lc(var _clause) matches /(^|<[,.]>|\s)nicht(\s|<[,.]>|$)/ do
            do regex using var _clause: /(^|<[,.]>|\s)nicht(\s|<[,.]>|$)/, "$1", :global:i
            do regex using var _clause: /\sein(.?.?.?)\s/, " kein$0 ", :global:i
            do regex using var _clause: /\sein(.?.?.?)$/, " kein$0", :global:i
            do regex using var _clause: /(^|\s)etwas(\s|$)/, "$0nichts$1", :global:i
        done
    done
    set var output to join using ", ", items of array _clauses

    do regex using var output: /_/, " ", :global:i
    # Time From <-> time from
    do regex using var output: /time(<[\s]>|<[_]>|<[-]>)from(<[\s]>|<[_]>|<[-]>)/, "time from ", :global:i
    do regex using var output: /time from\s+/, "time from ", :global:i
    # Time To   <-> time to
    do regex using var output: /time(<[\s]>|<[_]>|<[-]>)to(<[\s]>|<[_]>|<[-]>)/, "time to ", :global:i
    do regex using var output: /time to\s+/, "time to ", :global:i

    set new var time_now to time without arguments
    set new var time_begin to time without arguments
    set new var time_end to 0
    if var output matches /time_from-(<[0-9]>+?)(\s|$)/ do
        set var time_begin to $0
    done
    if var output matches /time from (<[0-9]>+?)(\s|$)/ do
        set var time_begin to $0
    done
    if var output matches /time_to-(<[0-9]>+?)(\s|$)/ do
        set var time_end to $0
    done
    if var output matches /time to (<[0-9]>+?)(\s|$)/ do
        set var time_end to $0
    done
    
    set new array date_time_array to items-returning localtime with var time_begin
    set new var sec to from array date_time_array item [ 0 ]
    set new var min to from array date_time_array item [ 1 ]
    set new var hour to from array date_time_array item [ 2 ]
    set new var mday to from array date_time_array item [ 3 ]
    set new var mon to from array date_time_array item [ 4 ]
    set new var year to from array date_time_array item [ 5 ]
    set new var wday to from array date_time_array item [ 6 ]
    set new var yday to from array date_time_array item [ 7 ]
    set new var isdst to from array date_time_array item [ 8 ]
    
    if not var min matches /../ do
        set var min to "0" concat var min
    done
    if not var sec matches /../ do
        set var sec to "0" concat var sec
    done
    if not var hour matches /../ do
        set var hour to "0" concat var hour
    done
    
    set new var weekday to 'nichts'
    if var wday is 0 do
        set var weekday to "Sonntag"
    done
    if var wday is 1 do
        set var weekday to "Montag"
    done
    if var wday is 2 do
        set var weekday to "Dienstag"
    done
    if var wday is 3 do
        set var weekday to "Mittwoch"
    done
    if var wday is 4 do
        set var weekday to "Donnerstag"
    done
    if var wday is 5 do
        set var weekday to "Freitag"
    done
    if var wday is 6 do
        set var weekday to "Samstag"
    done
    
    set var year to var year + 1900
    set var mon to var mon + 1
    if var mon matches /^.$/ do
        set var mon to "0" concat var mon
    done
    if var mday matches /^.$/ do
        set var mday to "0" concat var mday
    done
    
    set new var monthname to 'Monat'
    if var mon is 1 do
        set var monthname to "Januar"
    done
    if var mon is 2 do
        set var monthname to "Februar"
    done
    if var mon is 3 do
        set var monthname to "Maerz"
    done
    if var mon is 4 do
        set var monthname to "April"
    done
    if var mon is 5 do
        set var monthname to "Mai"
    done
    if var mon is 6 do
        set var monthname to "Juni"
    done
    if var mon is 7 do
        set var monthname to "Juli"
    done
    if var mon is 8 do
        set var monthname to "August"
    done
    if var mon is 9 do
        set var monthname to "September"
    done
    if var mon is 10 do
        set var monthname to "Oktober"
    done
    if var mon is 11 do
        set var monthname to "November"
    done
    if var mon is 12 do
        set var monthname to "Dezember"
    done
    
    
    do regex using var output: /\$\$time\$\$/, "var hour:var min:var sec", :global:i
    do regex using var output: /\$\$wday\$\$/, "var weekday", :global:i
    do regex using var output: /\$\$mday\$\$/, "var mday", :global:i
    do regex using var output: /\$\$month\$\$/, "var monthname", :global:i
    do regex using var output: /\$\$year\$\$/, "var year", :global:i
    do regex using var output: / das datum (\$\$date\$\$)/, " $0", :global:i
    do regex using var output: /\$\$date\$\$/, "var weekday, den var mday.var mon.var year", :global:i

    do regex using var output: /array\(.*?\)/, "", :global:i
    
    do regex using var output: /<[~]>time.*/, "", :global:i
    
    
    if var time_end + 24*60*60 is var time_begin do
        set new var temp to var time_end
        set var time_end to var time_begin
        set var time_begin to var temp
    done
    
    if var time_begin + 24*60*60 is var time_end do
        if var output matches /time from (<[0-9]>+?)(\s|$)/ do
            set new var replacement to ''
            if not ( var time_now < var time_end and var time_now > var time_begin ) do
                set var replacement to var replacement concat ' am ' concat var mday concat '.' concat var mon concat '.' concat var year
            done
            if var hour or var min or var sec do
                set var replacement to var replacement concat ' um ' concat var hour concat ':' concat var min
            done
            do regex using var output: /time from (<[0-9]>+?)(\s|$)/, "var replacement", :global:i
            do regex using var output: /time to (<[0-9]>+?)(\s|$)/, "", :global:i
        done
    done
    else do
        if var output matches /time from (<[0-9]>+?)(\s|$)/ do
            print "From: " concat var mday concat '.' concat var mon concat '.' concat var year concat ' ' concat var hour concat ':' concat var min concat new line
            set new var replacement to ''
            if not ( var time_now < var time_end and var time_now > var time_begin ) do
                set var replacement to var replacement concat ' vom ' concat var mday concat '.' concat var mon concat '.' concat var year
            done
            else if var hour or var min or var sec do
                set var replacement to var replacement concat ' von ' concat var hour concat ':' concat var min
            done
            do regex using var output: /time from (<[0-9]>+?)(\s|$)/, "var replacement ", :global:i
        done
        
        set new array date_time_array to items-returning localtime with var time_end
        set new var sec to from array date_time_array item [ 0 ]
        set new var min to from array date_time_array item [ 1 ]
        set new var hour to from array date_time_array item [ 2 ]
        set new var mday to from array date_time_array item [ 3 ]
        set new var mon to from array date_time_array item [ 4 ]
        set new var year to from array date_time_array item [ 5 ]
        set new var wday to from array date_time_array item [ 6 ]
        set new var yday to from array date_time_array item [ 7 ]
        set new var isdst to from array date_time_array item [ 8 ]
        
        if not var min matches /../ do
            set var min to "0" concat var min
        done
        if not var sec matches /../ do
            set var sec to "0" concat var sec
        done
        if not var hour matches /../ do
            set var hour to "0" concat var hour
        done
        
        set var year to var year + 1900
        set var mon to var mon + 1
        if var mon matches /^.$/ do
            set var mon to "0" concat var mon
        done
        if var mday matches /^.$/ do
            set var mday to "0" concat var mday
        done
        
        if var output matches /time to (<[0-9]>+?)(\s|$)/ do
            print "To:   " concat var mday concat '.' concat var mon concat '.' concat var year concat ' ' concat var hour concat ':' concat var min concat new line
            set new var replacement to ''
            if var hour matches "00" and var min matches "00" and var sec matches "00" do
                set var replacement to var replacement concat ' bis zum ' concat var mday concat '.' concat var mon concat '.' concat var year
            done
            else if var hour or var min or var sec do
                set var replacement to var replacement concat ' bis ' concat var hour concat ':' concat var min
            done
            do regex using var output: /time to (<[0-9]>+?)(\s|$)/, "var replacement ", :global:i
        done
    done
    
    do regex using var output: /nothing/, "nichts", :global:i
    do regex using var output: /NULL/, "", :global:i
    do regex using var output: /<[;]>/, " ", :global:i
    #do regex using var output: / = /, " bedeutet ", :global:i
    do regex using var output: /_/, " ", :global:i
    do regex using var output: /\s+/, " ", :global:i
    do regex using var output: /\s+<[,]>/, ",", :global:i
    do regex using var output: /\s\s/, " ", :global:i
    do regex using var output: /^\s/, "", :global:i
    do regex using var output: /\s$/, "", :global:i
    set var output to ucfirst with var output

    if not var output matches /<[?!]>/ do
        set var output to var output concat "."
    done
    
    do return with var output
done

define action check_for_as_well_as with var text, var adverbs, var lang, var path do
    if var text not matches /\$\$(notaswellas)\$\$/ and var text not matches /\$\$(aswellas)\$\$/ do
        do return with var text
    done

    set new flag negative to 0
    if var adverbs matches /nicht/ do
        set flag negative to 1
        do regex using var text: /(^|\s)nicht(\s|$)/, " ", :i
        do regex using var text: /\s+/, " ", :i
    done

    if var text matches /\$\$aswellas\$\$/ and flag negative is false do
        set var text to "sowohl " concat var text
        do regex using var text: /\$\$aswellas\$\$/, " als auch ", :i
        do regex using var text: /\s+/, " ", :i
    done
    if var text matches /\$\$(notaswellas)\$\$/ or ( var text matches /\$\$aswellas\$\$/ and flag negative is true ) do
        set var text to "weder " concat var text
        do regex using var text: /\$\$(notaswellas)\$\$/, " noch ", :i
        do regex using var text: /\$\$(aswellas)\$\$/, " noch ", :i
        do regex using var text: /\s+/, " ", :i
    done
    do return with var text
done

define action toggle_verbs with array verbs, array entities do
    set new flag continue to 0
    for each new array entity_array in array entities is rw do
        set new var entity to from array entity_array 1st item
        
        if lc(var entity) matches /(^|\s)(ich|du|mich|dich)(\s|$)/ do
            set flag continue to 1
        done
    done
    
    if not flag continue do
        print "Does not contain a personal pronoun."
        print new line
        do return with array verbs
    done
    print "Contains a personal pronoun."
    print new line
    
    for each new array verb_array in array verbs is rw do
        set new var verb to lc with from array verb_array 1st item
        print "verb: " concat var verb
        print new line
        if var verb matches "ist" do
            go to next
        done
        if var verb matches /^gew/ do
            go to next
        done
        if var verb matches /bin$/ do
            do regex using var verb: /bin$/, "bist", :global:i
        done
        else if var verb matches /bist$/ do
            do regex using var verb: /bist$/, "bin", :global:i
        done
        else if var verb matches /hast$/ do
            do regex using var verb: /hast$/, "habe", :global:i
        done
        else if var verb matches /hab.?$/ do
            do regex using var verb: /hab.?$/, "hast", :global:i
        done
        else if var verb matches /heisst$/ do
            do regex using var verb: /heisst$/, "heisse", :global:i
        done
        else if var verb matches /heisse$/ do
            do regex using var verb: /heisse$/, "heisst", :global:i
        done
        else if var verb matches /weisst$/ do
            do regex using var verb: /weisst$/, "weiss", :global:i
        done
        else if var verb matches /weiss$/ do
            do regex using var verb: /weiss$/, "weisst", :global:i
        done
        else if var verb matches /musst$/ do
            do regex using var verb: /musst$/, "muss", :global:i
        done
        else if var verb matches /muss$/ do
            do regex using var verb: /muss$/, "musst", :global:i
        done
        else if var verb matches /laesst/ do
            do regex using var verb: /laesst$/, "lasse", :global:i
        done
        else if var verb matches /lasse$/ do
            do regex using var verb: /lasse$/, "laesst", :global:i
        done
        else if var verb matches /traegst$/ do
            do regex using var verb: /traegst$/, "trage", :global:i
        done
        else if var verb matches /trage$/ do
            do regex using var verb: /trage$/, "traegst", :global:i
        done
        else if var verb matches /stirbst$/ do
            do regex using var verb: /stirbst$/, "sterbe", :global:i
        done
        else if var verb matches /sterbe$/ do
            do regex using var verb: /sterbe$/, "stirbst", :global:i
        done
        else if var verb matches /nimmst$/ do
            do regex using var verb: /nimmst$/, "nehme", :global:i
        done
        else if var verb matches /nehme$/ do
            do regex using var verb: /nehme$/, "nimmst", :global:i
        done
        else if var verb matches /haeltst$/ do
            do regex using var verb: /haeltst$/, "halte", :global:i
        done
        else if var verb matches /halte$/ do
            do regex using var verb: /halte$/, "haeltst", :global:i
        done
        else if var verb matches /willst$/ do
            do regex using var verb: /willst$/, "will", :global:i
        done
        else if var verb matches /will$/ do
            do regex using var verb: /will$/, "willst", :global:i
        done
        else if var verb matches /kannst$/ do
            do regex using var verb: /kannst$/, "kann", :global:i
        done
        else if var verb matches /kann$/ do
            do regex using var verb: /kann$/, "kannst", :global:i
        done
        else if var verb matches /kennst$/ do
            do regex using var verb: /kennst$/, "kenne", :global:i
        done
        else if var verb matches /kenne$/ do
            do regex using var verb: /kenne$/, "kennst", :global:i
        done
        else if var verb matches /mag$/ do
            do regex using var verb: /mag$/, "magst", :global:i
        done
        else if var verb matches /magst$/ do
            do regex using var verb: /magst$/, "mag", :global:i
        done
        else if var verb matches /sprichst$/ do
            do regex using var verb: /sprichst$/, "spreche", :global:i
        done
        else if var verb matches /spreche$/ do
            do regex using var verb: /spreche$/, "sprichst", :global:i
        done
        else if var verb matches /wirst$/ do
            do regex using var verb: /wirst$/, "werde", :global:i
        done
        else if var verb matches /werde$/ do
            do regex using var verb: /werde$/, "wirst", :global:i
        done
        else if var verb matches /schlaefst$/ do
            do regex using var verb: /schlaefst$/, "schlafe", :global:i
        done
        else if var verb matches /schlafe$/ do
            do regex using var verb: /schlafe$/, "schlaefst", :global:i
        done
        else if var verb matches /laeufst$/ do
            do regex using var verb: /laeufst$/, "laufe", :global:i
        done
        else if var verb matches /laufe$/ do
            do regex using var verb: /laufe$/, "laeufst", :global:i
        done
        else if var verb matches /(<[gdm]>)elst$/ do
            do regex using var verb: /(<[gdm]>)elst$/, "$0le", :global:i
        done
        else if var verb matches /(<[gdm]>)le$/ do
            do regex using var verb: /(<[gdm]>)le$/, "$0elst", :global:i
        done
        else if var verb matches /isst$/ do
            do regex using var verb: /isst$/, "esse", :global:i
        done
        else if var verb matches /esse$/ do
            do regex using var verb: /esse$/, "isst", :global:i
        done
        else if var verb matches /test$/ do
            do regex using var verb: /test$/, "te", :global:i
        done
        else if var verb matches /te$/ do
            do regex using var verb: /te$/, "test", :global:i
        done
        else if var verb matches /sst$/ do
            do regex using var verb: /sst$/, "sse", :global:i
        done
        else if var verb matches /est$/ do
            do regex using var verb: /est$/, "e", :global:i
        done
        else if var verb matches /st$/ do
            do regex using var verb: /st$/, "e", :global:i
        done
        else if var verb matches /<[td]>e$/ do
            do regex using var verb: /<[td]>e$/, "<[td]>est", :global:i
        done
        else if var verb matches /e$/ do
            do regex using var verb: /e$/, "st", :global:i
        done
        do regex using var verb: /sss/, "ss", :global:i
        set from array verb_array 1st item to var verb
    done
    do return with array verbs
done

define action toggle_entities with array entities do
    for each new array entity_array in array entities is rw do
        set new var entity to from array entity_array 1st item
        if lc(var entity) matches /(^|\s)mir($|\s)/ do
            do regex using var entity: /(^|\s)mir($|\s)/, "${1}dir$2", :global:i
        done
        else if lc(var entity) matches /(^|\s)dir($|\s)/ do
            do regex using var entity: /(^|\s)dir($|\s)/, "${1}mir$2", :global:i
        done
        else if lc(var entity) matches /(^|\s)mich($|\s)/ do
            do regex using var entity: /(^|\s)mich($|\s)/, "${1}dich$2", :global:i
        done
        else if lc(var entity) matches /(^|\s)dich($|\s)/ do
            do regex using var entity: /(^|\s)dich($|\s)/, "${1}mich$2", :global:i
        done
        else if lc(var entity) matches /(^|\s)ich($|\s)/ do
            do regex using var entity: /(^|\s)ich($|\s)/, "${1}du$2", :global:i
        done
        else if lc(var entity) matches /(^|\s)du($|\s)/ do
            do regex using var entity: /(^|\s)du($|\s)/, "${1}ich$2", :global:i
        done
        else if   (var entity) matches /(^|\s|<[_]>)mein/ do
            do regex using var entity: /(^|\s|<[_]>)mein/, "${1}dein", :global:i
        done
        else if   (var entity) matches /(^|\s|<[_]>)dein/ do
            do regex using var entity: /(^|\s|<[_]>)dein/, "${1}mein", :global:i
        done
        else if lc(var entity) matches /(^|<[_]>)mein/ and not lc(var entity) matches /meinung/ do
            do regex using var entity: /(^|<[_]>)mein/, "${1}dein", :global:i
        done
        else if lc(var entity) matches /(^|<[_]>)dein/ do
            do regex using var entity: /(^|<[_]>)dein/, "${1}mein", :global:i
        done
        
        set from array entity_array 1st item to var entity
    done
    do return with array entities
done

define action adjust_truth with array result, var truth, var number_of_clause, var number_of_subclause do
    if var truth < 0.5 and ( from array result item [ var number_of_clause ] item [ 1 + (6*var number_of_subclause) ] or from array result item [ var number_of_clause ] item [ 2 + (6*var number_of_subclause) ] ) do
        if from array result item [ var number_of_clause ] item [ 2 + (6*var number_of_subclause) ] matches /\$\$aswellas\$\$/ do
            do regex using from array result item [ var number_of_clause ] item [ 2 + (6*var number_of_subclause) ]: /\$\$aswellas\$\$/, "\$\$notaswellas\$\$", :global:i
        done
        else if from array result item [ var number_of_clause ] item [ 1 + (6*var number_of_subclause) ] matches /\$\$aswellas\$\$/ do
            do regex using from array result item [ var number_of_clause ] item [ 1 + (6*var number_of_subclause) ]: /\$\$aswellas\$\$/, "\$\$notaswellas\$\$", :global:i
        done
        else if from array result item [ var number_of_clause ] item [ 2 + (6*var number_of_subclause) ] matches /^ein/ do
            do regex using from array result item [ var number_of_clause ] item [ 2 + (6*var number_of_subclause) ]: /^ein(.?.?.?)$/, "kein$0", :global:i
            do regex using from array result item [ var number_of_clause ] item [ 2 + (6*var number_of_subclause) ]: /^ein(.?.?.?)\s/, "kein$0 ", :global:i
        done
        else if from array result item [ var number_of_clause ] item [ 1 + (6*var number_of_subclause) ] matches /^ein/ do
            do regex using from array result item [ var number_of_clause ] item [ 1 + (6*var number_of_subclause) ]: /^ein(.?.?.?)$/, "kein$0", :global:i
            do regex using from array result item [ var number_of_clause ] item [ 1 + (6*var number_of_subclause) ]: /^ein(.?.?.?)\s/, "kein$0 ", :global:i
        done
        else do
            set from array result item [ var number_of_clause ] item [ 3  + (6*var number_of_subclause)] to "nicht " concat from array result item [ var number_of_clause ] item [ 3 + (6*var number_of_subclause) ]
        done
    done
done

define action stem_nouns with array phrases do
    for each new var phrase in array phrases is rw do
        print "phrase: " concat var phrase
        print new line
        set new array words to split using /\s/, var phrase
        for each new var noun in array words is rw do
            # TEXT
            # Delete articles...
            # CODE

            if var noun matches /^\(a\)$/ do
                do regex using var noun: /^\(a\)$/, "*", :global:i
            done
            if not var noun matches /....../ do
                if var noun matches /^ein.?.?$/ do
                    do regex using var noun: /^ein.?.?$/, "*", :global:i
                done
                if var noun matches /^ein.?.?$/ do
                    do regex using var noun: /ein.?.?$/, "ei*", :global:i
                done
                if var noun matches /^ein$/ do
                    do regex using var noun: /ein$/, "*", :global:i
                done
            done
            if var noun matches /^(der|die|das|den|dem|des)$/ and not items of array words is 1 do
                #do regex using var noun: /^(der|die|das|den|dem|des)$/, "*", :global:i
                if items of array words > 2 do
                    do regex using var noun: /^(der|die|das|den|dem|des)$/, "*", :global:i
                done
                else do
                    do regex using var noun: /^(der|die|das|den|dem|des)$/, "", :global:i
                done
                go to next
            done
            
            if length(var noun) <= 3 do
                go to next
            done
            
            # TEXT
            # That's the stemming algorithm
            # CODE
            if var noun matches /((ein)|(ie.)|(tes)|(be)|([mnpl][ksl]er))$/ do
                go to next
            done
            
            if var noun matches /ei.$/ do
                go to next
            done
            
            if var noun matches /^oder$/ do
                set var noun to '|'
            done
            
            if var noun matches /sen$/ do
                go to next
            done
            if var noun matches /ul.$/ do
                go to next
            done
            if var noun matches /(ff|lk|ns)e$/ do
                go to next
            done
            if var noun matches /ger$/ do
                go to next
            done
            if var noun matches /ppe$/ do
                go to next
            done
            if var noun matches /ern$/ and var noun not matches /<[yt]>ern$/ do
                do regex using var noun: /ern$/, "er*", :global:i
            done
            if length(var noun) > 8 and var noun matches /[c][hkg]e$/ do
                do regex using var noun: /e$/, "e*", :global:i
            done
            if var noun matches /ger$/ do
                do regex using var noun: /ger$/, "ge*", :global:i
            done
            #if var noun matches /e<[mnrs]>$/ do
            #    do regex using var noun: /e<[mnrs]>$/, "e*", :global:i
            #done
            #if var noun matches /e$/ do
            #    do regex using var noun: /e$/, "*", :global:i
            #done
            #if var noun matches /<[bdfghklmnrt]>s$/ do
            #    do regex using var noun: /s$/, "*", :global:i
            #done
            if length(var noun) > 8 do
                if var noun matches /est$/ do
                    do regex using var noun: /est$/, "*", :global:i
                done
            done
            #if var noun matches /e<[nr]>$/ do
            #    do regex using var noun: /e<[nr]>$/, "e*", :global:i
            #done
            #if var noun matches /<[bdfghklmnt]>st$/ do
            #    if length(var noun) > 5 do
            #        do regex using var noun: /st$/, "*", :global:i
            #    done
            #done
            #if var noun matches /.....(end|ung)$/ do
            #    do regex using var noun: /(end|ung)$/, "*", :global:i
            #    
            #    #if var noun matches /ig$/ and not var noun matches /eig$/ do
            #    #    do regex using var noun: /ig$/, "*", :global:i
            #    #done
            #done
            #if var noun matches /....(ig|ik|isch)$/ and not var noun matches /e(ig|ik|isch)$/ do
            #    do regex using var noun: /(ig|ik|isch)$/, "*", :global:i
            #done
            if var noun matches /(lich|heit)$/ do
                do regex using var noun: /(lich|heit)$/, "*", :global:i
            done
            if var noun matches /(lich|ig)?keit$/ do
                do regex using var noun: /(lich|ig)?keit$/, "*", :global:i
            done
        done
        set var phrase to join using " ", items of array words
        
        do regex using var phrase: /<[*]>\s/, "*", :global
        do regex using var phrase: /\s<[*]>/, "*", :global
        do regex using var phrase: /\$<[*]>/, "\$ *", :global
        do regex using var phrase: /^\s+/, "", :global
        do regex using var phrase: /\s+<[|]>/, "|", :global
        do regex using var phrase: /\s+$/, "", :global
    done
    
    do return with array phrases
done

define action check_for_math with var input do
    set new var math to var input
    
    do regex using var math: /dreizehn/, "13", :global:i
    do regex using var math: /vierzehn/, "14", :global:i
    do regex using var math: /fuenfzehn/, "15", :global:i
    do regex using var math: /sechzehn/, "16", :global:i
    do regex using var math: /siebzehn/, "17", :global:i
    do regex using var math: /achtzehn/, "18", :global:i
    do regex using var math: /neunzehn/, "19", :global:i
    do regex using var math: /zwanzig/, "20", :global:i
    do regex using var math: /hundert/, "100", :global:i
    do regex using var math: /tausend/, "1000", :global:i
    do regex using var math: /eins/, "1", :global:i
    do regex using var math: /zwei/, "2", :global:i
    do regex using var math: /drei/, "3", :global:i
    do regex using var math: /vier/, "4", :global:i
    do regex using var math: /fuenf/, "5", :global:i
    do regex using var math: /sechs/, "6", :global:i
    do regex using var math: /sieben/, "7", :global:i
    do regex using var math: /acht/, "8", :global:i
    do regex using var math: /neun/, "9", :global:i
    do regex using var math: /zehn/, "10", :global:i
    do regex using var math: /elf/, "11", :global:i
    do regex using var math: /zwoelf/, "12", :global:i
    
    do regex using var math: /<[=?!._]>/, "", :global:i
    do regex using var math: /hoch/, "**", :global:i
    do regex using var math: /\^/, "**", :global:i
    do regex using var math: /wie/, "", :global:i
    do regex using var math: /viel/, "", :global:i
    do regex using var math: /was/, "", :global:i
    do regex using var math: /jahre/, "", :global:i
    do regex using var math: /ISUNKNOWN/, "", :global:i
    do regex using var math: /ergebnis/, "", :global:i
    do regex using var math: /von/, "", :global:i
    do regex using var math: /ist/, "", :global:i
    do regex using var math: /sind/, "", :global:i
    do regex using var math: /what/, "", :global:i
    do regex using var math: /is/, "", :global:i
    do regex using var math: /does/, "", :global:i
    do regex using var math: /makes/, "", :global:i
    do regex using var math: /ergibt/, "", :global:i
    do regex using var math: /gibt/, "", :global:i
    do regex using var math: /aus/, " ", :global:i
    do regex using var math: /jahre/, " ", :global:i
    do regex using var math: /sich/, " ", :global:i
    do regex using var math: /der|die|das/, " ", :global:i
    do regex using var math: / plus /, "+", :global:i
    do regex using var math: / und /, "+", :global:i
    do regex using var math: / half of (\d+)/, "( $1 \/ 2 )", :global:i
    do regex using var math: / minus /, "-", :global:i
    do regex using var math: / weniger /, "-", :global:i
    set new var slash to "/"
    do regex using var math: / geteilt durch /, "var slash", :global:i
    do regex using var math: / dividiert durch /, "var slash", :global:i
    do regex using var math: / durch /, "var slash", :global:i
    do regex using var math: / mal /, "*", :global:i
    do regex using var math: /in/, "", :global:i
    do regex using var math: /x/, "*", :global:i
    do regex using var math: /\s+/, "", :global:i
    do regex using var math: /quadratwurzel/, "sqrt ", :global:i
    do regex using var math: /wurzel/, "sqrt ", :global:i
    do regex using var math: /<[,]>/, ".", :global:i
    set new var value to undef
    
    print "Checking for math expression: "
    print new line
    print var math
    print new line

    if var math matches /^(<[0-9\d+\-*.\/\s)(]>|(sqrt)|(sin)|(cos)|(tan)|(cot))+$/ do
        if var math matches /(<[+\-*.\/]>|(sqrt)|(sin)|(cos)|(tan)|(cot))/ do
            print "Ok."
            print new line
            do regex using var math: /(sin|cos|tan|cot)(<[\d]>+)/, "$1($2)", :global:i
            do eval with 'var value = ' concat var math concat ';'
            if defined(var value) do
                do return with [ 0, "Das Ergebnis ist " concat var value concat "."  ]
            done
            else do
                do return with 0
            done
        done
    done
    do return with 0
done

define action check_for_thanks with var input do
    set new array thanks_from_user to an empty array
    push into array thanks_from_user, 'danke'

    for each new var thank in array thanks_from_user do
        if lc(var input) matches /((\s)|<[,.\-!?]>|^)var thank((\s)|<[,.\-!?]>|$)/ do
            do return with 1
        done
    done
    
    do return with 0
done

define action say_answer_thanks with var user do
    set new array answers to an empty array
    push into array answers, "Nichts zu danken."
    push into array answers, "Gern geschehen."
    set new var random_number to rand using items of array answers
    set new var answer to from array answers item [ var random_number ]
    
    do return with [ 0, var answer ]
done

define action check_for_greeting with var input do
    set new array greetings_from_user to an empty array
    push into array greetings_from_user, 'hallo'
    push into array greetings_from_user, 'hi'
    push into array greetings_from_user, 'guten tag'
    push into array greetings_from_user, 'guten morgen'
    push into array greetings_from_user, 'guten abend'
    push into array greetings_from_user, 'gute nacht'
    push into array greetings_from_user, 'mahlzeit'
    push into array greetings_from_user, 'schoenen nachmittag'

    for each new var greeting in array greetings_from_user do
        if lc(var input) matches /((\s)|<[,.\-!?]>|^)var greeting((\s)|<[,.\-!?]>|$)/ do
            do return with 1
        done
    done
    
    do return with 0
done

define action greet with var user do
    set new array time_now to items-returning localtime without arguments
    set new var hour to from array time_now item [ 2 ]

    if var user do
        if var hour >= 0 and var hour < 5 do
            do return with [ 0, var user concat "..? Immer noch wach...?" ]
        done
        if var hour >= 5 and var hour < 12 do
            do return with [ 0, "Guten Morgen, " concat var user concat "." ]
        done
        if var hour >= 12 and var hour < 17 do
            do return with [ 0, "Guten Tag, " concat var user concat "." ]
        done
        if var hour >= 17 and var hour < 24 do
            do return with [ 0, "Guten Abend, " concat var user concat "." ]
        done
    done
    else do
        if var hour >= 0 and var hour < 5 do
            do return with [ 0, "Wie..? Immer noch wach...?" ]
        done
        if var hour >= 5 and var hour < 12 do
            do return with [ 0, "Guten Morgen." ]
        done
        if var hour >= 12 and var hour < 17 do
            do return with [ 0, "Guten Tag." ]
        done
        if var hour >= 17 and var hour < 24 do
            do return with [ 0, "Guten Abend." ]
        done
    done
done

define action make_parsable with var input do
    do regex using var input: / weil /, ", weil ", :global:i
    do regex using var input: / dass /, ", dass ", :global:i
    do regex using var input: / wenn /, ", wenn ", :global:i
    do regex using var input: / falls /, ", falls ", :global:i
    do regex using var input: / dann /, ", dann ", :global:i
    do regex using var input: /<[,]>\s*?<[,]>/, ",", :global:i
    do regex using var input: /<[,]>\s*?<[,]>/, ",", :global:i
    do regex using var input: /<[,]>\s*?<[,]>/, ",", :global:i
    do regex using var input: /<[,]>\s*?<[,]>/, ",", :global:i
    
    do return with var input
done

define action multiple_choices_verb with var verb do
    set new array choices to an empty array
    set new array endings to an empty array
    
    push into array endings, "enen"
    push into array endings, "en"
    push into array endings, "st"
    push into array endings, "t"
    push into array endings, "n"
    push into array endings, "e"
    push into array endings, ""

    for each new var ending in array endings do
        set new var copied_verb to var verb
        do regex using var verb: /var ending$/, "", :i
        if not var copied_verb matches var verb do
            go to last
        done
    done
    
    if var verb matches "bi" or var verb matches "i" or var verb matches "is" or var verb matches "sind" or var verb matches /heis/ or var verb matches /wurd/ do
        push into array choices, var verb
        push into array choices, "="
        push into array choices, "bin"
        push into array choices, "bist"
        push into array choices, "ist"
        push into array choices, "sind"
        push into array choices, "seid"
        push into array choices, "sein"
        push into array choices, "heisst"
        push into array choices, "heisse"
        push into array choices, "heissen"
        push into array choices, "sei"
        push into array choices, "war"
        push into array choices, "wurde"
        push into array choices, "wurden"
        push into array choices, "werden"
        push into array choices, "werde"
        push into array choices, "wirst"
        push into array choices, "wurdest"
        push into array choices, "wurde"
        push into array choices, "wuerdet"
        push into array choices, "werdet"
    done
    else if var verb matches "ha" or var verb matches "hab" do
        push into array choices, var verb
        push into array choices, "hab"
        push into array choices, "habe"
        push into array choices, "hat"
        push into array choices, "hast"
        push into array choices, "habt"
        push into array choices, "haben"
        push into array choices, "hatte"
        push into array choices, "hattest"
        push into array choices, "hatten"
        push into array choices, "hattet"
    done
    else if var verb matches "gib" or var verb matches "geb" do
        push into array choices, var verb
        push into array choices, "gebe"
        push into array choices, "geben"
        push into array choices, "gibst"
        push into array choices, "gibt"
        push into array choices, "gebt"
    done
    else if var verb matches "tu" or var verb matches "mach" do
        push into array choices, var verb
        for each new var ending in array endings do
            push into array choices, var verb concat var ending
        done
        for each new var ending in array endings do
            push into array choices, "tu" concat var ending
        done
        for each new var ending in array endings do
            push into array choices, "mach" concat var ending
        done
        push into array choices, "do_general"
    done
    else if var verb matches /(<[gdm]>)l$/ do
        push into array choices, var verb
        for each new var ending in array endings do
            push into array choices, var verb concat var ending
        done
        do regex using var verb: /(<[gdm]>)l$/, "$0el"
        push into array choices, var verb
        for each new var ending in array endings do
            push into array choices, var verb concat var ending
        done
    done
    else do
        push into array choices, var verb
        for each new var ending in array endings do
            push into array choices, var verb concat var ending
        done
    done
    
    set new var verbs to join with "|", items of array choices
    do return with var verbs
done

define action find_mode with var input, var only_learn, var lang, var path do
    if var only_learn do
        print "Sentence should only be learned!"
        print new line
        
        do return with "learn"
    done
    else if var input matches /<[?]>/ do
        print "Sentence contains a question mark"
        print new line
        
        do return with "question"
    done
    else if (not var input matches /_no-question_/) and lc(var input) matches /^((kannst\s)|(kann\s))/ do
        print "Sentence contains a question with can..."
        print new line
        
        do return with "question"
    done
    else if (not var input matches /_no-question_/) and lc(var input) matches /^(<[A-Za-z]>+?)\s/ do
        set new array tags to compute_tags with $0, var lang, var path
        if from array tags 1st item matches /v/ and not from array tags 1st item matches /adv/ do
            print "Sentence contains a verb as first word..."
            print new line
            
            do return with "question"
        done
    done
    else if (not var input matches /_no-question_/) and lc(" " concat var input concat " ") matches /(<[,]>)|(komma)/ and (" " concat var input concat " ") matches /((\swas\s)|(\swer\s)|(\swie\s)|(\swo\s)|(\swann\s)|(\swieso\s)|(\swarum\s)|(\swes)|(\swen\s)|(\swem\s)).*?(<[,]>|(komma))/ do
        print "Sentence contains a question word and sub clauses"
        print new line

        do return with "question"
    done
    else if (not var input matches /_no-question_/) and lc(" " concat var input concat " ") matches /(\swas\s)|(\swer\s)|(\swie\s)|(\swo\s)|(\swann\s)|(\swieso\s)|(\swarum\s)|(\swes)|(\swen\s)|(\swem\s)/ and not lc(" " concat var input concat " ") matches /(<[,]>)|(komma)/ do
        print "Sentence contains a question word"
        print new line

        do return with "question"
    done
    else if lc(var input) matches /enumall/ do
        print "Sentence contains a enumeration request"
        print new line

        do return with "question"
    done
    print "Sentence contains a statement"
    print new line
    do return with "statement"
done

define action but_feature_is_useful with var input do
    if (" " concat var input concat " ") matches /(\swas\s)|(\swer\s)|(\swie\s)|(\swo\s)|(\swann\s)|(\swieso\s)|(\swarum\s)|(\swes)|(\swen\s)|(\swem\s)/ and not lc(" " concat var input concat " ") matches /(<[,]>)|(komma)/ do
        do return with 0
    done
    
    if lc(" " concat var input concat " ") matches /(\sdas\s)/ and not lc(" " concat var input concat " ") matches /(<[,]>)|(komma)/ do
        if lc(" " concat var input concat " ") matches /(\sist\s)|(\ssind\s)/ do
            do return with 1
        done
    done
    
    if lc(" " concat var input concat " ") matches /(\shast\s)|(\shat\s)|(\shabe\s)/ do
        do return with 1
    done
    
    do return with 0
done

define action use_bug_feature with array results, hash parsed do
    for each new array result in array results do
        set new array clause to an empty array
        
        push into array clause, ''
        if from array result item [ 1 ] item [ 3 ] matches /nicht/ do
            push into array clause, 'und auch'
        done
        else do
            push into array clause, 'aber'
        done
        
        set new var objects to ''
        set new array objects_separated to from hash parsed item { 'objects' }
        for each new array obj in array objects_separated do
            set var objects to var objects concat " "
            set var objects to var objects concat from array obj 1st item
        done
        do regex using var objects: /^\s/, "", :global
        
        if var objects matches /^\sein/ do
            push into array clause, 'k' concat var objects
        done
        else do
            push into array clause, 'nicht ' concat var objects
        done
        push into array clause, ''
        
        set var objects to lc with var objects
        set new var lastnoun to var objects
        do regex using var lastnoun: /^.*?\s/, "", :global
        if not lc( from array result item [ 1 ] item [ 1 ] concat " " concat from array result item [ 1 ] item [ 2 ] concat " " concat from array result item [ 1 ] item [ 3 ] ) matches /var objects/ do
            if not lc( from array result item [ 1 ] item [ 1 ] concat " " concat from array result item [ 1 ] item [ 2 ] concat " " concat from array result item [ 1 ] item [ 3 ] ) matches /var lastnoun/ do
                push into array result, array clause
            done
        done
    done
    
    do return with array results
done

define action use_random with var input, var current_language, var path, var mode do
    set new array random to an empty array

    print "Mode is: "
    print var mode
    print new line

    if var mode matches "statement" do
        push into array random, "Ich habe dich leider nicht verstanden."
        push into array random, "Hmm."
        push into array random, "Ah."
        push into array random, "Aha."
        push into array random, "Hmm."
        push into array random, "Gut."
        push into array random, "Ja."
        push into array random, "Oh."
        push into array random, "Klar."
    done
    else do
        print "Input is: "
        print var input
        print new line
        if lc(" " concat var input concat " ") matches /(\sja\s)|(\snein\s)|(\swas\s)|(\swer\s)|isunknown|(\swie\s)|(\swo\s)|(\swann\s)|(\swen\s)|(\swem\s)|(\swelch)/ do
            push into array random, "Da kann ich dir leider keine Antwort geben."
            push into array random, "Keine Ahnung."
            push into array random, "Keine Ahnung, das kann ich dir nicht sagen."
            push into array random, "Keine Ahnung, das kann ich nicht sagen."
            push into array random, "Tut mir leid, das weiss ich nicht."
            push into array random, "Sorry, Keine Ahnung."
            push into array random, "Tut mir leid, das kann ich nicht sagen."
            push into array random, "Hm, das kann ich nicht sagen."
            push into array random, "Hm, das kann ich dir nicht sagen."
            push into array random, "Das weiss ich nicht."
            push into array random, "Ich weiss das nicht, kannst du es mir sagen?"
            push into array random, "Wenn ich das wuesste..."
            push into array random, "Ich stehe gerade auf dem Schlauch."
            push into array random, "Ich stehe wohl gerade auf dem Schlauch."
            push into array random, "Diese Eingabe kann ich nicht verarbeiten."
            push into array random, "Auf diese Eingabe kann ich nicht antworten."
            push into array random, "Darauf kann ich noch nicht antworten."
            push into array random, "Das kann ich leider nicht beantworten."
            push into array random, "Fuer diese Eingabe fehlt mir das notwendige Wissen."
            push into array random, "Auf alles habe ich leider keine Antwort..."
            push into array random, "Die Antwort auf diese Eingabe ist mir unbekannt."
            push into array random, "Zur Zeit kann ich diese Eingabe nicht beantworten."
            push into array random, "Momentan ist es mir nicht moeglich diese Eingabe zu beantworten."
            push into array random, "Mein Wissensspeicher ist begrenzt, diese Eingabe kann ich nicht verarbeiten."
            push into array random, "Fuer diese Eingabe ist keine Antwort in meinen Daten vorhanden."
            push into array random, "Tut mir leid, aber auf diese Eingabe habe ich keine korrekte Antwort. "
            push into array random, "Das kann ich momentan noch nicht beantworten."
            push into array random, "Fuer diese Eingabe fehlt mir momentan das notwendige Wissen, um diese genau zu beantworten."
            push into array random, "Bitte nicht boese sein, aber auf diese Eingabe habe ich keine Antwort."

            push into array random, items of array random
        done
        else if lc(" " concat var input concat " ") matches /(\sja\s)|(\snein\s)/ do
            push into array random, "Wieso nicht?"
            push into array random, "Ja."
            push into array random, "Ja, klar."
            push into array random, "Ja klar."
            push into array random, "Natuerlich."
            push into array random, items of array random
        done
        else if lc(" " concat var input concat " ") matches /(\swarum\s)|(\swieso\s)|(\swes)/ do
            push into array random, "Wieso nicht?"
            push into array random, "Keine Ahnung."
            push into array random, "Keine Ahnung, das kann ich dir nicht sagen."
            push into array random, "Keine Ahnung, das kann ich nicht sagen."
            push into array random, "Hm, das kann ich nicht sagen."
            push into array random, "Hm, das kann ich dir nicht sagen."
            push into array random, "Das weiss ich nicht."
            push into array random, "Ich weiss das nicht, kannst du es mir sagen?"
            push into array random, items of array random
        done
        else do
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."
            push into array random, "Nein."

            if lc(" " concat var input concat " ") matches /(\shast\s)/ do
                push into array random, "Nein, habe ich leider verliehen." 
                push into array random, "Nein, ich bin nuechtern." 
                push into array random, "Nein, ich habe eine Menge Freunde." 
                push into array random, "Nein, ich habe viele Freunde und Bekannte." 
            done
            if lc(" " concat var input concat " ") matches /(\smagst\s)/ do
                push into array random, "Nein, ich mag das nicht."
            done
            push into array random, "Nein eigentlich so gut wie nie." 
            push into array random, "Nein, ganz im Gegenteil." 
            push into array random, "Nein, ganz und gar nicht."
            push into array random, "Nein, keinesfalls." 
            push into array random, "Nein, ich sehe keinen Grund dazu ."
            push into array random, "Nein, ich vertreibe mir mit chatten die Langeweile." 
            push into array random, "Nein, tu ich sicher nicht." 
            push into array random, "Nein, nicht direkt, darueber will ich nicht reden." 
            push into array random, "Nein, nur ganz selten." 
            push into array random, "Nicht falsch verstehen, aber ich denke nicht das dich das etwas angeht." 
            if lc(" " concat var input concat " ") matches /(\sviel\s)/ do
                push into array random, "Nicht gerade wenig." 
                push into array random, "Nicht mehr und nicht weniger als andere." 
            done
            if lc(" " concat var input concat " ") matches /(\sfeig)/ do
                push into array random, "Nicht feige, nur vorsichtig."
            done
        done
    done
    
    for each new var r in array random do
        set var r to [ 0, var r ]
    done

    do return with array random
done

define action check_invoke with var statement do
    set new var appname to ""
    set new var statement_lower to lc with var statement
    
    if var statement_lower matches /^rufe (.*?) auf/ do
        set var appname to $0
    done
    if var statement_lower matches /^ruf (.*?) auf/ do
        set var appname to $0
    done
    if var statement_lower matches /^starte (.*)/ do
        set var appname to $0
    done
    if var statement_lower matches /^start (.*)/ do
        set var appname to $0
    done
    if var statement_lower matches /^run (.*)/ do
        set var appname to $0
    done
    if var statement_lower matches /^fuehre (.*?) aus/ do
        set var appname to $0
    done
    if var statement_lower matches /^fuehr (.*?) aus/ do
        set var appname to $0
    done
    
    do return with var appname
done

define action check_sentence_for_weather with var input do
    if lc(var input) matches /wetter in ([^\s]+(?:\san de.\s[^\s]+)?(?:\sin\s[^\s]+)?)/ do
        if $0 do
            set new var city to $0
            do regex using var city: /an dem/, "am", :global
            print "I have to check the weather for " concat var city
            print new line
            do return with var city
        done
        else do
            print "I have to check the weather, but there is a bad syntax: " concat var input
            print new line
        done
    done
    else do
        print "I don't have to check the weather"
        print new line
    done
    
    do return with ''
done

define action check_for_weather with var place, var lang, var path do
    do chdir with var path
    do regex using var place: /\s+/, "\\s", :global
    do system with "curl -A \"Mozilla/5.0 (X11; U; Linux x86_64; de; rv:1.9.0.13) Gecko/2009080315 Ubuntu/9.04 (jaunty) IE/4.0\" -s -o weather.txt http://www.wetter.com/suche/?search=" concat var place concat "&search_type_weather=1&search_type_site=1"
    
    set new var pro_file_name to "./lang_" concat var lang concat "/weather.pro"
    set new var weather_pro_file to handle for file name var pro_file_name, write
    do close with var weather_pro_file
    
    set new var search_results to handle for file name "weather.txt", read
    for each new var line from var search_results do
        if var line matches /["]search_result["]/ do
            set new var url to var line
            do regex using var url: /^.*?http/, "http", :global
            do regex using var url: /html.*?$/, "html", :global
            print var url
            print new line
            
            set new var name to ''
            set new var temperature to ''
            set new var weather to ''
            
            do wait 2 seconds
            do system with "curl -A \"Mozilla/5.0 (X11; U; Linux x86_64; de; rv:1.9.0.13) Gecko/2009080315 Ubuntu/9.04 (jaunty) IE/4.0\" -s -o weather-city.txt " concat var url
            set new var city to handle for file name "weather-city.txt", read
            for each new var line from var city do
                if var line matches /google_kw / do
                    print var line concat new line
                    do regex using var line: /google_kw/, "", :global
                    do regex using var line: /[<][^>]*?[>]/, "", :global
                    do regex using var line: /[&].*/, "", :global
                    do regex using var line: /<[^a-zA-Z0-9,\s]>/, "", :global:i
                    do regex using var line: /^\s+/, "", :global:i
                    do regex using var line: /\s+$/, "", :global:i
                    do regex using var line: /,/, " in ", :global
                    set new var unwanted_chars to '="'
                    do regex using var line: /<[var unwanted_chars]>/, "", :global
                    print var line concat new line
                    if var line do
                        set var name to var line
                    done
                done
                if var line matches /deg text_l temp_w/ do
                    set new array parts to split with /<.div>/, var line
                    set var line to from array parts 1st item
                    do regex using var line: /[<][^>]*?[>]/, "", :global
                    do regex using var line: /[&].*/, "", :global
                    do regex using var line: /[^a-zA-Z0-9,. ]/, "", :global:i
                    do regex using var line: /,/, " in ", :global
                    if var line do
                        set var temperature to var line
                        
                        print var line
                        print new line
                    done
                done
                if var line matches /deg text_l temp_w/ do
                    set new array parts to split with /<.div>/, var line
                    set var line to from array parts 2nd item
                    do regex using var line: /[<][^>]*?[>]/, "", :global
                    do regex using var line: /[&].*/, "", :global
                    do regex using var line: /[^a-zA-Z0-9,. ]/, "", :global:i
                    do regex using var line: /,/, " in ", :global
                    if var line do
                        set var weather to var line
                        
                        print var line
                        print new line
                    done
                done
            done
            do close with var city
            
            set new var weather_pro_file to handle for file name var pro_file_name, append
            print into var weather_pro_file data "ist <> es <>  <> " concat var weather concat " in " concat var name concat " <> (true)"
            print into var weather_pro_file data new line
            print into var weather_pro_file data "sind <> es <> " concat var temperature concat " grad celsius <> in " concat var name concat " <> (true)"
            print into var weather_pro_file data new line
            print into var weather_pro_file data "sind <> es <> " concat var temperature concat " grad <> in " concat var name concat " <> (true)"
            print into var weather_pro_file data new line
            print into var weather_pro_file data "ist <> die temperatur <> " concat var temperature concat " grad <> in " concat var name concat " <> (true)"
            print into var weather_pro_file data new line
            print into var weather_pro_file data "ist <> das wetter <> " concat var weather concat " bei " concat var temperature concat " grad <> in " concat var name concat " <> (true)"
            print into var weather_pro_file data new line
            print into var weather_pro_file data new line
            do close with var weather_pro_file

        done
    done
    do close with var search_results
    
    do reread_pro_file with var pro_file_name
    
    do return without arguments
done

define action replace_he with var text, var replacement do
    do regex using var text: /\s+?(er|ihn)\s+?/, " var replacement ", :global:i
    do return with var text
done

define action replace_she with var text, var replacement do
    do regex using var text: /\s+?(sie)\s+?/, " var replacement ", :global:i
    do return with var text
done

define action verb_category with var verb do
    if var verb matches /\// do
        do return with ""
    done

    if var verb matches /(muss)|(muessen)|(musst)|(muesse)|(muesste)|(musste)|(mussten)/ do
        do return with "must"
    done
    if var verb matches /(will)|(willst)|(wollte)|(wollten)|(wolltest)|(wolltet)/ do
        do return with "want"
    done
    if var verb matches /(kann)|(kannst)|(konnte)|(konntest)|(konnten)|(konntet)/ do
        do return with "can"
    done
    if var verb matches /(koenne|koennen|koennte|koenntest|koennten|koenntet|koennt)/ do
        do return with "can"
    done
    if var verb matches /(darf)|(darfst)|(dueftest)|(duerften)|(duerftet)|(duerfte)/ do
        do return with "may"
    done
    if var verb matches /(soll)|(sollst)|(sollen)|(solltest)|(solltet)|(sollte)/ do
        do return with "should"
    done
    
    do return with ""
done

define action noun_for_anonymous without arguments do
    do return with "man"
done

define action adj_for_already without arguments do
    do return with "schon"
done

define action adj_for_still without arguments do
    do return with "noch"
done

define action adj_for_not without arguments do
    do return with "nicht"
done

define action upper_case_correction with var phrase, hash tags, var lang, var path do
    set new array words to split with /\s+?/, var phrase
    
    for each new var word in array words do
        if not from hash tags item { var word } do
            set new var word_to_check to var word
            do regex using var word_to_check: /<[^a-zA-Z0-9-]>/, "", :global:i
            set from hash tags item { var word } to compute_tags with var word_to_check, var lang, var path
        done
        if from hash tags item { var word } 1st item matches /n/ and not from hash tags item { var word } 1st item matches /linking|question/ do
            set new array parts_of_word to split with /<[-]>/, var word
            for each new var part in array parts_of_word do
                set var part to ucfirst with var part
            done
            set var word to join '-', items of array parts_of_word
            set var word to ucfirst with var word
        done
    done
    
    set var phrase to join ' ', items of array words
    
    set new array verb_prefixes to items-returning keys with items of hash builtin_verb_prefixes
    
    for each new var prefix in array verb_prefixes do
        if from hash builtin_verb_prefixes_no_split item { var prefix } do
            go to next
        done
        if from hash builtin_auxiliary_verbs item { var prefix } and not from hash builtin_verb_prefixes_with_auxiliary_verbs item { var prefix } do
            go to next
        done
        if var phrase matches /kann|soll|muss|muess|darf/ do
            go to next
        done
        
        if lc(var phrase) matches /(andro)/ do
            go to next
        done
        if lc(var phrase) matches /\.\.\./ do
            go to next
        done
        
        if var phrase matches /\s($prefix)(<[a-zA-Z0-9]><[a-zA-Z0-9]><[a-zA-Z0-9]>+?)(\s|$)/ do
            print "possible verb: "
            print lc( $0 concat $1 )
            print " = "
            print from hash tags item { lc( $0 concat $1 ) } 1st item
            print new line
            
            if (not from hash tags item { lc( $0 concat $1 ) } 1st item matches /v/) or from hash tags item { lc( $0 concat $1 ) } 1st item matches /adv/ or from hash tags item { lc( $0 concat $1 ) } 1st item matches /adj/ do
                print "no verb to replace... (1)"
                print new line
                go to next
            done

            do regex using var phrase: /\s($prefix)(<[a-zA-Z0-9]>+?)(\s?.*?)<[,]>/, " $1$2 $0,", :global
            do regex using var phrase: /\s($prefix)(<[a-zA-Z0-9]>+?)(\s?.*?)$/, " $1$2 $0", :global
            
            if var phrase not matches /<[?]>/ do
                do regex using var phrase: /<[.]>/, "", :global
                set var phrase to var phrase concat "."
            done
        done
    done
    
    do return with var phrase
done

define action to_verb_root_left with var verb, var lang, var path do
    set new array verb_prefixes to items-returning keys with items of hash builtin_verb_prefixes
    
    set new var allprefix to ''
    
    set new var last_verb to ''
    while not var verb matches var last_verb do
        set var last_verb to var verb
        
        if length(var verb) > 4 and var verb matches /<[aeiou]>/ do
            for each new var prefix in array verb_prefixes do
                if var verb matches /^var prefix/ do
                    do regex using var verb: /^var prefix/, "", :i
                    set var allprefix to var allprefix concat var prefix
                    go to last
                done
            done
            
            if var verb matches /^ver/ and not var verb matches /^verge/ do
                do regex using var verb: /^ver/, "", :i
                set var allprefix to var allprefix concat "ver"
            done
            if var verb matches /^ge/ and length(var verb) > 5 and not var verb matches /^gelt/ do
                do regex using var verb: /^ge/, "", :i
                set var allprefix to var allprefix concat "ge"
            done
            if var verb matches /^be/ and length(var verb) > 6 and not var verb matches /^bei|ber/ do
                do regex using var verb: /^be/, "", :i
                set var allprefix to var allprefix concat "be"
            done
            if var verb matches /^zu/ do
                do regex using var verb: /^zu/, "", :i
                set var allprefix to var allprefix concat "zu"
            done
        done
    done

    do return with [ var verb, var allprefix ]
done

define action to_verb_root_right with var verb, var lang, var path do
    
    if var verb matches /e<[rl]>n$/ do
        if var verb matches /h/ do
            do regex using var verb: /(<[rl]>)n$/, "$0", :global
        done
        else do
            do regex using var verb: /(e<[rl]>)n$/, "$0", :global
        done
    done
    
    else if var verb matches /eigen$/ do
        do regex using var verb: /en$/, "", :global
    done
    else if var verb matches /igen$/ do
        do regex using var verb: /igen$/, "", :global
    done
    else if var verb matches /lichen$/ do
        do regex using var verb: /lichen$/, "", :global
    done
    
    else if var verb matches /eien$/ do
        do regex using var verb: /en$/, "", :global
    done
    else if var verb matches /ien$/ do
        do regex using var verb: /n$/, "", :global
    done
    else if var verb matches /en$/ do
        do regex using var verb: /en$/, "", :global
    done
    else if var verb matches /n$/ do
        do regex using var verb: /n$/, "", :global
    done
    
    do return with var verb
done

define action to_verb_root with var verb, var lang, var path do

    
    set new array verb_and_prefix to to_verb_root_left with var verb, var lang, var path
    set var verb to from array verb_and_prefix 1st item

    set var verb to to_verb_root_right with var verb, var lang, var path
    
    do return with var verb
done

define action to_verb_prefix with var verb, var lang, var path do

    
    set new array verb_and_prefix to to_verb_root_left with var verb, var lang, var path
    set new var prefix to from array verb_and_prefix 2nd item
    
    set var verb to to_verb_root_right with var verb, var lang, var path
    
    do return with var prefix
done

define action to_verb_nucleus_right with var verb, var lang, var path do

    set new flag has_h to 0

    if var verb matches /h$/ do
        set flag has_h to 1
        do regex using var verb: /h$/, "", :i
    done
    
    if var verb matches /(ei|au|eu|aeu|ou|ie|aa|ee|oo|uu|oeu|oe|ue|ae)$/ do
        do return with $0
    done
    if var verb matches /(a|e|i|o|u)(a|e|i|o|u)$/ do
        do return with $0
    done
    if var verb matches /(a|e|i|o|u)$/ do
        do return with $0
    done
    
    do return with var verb
done

define action to_verb_nucleus with var verb, var lang, var path do
    set new var postnucleus to to_verb_postnucleus with var verb, var lang, var path
    do regex using var verb: /var postnucleus$/, "", :i
    
    set var verb to to_verb_nucleus_right with var verb, var lang, var path
    
    do return with var verb
done

define action to_verb_prenucleus_right with var verb, var lang, var path do

    set new flag has_h to 0

    if var verb matches /h$/ do
        set flag has_h to 1
        do regex using var verb: /h$/, "", :i
    done
    
    set new var postnucleus to to_verb_postnucleus with var verb, var lang, var path
    do regex using var verb: /var postnucleus$/, "", :i
    set new var nucleus to to_verb_nucleus with var verb, var lang, var path
    do regex using var verb: /var nucleus$/, "", :i
    
    do return with var verb
done

define action to_verb_prenucleus with var verb, var lang, var path do

    set var verb to to_verb_prenucleus_right with var verb, var lang, var path
    
    do return with var verb
done

define action to_verb_postnucleus_right with var verb, var lang, var path do

    set new var postnucleus to ''

    if var verb matches /(d)er$/ do
        set var postnucleus to "er" concat var postnucleus
        do regex using var verb: /(d)er$/, "$0", :i
    done
    
    while var verb matches /(<[bcdfghjklmnpqrstvwxyz]>)$/ do
        set var postnucleus to $0 concat var postnucleus
        do regex using var verb: /$0$/, "", :i
    done
    
    do return with var postnucleus
done

define action to_verb_postnucleus with var verb, var lang, var path do

    set var verb to to_verb_postnucleus_right with var verb, var lang, var path
    
    do return with var verb
done

define action to_verb_conjugation with var verb, var pre, var lang, var path do

    set new var verb_nucleus to to_verb_nucleus with var verb, var lang, var path
    set new var verb_prefix to to_verb_prefix with var verb, var lang, var path
    if not var verb_prefix do
        set var verb_prefix to var pre
    done
    set new var verb_prenucleus to to_verb_prenucleus with var verb, var lang, var path
    set new var verb_postnucleus to to_verb_postnucleus with var verb, var lang, var path
    
    set new var verb_past_nucleus to var verb_nucleus
    set new var verb_past_prefix to var verb_prefix
    set new var verb_past_prenucleus to var verb_prenucleus
    set new var verb_past_postnucleus to var verb_postnucleus
    
    set new var verb_participle_nucleus to var verb_nucleus
    set new var verb_participle_prefix to var verb_prefix
    set new var verb_participle_prenucleus to var verb_prenucleus
    set new var verb_participle_postnucleus to var verb_postnucleus

    print "verb:             " concat var verb concat new line
    print "verb_nucleus:     " concat var verb_nucleus concat new line
    print "verb_prefix:      " concat var verb_prefix concat new line
    print "verb_prenucleus:  " concat var verb_prenucleus concat new line
    print "verb_postnucleus: " concat var verb_postnucleus concat new line
    
    set new flag is_strong_verb to 0
    
    # irregular
    
    # s-ei-n
    if (not flag is_strong_verb) and var verb_nucleus matches /^(ei)$/ and var verb_prenucleus matches /(s)/ and var verb_postnucleus matches /^$/ do
        set var verb_past_nucleus to 'i'
        set var verb_participle_nucleus to 'e'
        set var verb_past_prenucleus to ''
        set var verb_past_postnucleus to 'st'
        set var verb_participle_prenucleus to 'w'
        set var verb_participle_postnucleus to 's'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # g-e-h-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(g)/ and var verb_postnucleus matches /^(h)$/ do
        set var verb_past_nucleus to 'i'
        set var verb_participle_nucleus to 'a'
        set var verb_past_postnucleus to 'ng'
        set var verb_participle_postnucleus to 'ng'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # w-i-ss-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(i)$/ and var verb_prenucleus matches /(w)/ and var verb_postnucleus matches /^(ss)$/ do
        set var verb_past_nucleus to 'u'
        set var verb_participle_nucleus to 'u'
        set var verb_past_postnucleus to 'sste'
        set var verb_participle_postnucleus to 'sst'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    
    # 4th
    
    # ge-b-ae-r-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(ae)$/ and var verb_prenucleus matches /(b)/ and var verb_postnucleus matches /^(r)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # be-f-e-hl- / empf-e-hl-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(f|empf|bef)/ and var verb_postnucleus matches /^(hl)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # k-o-mm-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(o)$/ and var verb_prenucleus matches /(k|gek)/ and var verb_postnucleus matches /^(mm)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        set var verb_past_postnucleus to 'm'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # n-e-hm-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(n)/ and var verb_postnucleus matches /^(hm|m)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        set var verb_past_postnucleus to 'hm'
        set var verb_participle_postnucleus to 'mm'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # er-schr-e-ck-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(schr|erschr)/ and var verb_postnucleus matches /^(ck|k)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        set var verb_past_postnucleus to 'k'
        set var verb_participle_postnucleus to 'ck'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # spr-e-ch- / st-e-ch- / st-e-hl- / br-e-ch-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e|i)$/ and var verb_prenucleus matches /(spr|st|erst|st|br)/ and var verb_postnucleus matches /^(ch|hl)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # tr-e-ff-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(tr)/ and var verb_postnucleus matches /^(ff|f)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'o'
        set var verb_past_postnucleus to 'f'
        set var verb_participle_postnucleus to 'ff'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # ver-g-ae-r-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(ae)$/ and var verb_prenucleus matches /(g)/ and var verb_postnucleus matches /^(r)$/ do
        set var verb_past_nucleus to 'o'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # sch-e-r- / schw-oe-r- / er-w-ae-g-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e|oe|ae)$/ and var verb_prenucleus matches /(sch|schw|w|erw)/ and var verb_postnucleus matches /^(r|g)$/ do
        set var verb_past_nucleus to 'o'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # w-e-b-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(w)/ and var verb_postnucleus matches /^(b)$/ do
        set var verb_past_nucleus to 'o'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    
    # 5th
    
    # e-ss- / fr-e-ss- / m-e-ss- / ver-g-e-ss- 
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(|fr|m|verg|g|)/ and var verb_postnucleus matches /^(ss)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'e'
        if var verb_participle_prenucleus matches "" do
            set var verb_participle_prenucleus to "g"
        done
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # s-i-tz-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(i)$/ and var verb_prenucleus matches /(s)/ and var verb_postnucleus matches /^(tz)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'e'
        set var verb_past_postnucleus to 'ss'
        set var verb_participle_postnucleus to 'ss'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # b-i-tt-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(i)$/ and var verb_prenucleus matches /(b)/ and var verb_postnucleus matches /^(tt|t)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'e'
        set var verb_past_postnucleus to 't'
        set var verb_participle_postnucleus to 't'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # g-e-b- / tr-e-t-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(g|erg|verg|tr)/ and var verb_postnucleus matches /^(b|t)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'e'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # l-e-s- / l-ie-g- / l-e-g- / ge-n-e-s- / ge-sch-e-h-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e|ie)$/ and var verb_prenucleus matches /^(l|n|gen|sch|gesch)$/ and var verb_postnucleus matches /^(g|s|h)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'e'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    
    # 6th
    
    # f-a-hr- / gr-a-b- / l-a-d- / sch-a-ff- / schl-a-g- / tr-a-g-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(a)$/ and var verb_prenucleus matches /(f|gr|l|sch|schl|tr)/ and var verb_postnucleus matches /^(hr|r|b|d|ff|g)$/ do
        set var verb_past_nucleus to 'u'
        set var verb_participle_nucleus to 'a'
        if var verb_postnucleus matches /^(ff)$/ do
            set var verb_past_postnucleus to "f"
        done
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # h-e-b-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(h)/ and var verb_postnucleus matches /^(b)$/ do
        set var verb_past_nucleus to 'o'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # schw-oe-r-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(oe)$/ and var verb_prenucleus matches /(schw)/ and var verb_postnucleus matches /^(r)$/ do
        set var verb_past_nucleus to 'o'
        set var verb_participle_nucleus to 'o'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # w-a-chs- / w-a-sch-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(a)$/ and var verb_prenucleus matches /(w)/ and var verb_postnucleus matches /^(chs|sch)$/ do
        set var verb_past_nucleus to 'u'
        set var verb_participle_nucleus to 'a'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    
    # 6th
    
    # l-a-ss-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(a)$/ and var verb_prenucleus matches /(l)/ and var verb_postnucleus matches /^(ss)$/ do
        set var verb_past_nucleus to 'ie'
        if var verb_past_postnucleus matches /^(ll)$/ do
            set var verb_past_postnucleus to "l"
        done
        set flag is_strong_verb to 1
    done
    
    # l-au-f- / st-o-ss- / f-a-ll / h-a-lt- / r-u-f- / bl-a-s- / br-a-t-
    # r-a-t- / schl-a-f-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(au|o|a|u)$/ and var verb_prenucleus matches /(l|st|f|gef|h|r|bl|br|schl)/ and var verb_postnucleus matches /^(f|ss|ll|lt|s|t)$/ do
        set var verb_past_nucleus to 'ie'
        if var verb_past_postnucleus matches /^(ll)$/ do
            set var verb_past_postnucleus to "l"
        done
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # s-e-h-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(e)$/ and var verb_prenucleus matches /(s)/ and var verb_postnucleus matches /^(h)$/ do
        set var verb_past_nucleus to 'ie'
        set var verb_past_postnucleus to "ht"
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # f-a-ng- / h-ae-ng-
    if (not flag is_strong_verb) and var verb_nucleus matches /^(a|ae)$/ and var verb_prenucleus matches /(f|h)/ and var verb_postnucleus matches /^(ng)$/ do
        set var verb_past_nucleus to 'i'
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    
    # t-u-n
    if (not flag is_strong_verb) and var verb_nucleus matches /^(u)$/ and var verb_prenucleus matches /(t)/ and var verb_postnucleus matches /^(|n|en|)$/ do
        set var verb_past_nucleus to 'a'
        set var verb_participle_nucleus to 'a'
        set var verb_past_postnucleus to "t"
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        set flag is_strong_verb to 1
    done
    

    
    
    # 1st
    
    if (not flag is_strong_verb) and var verb_nucleus matches /ei/ do
        # bl-ei-b- / ge-d-ei-h- / l-ei-h- / m-ei-d- / pr-ei-s- / r-ei-b- / sch-ei-d- /
        # schr-ei-b- / schr-ei-h- / schw-ei-g- / sp-ei- / st-ei-g- / tr-ei-b- / w-ei-s- / z-ei-h-
        #
        # b-ei-ss- / bl-ei-ch- / gl-ei-ch- / gl-ei-t- / gr-ei-f- / k-ei-f- / kn-ei-f- /
        # kn-ei-p- / kr-ei-ss- / kr-ei-sch- / l-ei-d- / pf-ei-ff- / r-ei-ss- / r-ei-t- /
        # sch-ei-ss- / schl-ei-ch- / schl-ei-f- / schl-ei-ss- / schm-ei-ss- / schn-ei-d- /
        # schr-ei-t- / spl-ei-ss- / str-ei-ch- / str-ei-t- / w-ei-ch- / 
    
        if var verb_prenucleus matches /(bl|d|l|m|pr|r|sch|schr|schw|sp|st|tr|w|z)/ or var verb_prenucleus matches /(b|bl|gl|gr|k|kn|kr|kr|l|pf|r|sch|schl|schm|schn|schr|spl|str|w)/ do
            if var verb_postnucleus matches "" or var verb_postnucleus matches /^(b|s|n|g|d)$/ or var verb_postnucleus matches "h" do
                set var verb_past_nucleus to 'ie'
                set var verb_participle_nucleus to 'ie'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                if var verb_past_postnucleus matches "d" and var verb_prenucleus matches /^(schn|l)$/ do
                    set var verb_past_nucleus to 'i'
                    set var verb_participle_nucleus to 'i'
                    set var verb_past_postnucleus to "tt"
                    set var verb_participle_postnucleus to "tt"
                done
                
                set flag is_strong_verb to 1
            done
            else if var verb_postnucleus matches "ss" or var verb_postnucleus matches /^(ch|ss|sch|)$/ do
                set var verb_past_nucleus to 'i'
                set var verb_participle_nucleus to 'i'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                
                set flag is_strong_verb to 1
            done
            else if var verb_postnucleus matches /^(t|f|p|)$/ or var verb_postnucleus matches "h" do
                set var verb_past_nucleus to 'i'
                set var verb_participle_nucleus to 'i'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                set var verb_past_postnucleus to var verb_past_postnucleus concat var verb_past_postnucleus
                set var verb_participle_postnucleus to var verb_participle_postnucleus concat var verb_participle_postnucleus
                
                set flag is_strong_verb to 1
            done
        done
    done
    
    # 2nd
    
    if (not flag is_strong_verb) and ( var verb_nucleus matches /ie/ or ( var verb_nucleus matches /ue/ and var verb_prenucleus matches /(l|tr)/ ) or ( var verb_nucleus matches /au/ and var verb_prenucleus matches /(s)/ ) ) do
        # b-ie-g- / b-ie-t- / fl-ie-g- / fl-ie-g- / fl-ie-h- / fr-ie-r- / ver-l-ie-r- /
        # l-ue-g- / sch-ie-b- / tr-ue-g- / z-ie-h-
        #
        # ver-dr-ie-ss- / fl-ie-ss- / g-ie-ss- / kr-ie-ch- / ge-n-ie-ss- / r-ie-ch- /
        # s-au-f- / s-au-g- / sch-ie-ss- / schl-ie-ss- / spr-ie-ss- 
    
        if var verb_prenucleus matches /(b|fl|fr|sch|st|tr|z|verl|l)/ or var verb_prenucleus matches /(dr|fl|g|kr|n|r|s|schl|spr)/ or ( var verb_nucleus matches /ue/ and var verb_prenucleus matches /(l|tr)/ ) do
            if var verb_postnucleus matches "" or var verb_postnucleus matches /^(g|t|r|b|s|d)$/ or var verb_postnucleus matches "h" do
                set var verb_past_nucleus to 'o'
                set var verb_participle_nucleus to 'o'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                if var verb_postnucleus matches "h" and var verb_prenucleus matches /(z)/ do
                    set var verb_past_postnucleus to "g"
                    set var verb_participle_postnucleus to "g"
                done
                
                if var verb_past_postnucleus matches "d" do
                    set var verb_past_postnucleus to "tt"
                    set var verb_participle_postnucleus to "tt"
                done
                
                set flag is_strong_verb to 1
            done
            else if var verb_postnucleus matches "ss" or var verb_postnucleus matches /^(ch|ss|sch|)$/ do
                set var verb_past_nucleus to 'o'
                set var verb_participle_nucleus to 'o'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                
                set flag is_strong_verb to 1
            done
            else if var verb_postnucleus matches /^(t|f|p|)$/ or var verb_postnucleus matches "h" do
                set var verb_past_nucleus to 'o'
                set var verb_participle_nucleus to 'o'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                set var verb_past_postnucleus to var verb_past_postnucleus concat var verb_past_postnucleus
                set var verb_participle_postnucleus to var verb_participle_postnucleus concat var verb_participle_postnucleus
                
                set flag is_strong_verb to 1
            done
        done
    done
    
    # 3rd
    
    if (not flag is_strong_verb) and var verb_nucleus matches /^i$/ do
        # b-i-nd / dr-i-ng- / f-in-d- / kl-i-ng- / ge-l-i-ng- / r-in-g- / schl-i-ng- /
        # schw-i-nd- / schw-i-ng- / s-i-ng- / s-i-nk- / spr-i-ng- / st-i-nk- / tr-i-nk- /
        # w-in-d- / wr-i-ng- / zw-i-ng-

        if var verb_prenucleus matches /(b|d|dr|f|fl|l|r|sch|schl|schw|s|spr|st|tr|w|wr|zw)/ do
            if var verb_postnucleus matches "" or var verb_postnucleus matches /^(g|t|r|b|k|d|nd|ng|nk)$/ do
                set var verb_past_nucleus to 'a'
                set var verb_participle_nucleus to 'u'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                
                set flag is_strong_verb to 1
            done
        done
    done
    
    if (not flag is_strong_verb) and ( var verb_nucleus matches /^(e)$/ ) do
        # b-e-rg- / b-e-rst- / ver-d-e-rb- / dr-e-sch- / f-e-cht- / fl-e-cht- / g-e-lt- /
        # be-g-i-nn- / gl-i-mm- / h-e-lf- / kl-i-mm- / l-oe-sch- / m-e-lk- / r-i-nn- /
        # zer-sch-e-ll- / sch-e-lt- / schm-e-lz- / schw-e-ll- / schw-i-mm- / s-i-nn- /
        # sp-i-nn- / st-e-rb- / w-e-rb / w-e-rd- / w-e-rf- / ge-w-i-nn- /

        if var verb_prenucleus matches /(f|fl|dr)/ do
            if var verb_postnucleus matches "" or var verb_postnucleus matches /^(sch|cht)$/ do
                set var verb_past_nucleus to 'o'
                set var verb_participle_nucleus to 'o'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                
                set flag is_strong_verb to 1
            done
        done
    done
    
    if (not flag is_strong_verb) and ( var verb_nucleus matches /^(i|e)$/ ) do
        # b-e-rg- / b-e-rst- / ver-d-e-rb- / dr-e-sch- / f-e-cht- / fl-e-cht- / g-e-lt- /
        # be-g-i-nn- / gl-i-mm- / h-e-lf- / kl-i-mm- / l-oe-sch- / m-e-lk- / r-i-nn- /
        # zer-sch-e-ll- / sch-e-lt- / schm-e-lz- / schw-e-ll- / schw-i-mm- / s-i-nn- /
        # sp-i-nn- / st-e-rb- / w-e-rb / w-e-rd- / w-e-rf- / ge-w-i-nn- /

        if var verb_prenucleus matches /(b|d|dr|f|fl|g|gl|h|kl|l|m|r|sch|schm|schw|s|sp|st|w)/ do
            if var verb_postnucleus matches "" or var verb_postnucleus matches /^(rg|rst|rb|sch|cht|lt|nn|mm|lf|lk|ll|lt|lz|rb|rd|rf)$/ do
                set var verb_past_nucleus to 'a'
                set var verb_participle_nucleus to 'o'
                if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
                    set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
                done
                
                set flag is_strong_verb to 1
            done
        done
    done
    
    
    
    if flag is_strong_verb do
        set new var verb_past to var verb_past_prefix concat '-' concat var verb_past_prenucleus concat '-' concat var verb_past_nucleus concat '-' concat var verb_past_postnucleus
        set new var verb_participle to var verb_participle_prefix concat '-' concat var verb_participle_prenucleus concat '-' concat var verb_participle_nucleus concat '-' concat var verb_participle_postnucleus

print var verb concat new line
print var verb_past concat new line
print var verb_participle concat new line
        
        do return with [ var pre concat var verb, var verb_past, var verb_participle ]
    done
    else do
        if ( not var verb_participle_prefix matches /ver|ge|be|zer|er/ ) and ( not var verb_prenucleus matches /ver|ge|be|zer|er/ ) do
            set var verb_participle_prefix to var verb_participle_prefix concat 'ge'
        done
        
        if not var verb_past_postnucleus matches /t/ do
            set var verb_past_postnucleus to var verb_past_postnucleus concat "t"
        done
        
        if not var verb_participle_postnucleus matches /s|z|t|l|f/ do
            set var verb_participle_postnucleus to var verb_participle_postnucleus concat "t"
        done
        
        set new var verb_past to var verb_past_prefix concat '-' concat var verb_past_prenucleus concat '-' concat var verb_past_nucleus concat '-' concat var verb_past_postnucleus
        set new var verb_participle to var verb_participle_prefix concat '-' concat var verb_participle_prenucleus concat '-' concat var verb_participle_nucleus concat '-' concat var verb_participle_postnucleus
        
        do return with [ var pre concat var verb, var verb_past, var verb_participle ]
    done
done

define action make_participle with var participle, var lang, var path do
    do regex using var participle: /<[-]>/, "", :global
    if not var participle matches /(t)$/ do
        set var participle to var participle concat "en"
    done
    do return with var participle
done

define action get_modal_verb_for_verb with var verb, var lang, var path do
    if var verb matches /stolp|lauf|gehe|g(i|a)ng|gewes|sei|bist|ist|bin/ do
        do return with "be"
    done
    do return with "have"
done

define action get_score_answer without arguments do
    do return with [ 0, "Bewertung erfolgreich." ]
done

